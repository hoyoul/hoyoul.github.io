<!DOCTYPE html>
<html>
  <head><title>Markov Decision Policies for Dynamic Video Delivery in Wireless Caching Networks</title>


<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes" />

<link rel="shortcut icon" href="./img/favicon.ico" type="image/x-icon">
<link rel="icon" href="./img/favicon.ico" type="image/x-icon">    

<link rel="stylesheet" href="/css/main.css">

</head>
  <body><header>
  <a href="/" id="logo">
    <img src="http://braindump.frege2godel.me/img/mylogo.png" alt="holy frege">
    <h3><span>H</span>oly <span>F</span>rege's <span id="note">notes</span></h3>
  </a>
    <small>G.frege를 너무 사랑하는 holy가...</small>  
</header>

<div class="container">
  <div class="page">
    <h1 class="collapsed-title">Markov Decision Policies for Dynamic Video Delivery in Wireless Caching Networks</h1>    
      <div class="content">
	<a href="http://braindump.frege2godel.me/postss/20211113074512-%E1%84%82%E1%85%A9%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB_markov_decision_policies_for_dynamic_video_delivery_in_wireless_caching_networks/" alt="Markov Decision Policies for Dynamic Video Delivery in Wireless Caching Networks" class="permalink"><h1>Markov Decision Policies for Dynamic Video Delivery in Wireless Caching Networks</h1></a>      
	<h2 id="참고">참고</h2>
<ul>
<li>논문 순서에 따라 요약하는 방식으로 작성했음.</li>
</ul>
<h2 id="introduction">Introduction</h2>
<ul>
<li>최근 video demand service로 streaming data traffic이 급증하고 있다.</li>
<li>인기 있는 video가 network traffic을 유발.</li>
<li>해결 방법으로, wireless caching network에 대한 연구가 논의.</li>
</ul>
<h3 id="dynamic-video-delivery-결정-문제">dynamic video delivery 결정 문제</h3>
<ul>
<li>어떤 caching node가 사용자와 연결될 것인가? 기존 연구: 채널 세기</li>
<li>어느 정도 수준의 quality video를 보낼것인가? 기존연구: 네트웍 상황을 고려해서 고화질,저화질</li>
<li>보내질 chunk의 양은 어떻게 되는가?</li>
<li>GOAL: 시간에 따른  quality가 최고가 되는것을 목표로 한다.  재생이 중지(delay) 되지 않는다는 constraints(조건)에서&hellip;</li>
</ul>
<h3 id="video-quality와-chunk">video quality와 chunk</h3>
<ul>
<li>네트웍 사정으로 low quality video를 전송할 수 밖에 없을때, 기존 연구에서는 사용자 qos를 고려하지 않음. 즉, low quality video를 보낸다. 왜냐 playback delay때문이다.</li>
<li>네트웍 사정으로 low quality의 video chunk만을 보내는 것보다, 사용자들은 high-quality의 video chunk를 기다릴 수 있다. 여기에는 playback delay가 생기지 않는다는 constraints가 붙는다.</li>
<li>video quality와 chunk사이에는 관계가 있어 보인다. high qualtiy 비디오에는 적은 chunk와 low quality 비디오에는 많은 chunk의 관계가 있는 거 같다.</li>
<li>이 논문에서는 Adaptive video streaming(DASH)를 사용한다고 가정했다. 그래서 사용자가  quality와 chunk를  사용자가 결정할수 있다.</li>
</ul>
<h3 id="논문의-주요-내용">논문의 주요 내용</h3>
<ul>
<li>dynamic video delivery 결정 문제(3가지 고려사항)</li>
<li>위 결정문제에 대한 2가지 최적화방법: lyapunov optimization, dynamic programming.</li>
<li>user mobility에 따른 content delivery 방법.</li>
<li>video quality와 playback delay에 대한 trade-off 처리.</li>
</ul>
<h2 id="network-model">Network Model</h2>
<h3 id="wireless-caching-network-model">wireless caching network model</h3>
<ul>
<li>BS에서 caching node에 video를 이미 저장했다고 가정.</li>
<li>caching node들은 가지고 있는 video quality에 따라 type-1, type-2&hellip;type-l로 나누어짐.</li>
<li>caching node 분포는 PPP(Poisson Point Processes)를 따른다고 가정.</li>
<li>사용자 이동에 따라, 주기적으로 caching node를 선택하고 update한다.</li>
</ul>
<p><a id="figure--"></a></p>
<figure><img src="./img/paper/networkmodel.jpeg"
         alt="Figure 1: caching network model" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 1: </span>caching network model</p>
        </figcaption>
</figure>

<h3 id="user-queue-model">User Queue model</h3>
<ul>
<li>caching node로부터 chunk 단위로 data를 user queue에 넣고 재생.</li>
<li>user queue에 chunk가 없으면 delay가 발생.</li>
<li>user queue는 departure, arrive 과정이 있다.</li>
<li>user queue의 크기는 동적으로 변한다.
(Q(t): backlog 크기,  c: departure chunks, M(t): arrival chunks)</li>
<li>play되는 chunk(departure:c)는 상수로 표시할 수 있지만, arrival chunk는 channel의 noise나 사정에 따라 달라진다.</li>
</ul>
<p><a id="figure--"></a></p>
<figure><img src="./img/paper/queue1.png"
         alt="Figure 2: user queue" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 2: </span>user queue</p>
        </figcaption>
</figure>

<h3 id="channel-model">channel model</h3>
<ul>
<li>위 슬라이드에서 M(t)는 user queue에 도착하는 chunk의 수다.</li>
<li>chunk의 수는 caching node와 네트웍환경에 따라 달라진다.</li>
<li>gaussian 확률분포를 따라서 loss율이 결정된다고 가정한다.</li>
<li>사용자가 선택한 caching node를 a라고 할때 다음과 같은 식이 나온다. (식 전개는 생략)</li>
</ul>
<p><a id="figure--"></a></p>
<figure><img src="./img/paper/link.png"
         alt="Figure 3: caching node link" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 3: </span>caching node link</p>
        </figcaption>
</figure>

<h3 id="the-number-of-chunks">the number of chunks</h3>
<ul>
<li>사용자 Queue에 저장되는 chunk는 caching node와 link rate에 의해 결정</li>
<li>link rate는 다음과 같이 표현. (figure 5)</li>
</ul>
<p><a id="figure--"></a></p>
<figure><img src="./img/paper/link2.png"
         alt="Figure 4: maximum chunks" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 4: </span>maximum chunks</p>
        </figcaption>
</figure>

<p><a id="figure--"></a></p>
<figure><img src="./img/paper/link1.png"
         alt="Figure 5: link rate" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 5: </span>link rate</p>
        </figcaption>
</figure>

<h3 id="distance-based-interference-management">Distance-Based Interference Management</h3>
<ul>
<li>새로운 사용자가 caching node에 associating(연결) 하는 것은 다른 사용자에게 방해가될 수 있다.</li>
<li>거리에 따라 보호해 준다. (safety radius)</li>
<li>Rn(network radius), Ru(exisiting user radius)</li>
<li>새로운 user는 threshold값과 비교를 통해서 link association이 결정.</li>
</ul>
<p><a id="figure--"></a></p>
<figure><img src="./img/paper/interference.jpeg"
         alt="Figure 6: Distance based Interference" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 6: </span>Distance based Interference</p>
        </figcaption>
</figure>

<h2 id="dynamic-video-delivery-policies">Dynamic Video Delivery Policies</h2>
<ul>
<li>다른 2개의 timescale(시간단위)이 사용된다.</li>
<li>목적은 playback을 delay하지 않는 조건에서 최대의 quality chunk를 최대화하는 것이다.</li>
</ul>
<h3 id="video-delivery-decisions">Video Delivery Decisions</h3>
<ul>
<li>3가지 결정
a(t): caching node 결정, q(t): video quality, M(t): the number of chunks</li>
<li>caching node를 결정하는 timescale은 q(t)와 M(t)의 time scale보다 크다.</li>
<li>caching node가 association이 된 상황에서 q(t)와 M(t)의 timescale이 사용된다.</li>
</ul>
<p><a id="figure--"></a></p>
<figure><img src="./img/paper/timescale.jpeg"
         alt="Figure 7: time scale" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 7: </span>time scale</p>
        </figcaption>
</figure>

<h3 id="problem-formualtion">Problem formualtion</h3>
<ul>
<li>video delivery policy가 시간 t에서 어떤 action을 취해야 할 policy라면, value function과
같이 좋고 streaming의 좋고 나쁨을 평가할 수 있어야 한다.</li>
<li>좋은 streaming이라고 평가하기 위해선 3가지 performance metric이 필요하다.</li>
<li>(1) playback delay: 재생이 멈추면 안좋다.</li>
<li>(2) averegy streaming quality:</li>
<li>(3) video quality fluctuation: 매 t 마다 변동이 크면 안좋다.</li>
</ul>
<h3 id="average-streaming-quality-degradation">Average Streaming Quality Degradation</h3>
<ul>
<li>P(q(t))는 매순간의 화질을 말하는데, low quality가 지속되거나 fluctuation이 심하면,  평균값이 커진다.</li>
</ul>
<p><a id="figure--"></a></p>
<figure><img src="./img/paper/degradation.jpeg"
         alt="Figure 8: Quality degradation" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 8: </span>Quality degradation</p>
        </figcaption>
</figure>

<h3 id="average-streaming-quality-degradation-2">Average Streaming Quality Degradation 2</h3>
<ul>
<li>재생이 멈추는 경우의 constraints가 필요. constraints를 만족하지 못하면 Figure8 적용 못함.</li>
</ul>
<p><a id="figure--"></a></p>
<figure><img src="./img/paper/degradation2.png"
         alt="Figure 9: Quality degradation2" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 9: </span>Quality degradation2</p>
        </figcaption>
</figure>

<h2 id="caching-node-decision-policies">Caching node Decision Policies</h2>
<ul>
<li>Caching node decision문제는 Laypunov 방정식을 쓰는 것 같다.</li>
<li>그래서 pass</li>
</ul>
<h2 id="decision-on-quality-level-and-receiving-chunk-amounts">Decision On Quality Level And Receiving Chunk Amounts</h2>
<h3 id="stochastic-shortest-path-problem">Stochastic Shortest Path Problem</h3>
<ul>
<li>cashing node가 결정 되어 있고, 사용자는 q(t)와 M(t)를 선택할 수 있다.(DASH같은 adaptive)</li>
<li>MDP로 나타내고, 최적의 quality level과 chunk amount를 결정할 수 있다.</li>
</ul>
<h4 id="mdp--상태와-action의-정의">MDP (상태와 Action의 정의)</h4>
<p><a id="figure--"></a></p>
<figure><img src="./img/paper/state1.png"
         alt="Figure 10: state space"/><figcaption>
            <p><span class="figure-number">Figure 10: </span>state space</p>
        </figcaption>
</figure>

<p><a id="figure--"></a></p>
<figure><img src="./img/paper/action1.png"
         alt="Figure 11: Action"/><figcaption>
            <p><span class="figure-number">Figure 11: </span>Action</p>
        </figcaption>
</figure>

<ul>
<li>cashing node가 정해졌기 때문에 지원하는 quailty도 정해지고, Queue의 backlog도 유한개로 나타낼수 있다. 그래서 이것을 상태공간으로 한다.</li>
<li>Action은 quality level과 chunk amount의 선택이다.</li>
</ul>
<h4 id="mdp--reward와-상태전이-함수-정의">MDP (Reward와 상태전이 함수 정의)</h4>
<ul>
<li>Reward와 상태 전이 함수는 다음과 같이 정의 된다.</li>
</ul>
<p><a id="figure--"></a></p>
<figure><img src="./img/paper/reward.png"
         alt="Figure 12: Reward" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 12: </span>Reward</p>
        </figcaption>
</figure>

<p><a id="figure--"></a></p>
<figure><img src="./img/paper/stateT.png"
         alt="Figure 13: Probability Transition Function" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 13: </span>Probability Transition Function</p>
        </figcaption>
</figure>

<h3 id="probability-mass-function-of-b-k--t">probability Mass Function of \(B_{k}(t)\)</h3>
<ul>
<li>caching node를 찾을 때도, 그리고 quality degradation 식에서  사용된 constraint 중에, 다음과 같은 것이 있다.</li>
<li>\(B_{k}(t)\) Random Network Event라고 한다.</li>
<li>사용자가 video quality나 chunk를 설정할 때 dependency가 있다고 한다.</li>
<li>$B_{k}(t)$는 우연히 나오는 환경의 요소이기 때문에 Random variable로 계산한다.</li>
</ul>
<p><a id="figure--"></a></p>
<figure><img src="./img/paper/constraint.png"
         alt="Figure 14: constraint" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 14: </span>constraint</p>
        </figcaption>
</figure>

<h3 id="dynamic-programming">Dynamic Programming</h3>
<p><a id="figure--"></a></p>
<figure><img src="./img/paper/dp_1.jpeg"
         alt="Figure 15: dynamic programming" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 15: </span>dynamic programming</p>
        </figcaption>
</figure>

<ul>
<li>우리의 목적은 $g_{k}$값이 누적 cost가 최소로 되는 action(caching node)를 선택한다.</li>
<li>선택된 caching node에서 첫번째 cost부터 kth-frame이 끝날때 까지 더한다.</li>
</ul>
<h4 id="bellman-방정식처럼">Bellman 방정식처럼</h4>
<ul>
<li>$G_{k}$의 값을 재귀 호출식으로 바꿀 수 있다.</li>
<li>여기서 $J_{k}$가 나오는데, ${B_{k}}$에 대한 marginal function이다.</li>
</ul>
<p><a id="figure--"></a></p>
<figure><img src="./img/paper/bellman.jpeg"
         alt="Figure 16: 누적 cost" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 16: </span>누적 cost</p>
        </figcaption>
</figure>

<h3 id="decision-of-quality-and-chunk-amounts">Decision of Quality and Chunk amounts</h3>
<p><a id="figure--"></a></p>
<figure><img src="./img/paper/algorithm.jpeg"
         alt="Figure 17: algorithm" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 17: </span>algorithm</p>
        </figcaption>
</figure>

<h2 id="요약">요약</h2>
<ul>
<li>Dynamic Programming 부분에 대한 이해가 완벽하지 않고, 수식에 대한 이해가 어려웠음.</li>
</ul>
      
      </div>
        
  
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
  

  

  </div>
</div>  

<script src="/js/URI.js" type="text/javascript"></script>
<script src="/js/page.js" type="text/javascript"></script>
</body>
</html>
