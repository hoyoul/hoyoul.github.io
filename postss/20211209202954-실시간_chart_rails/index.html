<!DOCTYPE html>
<html>
  <head><title>실시간 chart [rails]</title>


<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes" />

<link rel="shortcut icon" href="./img/favicon.ico" type="image/x-icon">
<link rel="icon" href="./img/favicon.ico" type="image/x-icon">    

<link rel="stylesheet" href="/css/main.css">

</head>
  <body><header>
  <a href="/" id="logo">
    <img src="http://braindump.frege2godel.me/img/mylogo.png" alt="holy frege">
    <h3><span>H</span>oly <span>F</span>rege's <span id="note">notes</span></h3>
  </a>
    <small>G.frege를 너무 사랑하는 holy가...</small>  
</header>

<div class="container">
  <div class="page">
    <h1 class="collapsed-title">실시간 chart [rails]</h1>    
      <div class="content">
	<a href="http://braindump.frege2godel.me/postss/20211209202954-%E1%84%89%E1%85%B5%E1%86%AF%E1%84%89%E1%85%B5%E1%84%80%E1%85%A1%E1%86%AB_chart_rails/" alt="실시간 chart [rails]" class="permalink"><h1>실시간 chart [rails]</h1></a>      
	<h2 id="참조">참조</h2>
<p><a href="https://codepen.io/nagitch/pen/rNMrXNw">https://codepen.io/nagitch/pen/rNMrXNw</a></p>
<h2 id="참조-분석">참조 분석</h2>
<ul>
<li>실시간 그래프의 원리는 2가지로 나눠서 생각할 수 있다.</li>
</ul>
<h3 id="첫번째-단계-초기화-단계">[첫번째 단계: 초기화 단계]</h3>
<h4 id="timenow-timetail-설정">timeNow, timeTail 설정</h4>
<ul>
<li>초기화 단계는 timeNow와 timeTail이라는 변수를 초기화 한다. timeNow와 timeTail은 dayJS라는 js library를 사용해서 시간을 format화 한다.</li>
<li>timeNow와 timeTail은 x축의 min값과 max값을 설정하는데 사용한다.</li>
</ul>
<p><a id="figure--"></a></p>
<figure><img src="./img/realtime1.png" width="400px" height="300px"/>
</figure>

<h4 id="chartaxis--축--설정">[chartAxis (축)설정]</h4>
<ul>
<li>timeseries종류로 x축을 설정한다. 축의 종류는 3가지가 있다. index와 category, 그리고 timeseries가 있다. 일반적으로 chart를 만들면, x축에 특정 data를 설정하지 않으면, index값이 자동으로 부여된다. random한 값이다. 그런데 category와 timeseries는 x축의 좌표가 시간이라던가, 특정 카테고리를 x축 값으로 사용한다. 그래서 만일 x축에 시간값을 넣고 싶다면, type을 time series로 해야 한다. 그리고 data에서 x축으로 설정할 data를 정해줘야 하는데, 이부분은 data부분에서 다루겠다.</li>
<li>min값과 max값은 차트의 x축의 길이를 설정하는데, 위에서 말했듯이 timeNow와 timeTail로 설정한다. 여기서 설정하는 값은 초기값이다. 매번 갱신작업을 하는데, 그때, 이값도 갱신할 시간에 맞춰 다시 정해진다.</li>
<li>tick은 눈금을 의미한다. fit을 true로 하면, x좌표의 값과 data값을 정확히 일치하는 정보만 x축 눈금으로 보여준다. 이말이 무슨말이냐면, x축을 min값과 max값을 설정하고, fit을 false로 하면, 특정단위로 눈금이 매겨지는 것을 볼수 있다. 반면에 true로 하면 듬성듬성 x축 좌표눈금이 보이게 된다. 이것은 x축의 눈금도 하나의 data로 정의되는데, 시간값으로 되어 있는 배열이다. 일부 시간만 데이터로 가질 수 있기 때문에 모든 시간의 단위별로 x축 데이터가 가질수가 없다. 물론 가질수도 있겠지만, 그래서 fit를 통해서 좌표눈금을 x축 데이터와 맞출것인가를 설정하는 것이다.  예를 들어서, min값과 max값을 정해놓으면 정해진단위로 예를들면, 1초단위로 눈금이 기본적으로 매겨지는데, x축 시간 데이터는 5개밖에 없고, 10분 단위라면 어떻게 할것인가? fit가 true이면, x축 시간데이터에 맞추어 데이터를 매핑해서 보여주기 때문에 5개의 눈금만이 보일 것이다. fit를 false로 하면 x축에는 규칙적인 시간 눈금이 표시되고 그것에 맞추어 데이터들이 x축 데이터에 맞춰 보여질 것이다. 대부분의 경우는 x축으로 사용하는 시간 데이터가 충분치 않기 때문에 false로 한다. 우리도 false로 한다.</li>
<li>tick의 rotate는 눈금을 나타내는 값을 회전시켜서 보여주겠다는 뜻이다. -50는 반시계 방향을 의미한다.</li>
<li>tick의 format은 눈금을 나타내는 값의 형식을 보여준다.</li>
<li>tick값이나, type은 한번 초기화 되면 갱신과정에선 변경될 일이 없다. 그냥 처음 초기화하게 되면, 갱신과정에서 별도로 세팅할 필요가 없기 때문에 초기화 과정에서 이렇게 처리하는 것이다.</li>
</ul>
<h4 id="chart-data설정">chart data설정</h4>
<ul>
<li>초기화 단계의 data설정에서 x: &lsquo;x&rsquo;라는게 있는데, 처음보면, 이게 무슨의미인지 알수가 없다. 우리가 차트를 만드는데 있어서, x축에 어떤 값으로 넣고 싶을때가 있다. 거의 대부분 그렇다. 그럴때, x축에 값으로 들어가는 것도 일종의 데이터다. 따라서 chartData설정에서 data로 들어간다. 예를들면, data항목에 columns 아래에 column 데이터들이 들어가는데, column데이터는 배열형태인데, 첫번째원소는 데이터가 아닌, 그 데이터를 나타내는 레이블 같은것이다. 헤더라고 볼수도 있고, 즉 그 데이터를 나타내는 상징하는 문자열로 보면 된다. 이제 x:&lsquo;x&rsquo;를 설명하겠다. x: 라는 키와 그 값은,  x축으로 어떤 데이터값을 사용할 것인가? 즉 &lsquo;x&rsquo;라고 레이블링된 데이터를 x축으로 정하겠다는 뜻이다. columns에 보면, 배열 데이터들이 있는데, 그 배열 데이터의 첫번째 원소중에 &lsquo;x&rsquo;가 있는것을 볼 수 있을 것이다. 그런데, 여기서는 [&lsquo;x&rsquo;, ]만 있다. 실 데이터가 없다. 그렇다. 이것은 초기화만 하는것이다. 데이터는 갱신단계에서 삽입된다. 초기화된 chartData는 비어있다. 다만 &lsquo;x&rsquo; 라는 레이블링된 column이 x좌표 데이터로 사용될 것이라고 지정해준다.</li>
<li>xformat은 x축으로 사용되는 데이터의 format을 정해준다. 그냥 날짜 형식이다.</li>
<li>columns는 배열의 배열인데, 데이터배열을 담는 그릇이라고 보면된다. columns에 들어가는 데이터를 column배열이라고도 한다. 여기서는 초기화 과정이라서 x축데이터나, 실제값데이터나 모두 레이블만 있다. 실제 데이터와 x축 데이터는 갱신과정에서 해주기 때문이다.</li>
</ul>
<h4 id="chart-generate">chart generate</h4>
<ul>
<li>c3.generate가 chart를 실제 만드는 함수인데, 구조는 generate라는 함수에 위에서 정의한 axis라던가 data를 key:value형태의 객체를 받아서 chart를 만든다.</li>
</ul>
<h3 id="두번째-단계-갱신-단계">[두번째 단계: 갱신 단계]</h3>
<ul>
<li>갱신단계는 setInterval이라는 함수를 사용한다. 여기서 하는 일은 매번 x축의 범위를 설정하고, x(축데이터)값과 실데이터값을 column에 넣어준다. 이렇게 넣어주면 매번 갱신할때마다 데이터는 column data에 쌓여지고 쌓여진 데이터가 갱신할때마다 보여지는 것이다. 실제 화면에 보여지기 위해서는 chart.load함수를 사용해야 한다.</li>
</ul>
<h3 id="원리-요약">원리 요약</h3>
<ul>
<li>원리는 갱신과정에 다 있다고 봐도된다.  갱신하기전에  맨처음 초기화한 차트에는 차트만 달랑있다. column data도 아무것도 없기 때문이다. 다만 axis의 min value가 있고, fit가 false로 되어 있기 때문에 x축 좌표 눈금만 보이는 형태다. 이 상태에서 첫번째 갱신 함수가 실행된다. 그럼 어떤일이 벌어지는가?
x축 눈금의 범위를 min,max로 세팅한다. max값으로 now현재 시간값이 설정된다. 이 상태에서 새로운 x좌표데이터가 현재 시간값이다. 그리고 실데이터가 column배열에 저장된다. 이 말은 x축의 max위치에 지금 입력한 데이터를 보이겠다는 뜻이다. chart.load로 실제 보이게 한다. 이제 그 다음갱신을 보자.
다시 x축의 min max를 현재 시간에 맞추어 재설정한다. 이것이 갱신을 여러번 하게 되면, 축눈금의 왼쪽으로 이동하는 효과를 준다. 여튼, 다시 두번째 데이터를 입력한다. 두번째 데이터는 현재시간을 집어넣기 때문에 맨 오른쪽에 보여지게된다. 그런데 첫번째 갱신과정에 입력한 데이터는 아직도 있다. 따라서 chart.load하면 이전의 데이터와 현재의 데이터 2개가 보여진다. 그다음 갱신에는 3개가, 그다음은 4개가 &hellip;이런식이다.</li>
</ul>
<h2 id="1--c3-dot-js를-적용한-page를-server에-적용">(1) c3.js를 적용한 page를  server에 적용</h2>
<ul>
<li>chart를 적용할 page를 만들기 위해서, controller를 만들고, routes를 수정함.</li>
<li>charts라는 controller와 show라는 action을 만든다. controller는 복수를 사용하고, action도 추가해서 만든다. 그래야 view도 만들어진다.
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>rails g controller charts show
</span></span></code></pre></div></li>
<li>routes를 만든다. routes.rb에 다음을 추가한다. url 주소는 마음대로 정해도 된다. 다만 mapping되는 controller와 action은 정확하게 기술한다.
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>get &#39;/chart&#39;, to: &#39;charts#show&#39;
</span></span></code></pre></div></li>
<li>[test] routes의 url로 접근해본다. 제대로 된것을 확인하고, 해당 page의 link를 dropbox에서 접근하게 한다. layouts/header라는 partial page에 보면, dropdown menu가 있다. 여기에 chart를 추가한다. 상대적 주소로 연결해도 된다.
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>&lt;li&gt;&lt;a class=&#34;dropdown-item&#34; href=&#34;/chart&#34;&gt;Chart Test&lt;/a&gt;&lt;/li&gt;
</span></span></code></pre></div></li>
<li>[page작성] c3.js cdn으로 view에 &lt;head&gt;에 embedded해서 chart를 사용하기로 함. controller에서 정의 한 charts/show.html.erb에서 page를 만든다.</li>
<li>chart가 정의되는 div에 id를 명시해서 c3test.js라는 javascript파일에서 참조할 수 있게 한다.</li>
<li>chart를 그리는 js는 c3test.js는 pack폴더에 넣어 놓는다.</li>
<li>[test] 차트가 보여지는지 확인한다.</li>
</ul>
<h2 id="2--ajax로-server와-통신-적용">(2) ajax로  server와 통신 적용</h2>
<ul>
<li>ajax를 사용하는 이유는 server의 db 데이터를 가져와서 chart에 적용시킬려고 한다.</li>
<li>데이터를 가져오는 방식으로 ajax를 선택했다.</li>
<li>chart/show.html에서 server에 접속해서 통계적 data를 가져올 것이다.</li>
<li>server에서 이런 ajax요청을 처리하기 위해서 url도 만들고 controller도 만들어서 ajax요청에 대한 응답으로 json객체를 전달 할 것이다.</li>
<li>[server 처리]</li>
<li>controller를 만들자.
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>rails g controller api::v1::Statistics
</span></span></code></pre></div></li>
<li>routes를 수정하자.</li>
<li>url은 마음대로 할수 있지만, namespace를 만들어서 적용하자.
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>namespace &#39;api&#39; do
</span></span><span style="display:flex;"><span>    namespace &#39;v1&#39; do
</span></span><span style="display:flex;"><span>      get &#39;/realtimedata&#39; =&gt; &#39;statistics#realtimedata&#39;
</span></span><span style="display:flex;"><span>      get &#39;/hourlydata&#39; =&gt; &#39;statistics#hourlydata&#39;
</span></span><span style="display:flex;"><span>      get &#39;/dailydata&#39; =&gt; &#39;statistics#dailydata&#39;
</span></span><span style="display:flex;"><span>      get &#39;/monthlydata&#39; =&gt; &#39;statistics#monthlydata&#39;
</span></span><span style="display:flex;"><span>    end
</span></span><span style="display:flex;"><span>  end
</span></span></code></pre></div></li>
<li>controller를 만들자.
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def realtimedata
</span></span><span style="display:flex;"><span>  @waterdata = Watermeter.limit(5).order(&#39;gettingtime desc&#39;)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  render json: @waterdata
</span></span><span style="display:flex;"><span>end
</span></span><span style="display:flex;"><span>def hourlydata
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>end
</span></span><span style="display:flex;"><span>def dailydata
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>end
</span></span><span style="display:flex;"><span>def monthlydata
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>end
</span></span></code></pre></div></li>
<li>view를 처리하자. view는 chart가 그려질 div만 만든다.</li>
<li>chart를 그리는 것은 javascript파일이다.</li>
<li>따라서, javascript 를 include한다.</li>
<li>이제 js를 처리하자.</li>
</ul>
<h2 id="3--ajax에서-가져온-data를-chart에-적용">(3) ajax에서 가져온 data를 chart에 적용</h2>
<h2 id="비동기-통신의-문제점">비동기 통신의 문제점</h2>
<p>여러개의 ajax를 사용할 경우, data가 꼬인다. 구조적인 해결은 promise 패턴을 사용하던가?
하나의 ajax만 사용하고, data를 가져오면   여러개의 chart를 보여주는 방식을 사용해야 한다. 별도의 ajax로 chart data를 가져오면 데이터가 꼬여서 안된다.</p>
<h2 id="실시간차트-다시-정리">실시간차트 다시 정리</h2>
<h2 id="d41d8c"></h2>
      
      </div>
        
  
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
  

  

  </div>
</div>  

<script src="/js/URI.js" type="text/javascript"></script>
<script src="/js/page.js" type="text/javascript"></script>
</body>
</html>
