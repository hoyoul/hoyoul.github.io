<!DOCTYPE html>
<html>
  <head><title>Search</title>


<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes" />

<link rel="shortcut icon" href="./img/favicon.ico" type="image/x-icon">
<link rel="icon" href="./img/favicon.ico" type="image/x-icon">    


<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/orgmode.css">
<link rel="stylesheet" href="/css/chroma.css">
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>
  <body><header>
  <a href="/" id="logo">
    <img src="https://braindump.frege2godel.me/img/mylogo.png" alt="holy frege">
    <h3><span>H</span>oly <span>F</span>rege's <span id="note">notes</span></h3>
  </a>
  <small>G.frege를 너무 사랑하는 holy가...</small>
  <div class="vertical_dotted_line"></div>
    <label>
      <input role="switch" type="checkbox" id="switch"/>
      <span>d3 off</span>
    </label><form id="search"
	  action='https://braindump.frege2godel.me/search/' method="get">  
  <input type="text" id="search-input" name="query"
	 placeholder="" autocomplete="on">
  <input type="submit" value="search">
</form>

</header>
   
<div class="container">
      <div class="page wide">
	<ul id="results">
	  <li>
            Enter a keyword above to search this site.
	  </li>
	</ul>
      </div>
    </div><script>
 graph_objects = []; 

 
     
     graph_node_object = {
        
     "label": "[emacs] python lsp setting",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_python_lsp_setting\/",
     "id": "emacs_python_lsp_setting",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("emacs_python_lsp_setting",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[emacs] anaconda settings",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_anaconda_settings\/",
     "id": "emacs_anaconda_settings",
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["python_summary1"]
   }
 sessionStorage.setItem("emacs_anaconda_settings",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "hugo korean encoding problem",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/hugo_korean_encoding_problem\/",
     "id": "hugo_korean_encoding_problem",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("hugo_korean_encoding_problem",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "python_summary1",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary1\/",
     "id": "python_summary1",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("python_summary1",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "test_page1",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/test_page1\/",
     "id": "test_page1",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("test_page1",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[emacs] jupyter notebook settings",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_jupyter_noteboo_settings\/",
     "id": "emacs_jupyter_noteboo_settings",
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["python_summary1"]
   }
 sessionStorage.setItem("emacs_jupyter_noteboo_settings",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "daily영어(1)-don\u0027t pet my puppy",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/english1\/",
     "id": "english1",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("english1",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "folding test1",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/folding_test\/",
     "id": "folding_test",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["folding_test2"]
   }
 sessionStorage.setItem("folding_test",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "folding test2",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/folding_test2\/",
     "id": "folding_test2",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["folding_test"]
   }
 sessionStorage.setItem("folding_test2",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture10-String",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture10-string\/",
     "id": "lecture10-String",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture10-String",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture11-IO",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture11-io\/",
     "id": "lecture11-IO",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture11-IO",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture12-setting-exception-logging",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture12-setting-exception-logging\/",
     "id": "lecture12-setting-exception-logging",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture12-setting-exception-logging",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture13-web",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture13-web\/",
     "id": "lecture13-web",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture13-web",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture3 data structures",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture3_data-structure\/",
     "id": "lecture3_data-structure",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture3_data-structure",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture4_condition-and-loop",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture4_condition-and-loop\/",
     "id": "lecture4_condition-and-loop",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture4_condition-and-loop",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture5_function",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture5_function\/",
     "id": "lecture5_function",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture5_function",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture6-pythonic programming",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture6-pythonic-programming\/",
     "id": "lecture6-Pythonic-Programming",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture6-Pythonic-Programming",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture7_Object-Oriented-Programming",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture7_object-oriented-programming\/",
     "id": "lecture7_Object-Oriented-Programming",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture7_Object-Oriented-Programming",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture8-module-and-package",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture8-module-and-package\/",
     "id": "lecture8-module-and-package",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture8-module-and-package",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture9-Advanced-Data-Structure",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture9-advanced-data-structure\/",
     "id": "lecture9-Advanced-Data-Structure",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture9-Advanced-Data-Structure",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "web scraping1",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/webcrawler1\/",
     "id": "webcrawler1",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("webcrawler1",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture2_variable_and_operator",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture2_variable_and_operator\/",
     "id": "lecture2_variable_and_operator",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture2_variable_and_operator",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "linear_algebra1",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/linear_algebra1\/",
     "id": "linear_algebra1",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("linear_algebra1",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 

 
 function getNode(filename){
   var storedObject = JSON.parse(sessionStorage.getItem(filename));
   alert("label: " + storedObject.node_label);
   alert("url: " + storedObject.node_url);
   alert("backlinks: " + storedObject.backlinks);   
 }
 
 function getLinks(){
   links = []
   for (i = 0; i< graph_objects.length; i++)
   {
     let link_object;
     gno = graph_objects[i];
     blinks = gno.backlinks;
     for(j=0;j< blinks.length;j++){
       link_object = { source:gno.id, target:blinks[j]}
       links.push(link_object);
     }
   }
   return links;
 }

</script>
<script src="/js/URI.js" type="text/javascript"></script>
<script src="/js/page.js" type="text/javascript"></script>

<script src="https://d3js.org/d3.v7.min.js"></script>

<script>
window.store = {
      
    "https:\/\/braindump.frege2godel.me\/posts\/emacs_python_lsp_setting\/": {
        "title": "[emacs] python lsp setting",
        "tags": [],
        "content": "DOING pyright 설정 create env $ conda create -n pyright python=3.11 RET activate env $ conda activate pyright install pyright on pyright env $ conda install -c conda-forge pyright RET ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_python_lsp_setting\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/emacs_anaconda_settings\/": {
        "title": "[emacs] anaconda settings",
        "tags": [],
        "content": "system 설정 emacs에서 anaconda를 사용하기 위해선, mac에 anaconda를 설치한다. 여기(from here) 에서 다운받아서 설치하면 된다.\nvirtual environment 개요 시스템에 하나의 python만 있으면 불편하다. 하나의 python에 여러 package들이 설치된 후 project를 만들게 되는데, 매번 새로운 project를 만들때마다 project에 맞는 package를 설치해야 하는데, 기존 설치된 package때문에 충돌도 일어날 수 있다. 따라서 project에 필요한 python과 package들을 묶은 환경이 필요하다. project기준으로 봐야 한다. 기본적으로 anaconda을 설치하면 default 환경은 base다.\nFigure 1: 기본환경\n가상환경 만들기 가상환경을 만들려면, shell에서 conda명령어를 이용한다.\n$ conda create -n [가상환경이름] $ conda create -n [가상환경이름] python=3.7 가상환경 선택하기(활성화하기,비활성화하기) $ conda activate [가상환경이름] $ conda deactivate 가상환경 정보보기 현재 선택된 가상환경 목록 보기\n$ conda info 가상환경 목록보기 $ conda info --envs 가상환경 삭제하기 $ conda remove --name [가상환경이름] anaconda emacs 설정 anaconda mode setting (use-package anaconda-mode :ensure t ) create new .py file C-x C-f HolaWorld.py RET Add the code print (\u0026#34;Hola World from Emacs\u0026#34;) running it C-c C-p C-c C-c output\nFigure 2: anaconda2\nconda emacs설정 conda mode setting (use-package conda :ensure t :init (setq conda-anaconda-home \u0026#34;/Users/holy/opt/anaconda3\u0026#34;) (setq conda-env-home-directory \u0026#34;/Users/holy/opt/anaconda3/envs\u0026#34;) :config (conda-env-autoactivate-mode t)) check env list M-x conda-env-list RET activate env M-x conda-activate RET company 설정 complete anything. 자동완성 기능\ncompany setting (use-package company-anaconda :ensure t :config (eval-after-load \u0026#34;company\u0026#34; \u0026#39;(add-to-list \u0026#39;company-backends \u0026#39;(company-anaconda :with company-capf)))) ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_anaconda_settings\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/hugo_korean_encoding_problem\/": {
        "title": "hugo korean encoding problem",
        "tags": [],
        "content": "org-roam과 한글 org-roam에서 title을 한글로 하면 한글명의 org파일이 만들어지고, ox-hugo를 실행하면 contents/posts에 md파일이 만들어진다. 이 상태에서 hugo를 사용해서 md파일을 html로 만들게 된다. md파일을 전처리 하는 과정에서 title이름의 폴더를 만들고 index.html을 만들게 된다. 따라서 title을 한글로 만들면, public폴더에는 한글 폴더가 있게 된다.\nhugo의 문제 한글 폴더가 있다는게 development환경에서는 문제가 되지 않는다. 그런데 production환경에서는 한글폴더를 읽지 못하는 문제가 있다. config.toml에 다음과 같이 설정을 했지만, 해결하지 못했다.\nlanguageCode = \u0026#34;ko\u0026#34; hasCJKLanguage = true 해결책 그럼 어떻게 할것인가? 그냥 org-roam에서 title을 작성할때, 영어로 쓰자. 고칠려고 애는 쓸만큼 썼다. 5시간동안 했는데 해결책을 못찾았다. 너무 시간을 쏟을 필요가 없다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/hugo_korean_encoding_problem\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/python_summary1\/": {
        "title": "python_summary1",
        "tags": [],
        "content": "python이란? python은 함수형언어가 아니라, 객체 지향 언어 다. python은 모든 것을 객체로 바라본다. 따라서 우리도, python 코드의 모든것을 객체로 생각하고, 객체로 해석해야 한다.\npython의 개발 환경 python을 사용하려면 setting이 필요하다. computer에 전원을 넣고 바로 python 코드를 작성하고 실행하는 그림을 상상하지 말자. 코딩하는 방법은 여러가지다. 코딩할 수 있는 다양한 editor가 존재하고, 그 많은 editor에서 선택을 해야한다. 나는 emacs를 선택했다. emacs를 선택해서 끝나는게 아니다. 다양한 방법이 존재한다. elpy를 사용해서 코딩할수도 있고, lsp로 코딩할수도 있고, jupyter notebook으로 코딩할수도 있고, google colab과 연결해서 사용할 수도 있다. 짜증나지만, 많은 방법이 있다. 여튼 중요한건 난 emacs를 사용한다는 것이고 emacs를 사용한다는 것은, everything is possbile 이다. 한계는 없다.\nemacs python code를 작성하는 editor로 emacs를 사용한다. emacs에서 python을 작성하기위한 setting이 필요하다. lsp를 사용해서 속시원하게 사용하는게 추천되지만, 나는 2014년 맥북 사용자다. 분수에 맞게 코딩을 하자. jupyter notebook이나 google colab을 사용해서 ipython interpreter(kernel)을 이용하려면 다음 설정을 참고하자. anaconda로 작성하려면 여기(from here) 를 참조한다. 그래도 지금 대세인 lsp를 사용하겠다고 한다면\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary1\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/test_page1\/": {
        "title": "test_page1",
        "tags": [],
        "content": "test this is test\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/test_page1\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/emacs_jupyter_noteboo_settings\/": {
        "title": "[emacs] jupyter notebook settings",
        "tags": [],
        "content": "python, ipython, jupyter notebook, google colab이란? python의 동작방식 python은 REPL(Read Evaluate Print Loop)로 동작한다. shell에서 입력받은 code가 입력이 되고, 입력된 code가 python interpreter에 전해져서 실행되고 실행된 결과가 shell에 전달되는 동작 구조로 이루어져 있다. 그림으로 보면 다음과 같다.\nFigure 1: python 동작구조\nshell과 python은 local system에서 수행된다.\nipython과 ipython notebook python이 개발된 이후에 ipython이란것도 비슷한 시기에 개발되었다. ipython이 기존 python과 차별화하는 2가지 특징이 있는데, 하나는 code를 cell단위로 입력할 수 있고, server client구조를 가질 수 있다는 것이다. Read는 notebook의 코드조각(cell)형태다. cell에 입력한 input이 ipython에 전달되는데 ipython은 local에 있을 수도 원격에 있을 수도 있다. 이러한 개념을 그대로 가져다 사용한게 jupyter와 google colab이다.\njupyter와 jupyter notebook jupyter는 project이름이다. jupyter라는 project가 뭔지는 jupyter 홈페이지에 나와 있다.\nProject Jupyter is a non-profit, open-source project, born out of the IPython Project in 2014 as it evolved to support interactive data science and scientific computing across all programming languages. Jupyter will always be 100% open-source software, free for all to use and released under the liberal terms of the modified BSD license. 요약하면 jupyter와 jupyter notebook은 ipython이 python에 대한 interpreter만 사용하는 것에 문제가 있다고 생각함. 여러 언어를 지원하기로 함. jupyter는 ruby나 R도 사용가능 하다. 인터페이스만 제공하는 형태로 변경한 것이다. 인터페이스를 kernel이라고 부른다. jupyter notebook도 server client 구조로 되어 있다. browser가 client가 되어서 browser내에서 code cell을 입력하거나 notebook을 만들고, 각 cell을 ipython(kernel)의 입력으로 보내고, 실행한 결과를 다시 browser에게 보내게 된다. 위에서도 말했듯이 server client의 구조를 갖고, 원격에 서버가 있을수도 있고 local에 서버가 있을수도 있다. 구조는 다음과 같다.\nFigure 2: jupyter working\nGoogle colab google colab도 jupyter의 구조와 동일한 형태다. 그런데 programming언어는 python언어 하나만 사용 가능하다. google의 cloud와 gpu를 사용할 수 있다. 이말은 사용되는 notebook들이 local이 아닌 cloud에 저장되어 있고, python code를 실행하는 ipython(kernel)도 원격에 있으며, gpu를 사용할수 있다는 것이다. jupyter의 server가 jupyter server(hub)라는 이름으로 따로 있듯이, colab도 google colab server가 있다고 생각하면 된다. server가 따로 있다는 것은 python code를 실행할수 있는 kernel이 server에 있다는 말이다. 그리고,\n요약 말을 복잡하게 했는데, python과 달리, ipython, jupyter notebook, google colab은 아래 그림을 보면 직관적으로 이해할 수 있다. 우선 python을 보면 다음과 같다. shell에서 명령을 내리면 local에 있는 python interpreter가 실행해서 결과값을 보여준다.\nFigure 3: python\nFigure 4: jupyter notebook explorer\nbrowser에서 notebook을 선택할 수 있다.\nFigure 5: jupyter notebook\nnotebook을 선택하면 위와 같이 code와 text가 섞여있는 문서가 나온다. 실행할 수 있는 code block을 cell이라고 부르며 cell을 실행하면 결과가 표시되는 문서다. python에서는 shell에서 code를 실행하고 실행결과도 shell에서 확인하지만, ipython계열은 browser에서 notebook의 cell을 실행하고 실행결과를 notebook에서 확인 한다. browser가 shell의 역할을 대신하는 것이다. python에서 shell은 local에 있는 python interpreter과 통신하지만, browser를 사용하는 ipython계열에서는 실제 실행되는 python interpreter(kernel)은 원격에 있을수 있다. colab은 GCE라는 원격 server에 python interpreter가 있다. 그래서 GCE라는 원격 server가 gpu가 있으면 gpu를 사용할수 있는것이다. 그런데 가만 보면, notebook이라는게 emacs의 org파일과 동일한 형태다. code와 text가 섞여있고, code를 실행할수도 있다. 이런 것을 literate programming이라고 한다. emacs가 browser를 대신해서 client역할을 할수 있어보인다. emacs에서 notebook list를 보여주고, notebook을 선택해서 code를 실행하고 결과도 확인할 수 있을꺼 같다. 또한 org와 비슷하다고 했으니, org문서를 .ipynb로 변환하거나 .ipytnb를 org로 변환하는게 가능해 보인다.\nemacs에서 notebook 사용 jupyter나 colab은 server\u0026amp;client구조고, browser가 client역할 을 한다. 원격에 있는 server에 접속해서 server가 가진 notebook list를 가져오고 notebook에 있는 code를 원격 server에 보내고, server가 실행한 결과를 browser에서 보여주는 것들은 emacs에서도 가능하다. 즉 emacs가 client역할 을 하는 것이다. emacs에서 원격서버에 접속해서 notebook list를 가져오고 code를 원격에 보내고 결과를 emacs buffer에 보여주는 것이 가능하다. 이것을 가능케하는게 ein이라는 package 이다. 또한 .ipynb라는 notebook과 org파일들은 구조가 거의 같다. 그래서 org파일을 ipynb로 변환하고 ipynb를 org로 변환할 수 있는데, 이때 ox-ipynb 라는 package를 사용할 수 있다.\nox-, ob- package들 참고로 emacs에서 ox-, ob-라는 prefix를 갖는 package들은 특정 기능을 수행한다. ox-는 org 문서변환을 하는 package들이다. 예를 들어서, ox-latex는 org문서를 latex문서로 변환한다. ox-md도 org문서를 md파일로 변환을 한다. 그리고 ob-로 시작하는 package들은 babel과 관련이 있다. ob- package는 code block에서 실행할 수 있게 해준다. 예를 들어서, ob-ruby는 code block을 실행할 때 ruby interpreter를 사용한다.\nein package ein을 사용하면, browser로 notebook list를 보고 notebook을 실행하듯이 emacs에서 할 수 있다고 보면 된다. 그렇게 하기 위해선, browser가 원격 server와 접속해서 하는것처럼 emacs도 ein을 사용해서 서버에 접속한 후, notebook list를 가져오고, 가져온 notebook을 열어서 code cell을 실행할 수 있다. ein이 설치되어 있다면, .ipynb를 가진 파일을 dired에서 열면, browser처럼 notebook이 emacs에서 보여질것이라고 생각한다. 그런데 아쉽게도 .ipynb파일을 선택해도 notebook이 보여지지 않는다. json 파일이 열린다. ein에서 notebook을 browser럼 보려면, 다음과 같이 해야 보인다.\nM-x ein:run 현재경로 위와 같이 ein:run으로 server에 접속하면, browser처럼 list를 가져오는 화면이 보이고, 그 화면에서 ipynb를 선택하면 browser에서 봤던것처럼 notebook이 보인다. 이것은 emacs에서 .ipynb파일에 대한 mode를 만들어서 ui를 만들지 않는다는것을 의미한다. 즉 emacs는 jupyter server를 실행시키고, 실행된 jupyter와 tramp로 통신하면서 jupyter server가 만든 notebook list화면을 가져와서 그대로 보여줄 뿐이다. notebook을 선택하면 선택된 notebook정보를 server에 보내면 notebook화면을 고스란히 emacs에게 전달해주고 emacs는 보여줄 뿐이다. 따라서 emacs에서 확장자가 .ipynb를 dired모드에서 click한다고 해서 notebook이 보이지 않는다. 이건 좀 실망이긴 하다. inferior mode는 맘에 들지 않기 때문이다.\nFigure 6: ein notebook\n(use-package ein :ensure t) 사용법 jupyter처럼 현재 위치에서 실행 console에서 jupyter notebook하면 현재 경로에 대해서 browser가 notebook list목록을 보여주듯이 ein에서도 그렇게 할 수 있다.\nM-x ein:run google colab 사용하듯이 browser에서 google colab에 url 연결하면, notebook list를 가져온다. emacs에서도 가능할까? google drive나 colab에 연결하려면 oauth로 토큰을 받아서 사용해야 하는데, 이상하게 google의 project설정화면은 hang on상태다.\nM-x ein:notebooklist-login url: https://colab.research.google.com ox-ipynb사용 ein을 사용하면 emacs에서 notebook파일을 처리할 수 있다. notebook파일을 다뤄야 하는 이유는 gpu를 사용하는 colab이 notebook만을 처리하기 때문이다. big data처리를 하거나 deep learning을 하는 python 프로그램은 gpu를 사용한다. 따라서 gpu서버에서 프로그램을 돌리기 원하는 emacs 사용자들은 ein의 도움을 받아서 emacs에서 notebook문서를 만들고 사용하는게 당연해 보인다.emacs에서 notebook을 만들고 gpu가 있는 colab에서 실행! 매우 당연해 보인다. 그런데 emacs에서는 notebook파일을 자주 사용하지 않는다. 불편하다. emacs 문서 작성의 키 바인딩은 org파일을 능숙하게 사용할 수 있게 되어 있다. notebook과 비슷한 구조이기도 한 org파일을 그대로 사용할 수 없을까? 이런 아이디어로 만들어진게 ox-ipynb다. org로 코드를 작성하고, 원격에 있는 gpu가 있는 server(colab)에서 실행하기 위해서 notebook으로 변환하자는 것이다.\n설정 jkitchin이 만든것을 lisp폴더에 다운 https://github.com/jkitchin/ox-ipynb emacs에 설정 (add-to-list \u0026#39;load-path \u0026#34;/Users/holy/.emacs.d/lisp/ox-ipynb\u0026#34;) (require \u0026#39;ox-ipynb) export dispatcher에서 확인 (org-\u0026gt;notebook) 사용법 org와 ipynb 사용예제가 다운 받은 ox-ipynb에 있다. example.org와 변환된 example.ipynb가 sample로 있다.\n문제점 org모드에서 사용되는 image가 ipynb로 변환될때, image size가 조절되지 않는다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_jupyter_noteboo_settings\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/english1\/": {
        "title": "daily영어(1)-don\u0027t pet my puppy",
        "tags": [],
        "content": "Dear Annie audio-file 1 내 강아지는 비글 라브라도 리트리버의 mix입니다. 1살이며, 강아지가 하는 모든 것을 합니다.\nMy puppy, a beagle/Labrador mix, is 1 year old and does everything puppies do.\n2 그녀는 매력적입니다. 보는 사람들을 멈추게 만드는 매력이 있습니다. 그녀를 보면 내 마음이 녹아내립니다.\nShe\u0026rsquo;s adorbs. She\u0026rsquo;s a traffic-stopper. My heart melts when I see her.\n3 하지만 그녀는 집 안에서 볼일을 보고, 모든 것을 깨물고, 끝없이 에너지를 뿜어내고 있습니다. 강아지는 아직 훈련 중이며 적어도 1년 이상은 훈련을 받을 것입니다.\u0026quot;\nBut she also does her business in the house, chews on everything and has seemingly endless amounts energy. She is still in training and will be in training for another year -at least.\n4 우리가 지금 하고 있는것(애쓰는것)은 강아지가 사람들에게 뛰어 올라붙지 않도록 하는 것입니다. 강아지가 뛰기 시작하면, 강아지가 멈출 때까지 돌아서서 그녀를 무시합니다. 이것을 집에서 할때는 잘 합니다.\nOne of things we\u0026rsquo;re working on is getting her to stop jumping up on people. If she starts to jump, I\u0026rsquo;m supposed to turn around and ignore her until she stops. I do this at home and it works well.\n5 하지만 강아지와 산책을 할 때마다, 낯선 사람들은 그녀가 얼마나 귀여운지 보고 만지고 싶어합니다.\nBut whenever I take her for walks, strangers see what a cutie she is and want to pet her.\n6 그들이 강아지에가 다가가면 강아지는 점프합니다. 그러면, 그들은 내가 싫어하는 그 전형적인 문구를 말합니다: \u0026ldquo;괜찮아요. 괜찮아요\u0026rdquo;.\nWhen they approach her and she jumps, they say that typical phrase I\u0026rsquo;ve come to hate: \u0026ldquo;Oh, It\u0026rsquo;s ok. I don\u0026rsquo;t mind.\u0026rdquo;\n7 이러한 사람들 때문에 내가 매우 좌절합니다. 그리고 나는 \u0026ldquo;하지만 나는 그렇지 않아요!\u0026rdquo; 라고 따지기 시작합니다.\nI get so frustrated with these people. I find myself snapping back at them, \u0026ldquo;But I do!\u0026rdquo;\n8 나는 이렇게 하는 모든 사람에게 인내심을 갖고 대하기 어렵습니다. 이러한 상황이 매번 발생할 때마다, 그것이 강아지의 훈련 과정을 망친다고 생각하기 때문이에요. 이제부터는 낯선 사람들에게 뭐라고 말해야 할지 모르겠습니다.\nI am having trouble being patient with every single person who does this, because I feel as though every time it happen, it ruins the progress of my pup\u0026rsquo;s training. I don\u0026rsquo;t know what to say to strangers anymore.\nDear Puppy 1 이제는 당신이 알파 독이 되어야 합니다.\nIt\u0026rsquo;s time for you to be the alpha dog.\n2 낯선 사람들과의 교류에서 당신의 강아지에 대한 지배력을 확립해야 합니다.\nYou must assert your dominance over your pup\u0026rsquo;s interactions with strangers.\n3 이런 사람들은 분명 강아지를 훈련한 적이 없을 것이다. 단지 강아지를 쓰다듬는 것 가지고 화를 내는 것을 보면 그들은 매우 혼란스러울 것입니다.\nThe people who are doing this have obviously never had to train a dog before, so they\u0026rsquo;re probably really confused when you snap at them - ostensibly just for petting your dog.\n4 문제가 시작되기 전에 주의 신호를 인식하고 문제가 되는 행동을 중단해야 합니다.\nRecognize the warning signs and stop the troublesome behavior before it starts.\n5 당신의 강아지를 끌어안고 싶어하는 낯선 사람이 다가오는 모습을 보면, \u0026ldquo;만져도 괜찮아요. 하지만 강아지가 점프하지 않도록 부탁드릴게요.\nThe next time you see an approaching stranger giving your dog that oh-my-gosh-let-me-hug-you look, say, \u0026ldquo;You can pet her, but she\u0026rsquo;s in training, so please don\u0026rsquo;t let her jump.\n6 점프를 하면, 등을 보여주세요\u0026rdquo; 라고 말해보세요. 당신이 능동적이고 주도적으로 상황을 미리 통제하는 지도자 역할을 수행해야 합니다.\nIf she does, turn your back on her.\u0026rdquo; You have to be proactive and take control of the situation early-like any good leader of the pack.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/english1\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/folding_test\/": {
        "title": "folding test1",
        "tags": [],
        "content": "folding test 아래를 누르세요. folding test2 ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/folding_test\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/folding_test2\/": {
        "title": "folding test2",
        "tags": [],
        "content": "folding test 아래를 누르세요. folding test1 ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/folding_test2\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture10-string\/": {
        "title": "lecture10-String",
        "tags": [],
        "content": "String의 기본 자연어 처리에 있어서 문자열은 매우 중요하다. regular expression이 매우 많이 쓰인다.\nstring의 특징 immutable 이다. 표기법: \u0026lsquo;\u0026rsquo;\u0026rsquo;, \u0026ldquo;\u0026rdquo;\u0026quot;, \u0026ldquo;, \u0026lsquo;를 사용해서 string literal을 표시 가능 여러줄의 string literal은 \u0026ldquo;\u0026rdquo;\u0026rdquo;,\u0026lsquo;\u0026lsquo;\u0026lsquo;을 사용하자. tuple과 string은 둘다 배열이다. 그래서 둘다 immutable하고, indexing이 가능하며, slicing이 가능하다. 이것들이 배열의 특징이기 때문이다. in과 not in이 가능하다. 예를 들어보자. print(\u0026#39;a\u0026#39; in \u0026#39;abc\u0026#39;) print(\u0026#39;asdf\u0026#39; in \u0026#39;asdf_asdf\u0026#39;) python에선 character set으로 unicode로 처리한다. 즉 모든 글자는 4byte를 사용한다. escape문자 escape문자란? escape문자란 벗어난 문자다. 벗어난다는게 무슨 말인가? 원래 용도에서 벗어나 다른용도로 사용된다는 뜻이다. 문자라는것은 문자열에 포함된다. 문자열에 포함되면, 화면에 보여질 수도 있고, file에 text로 저장이 될 수도 있다. 그런데 escape문자는 문자열에 포함되지 않는다. escape문자중에 os나 언어차원에서 공식적으로 정의된 형태의 문자가 있다. \\를 사용하지 않는 문자인데, meta문자라고 부르기도 한다. 따옴표도 meta문자다. 예를 들어보자. python이란 언어에선 문자열을 나타내기 위해서 따옴표같은 문자를 사용한다. 따옴표도 문자이기때문에 문자열에 포함되어야 하지만, 따옴표는 문자열에 포합되지 않는다. 문자열의 시작과 끝을 나타낸다. 문자이지만, 문자열에 포함되지않는 escape문자라서 그렇다. 다시 말해서,문자라는게 문자라는 용도에 벗어나 다른 용도로 정의되어 있다면, escape문자라고 한다. meta문자 이외의 escape문자들은 보통 \\를 붙인다.\nescape문자를 만드는 \\문자가 일반문자에 적용되면 escape문자가 되지만, escape문자에 적용되면 escape문자를 일반 문자로 만들어준다.\nprint(\u0026#34;this is \\\u0026#34; .\u0026#34;) \\ escape 문자도 자기 자신을 escape시켜서 문자열에 포함시킬 수 있다.\nprint(\u0026#34;this escape escape character \\\\\u0026#34;) python 환경에만 이런 문자가 있는건 아니다. os도에도 있고, system에도 있다. 파일을 editor에서 편집한다고 생각하자. 키보드의 문자키를 입력하면, 키보드에선 문자키에 해당하는 code값을 cpu에 보낸다. 문자키에 해당하는 code값이란 unicode와 같은 character set 테이블에 있는 숫자값을 뜻한다. 각각의 character set은 symbol과 숫자값을 가지고 있기 때문이다. cpu에선 입력된 문자 code를 display로 보낸다. 그리고,display에선 code에 일치하는 symbol그림을 화면에 보여준다. font가 있다면 font에 해당하는 symbol그림을 display에서 보여준다. 키보드 문자키로 작성되는 모든 문자들은 기본적으로 화면에 출력이 된다. 파일을 열었을때, 파일에 담긴 문자코드들은 화면에 글자로 보여져야하는 용도인데, escape문자들은 문자열에 포함되지 않은 문자라서 화면에 보여지지 않고 다른 용도로 사용될 수있다. 예를 들어, \\a라는 문자는 bell소리를 낸다. a라고 화면에 보이지 않는다. escape문자이기 때문이다. display device로 가지않고 sound device로 가기 때문이다.\nescape 문자의 예 python에서 사용되는 escape문자는 아래와 같은 예가 있다.\nprint(\u0026#39;\\\\ \u0026#39;) print(\u0026#39;\\\u0026#39; \u0026#39;) print(\u0026#39;\\\u0026#34; \u0026#39;) print(\u0026#39;\\b \u0026#39;) print(\u0026#39;\\n \u0026#39;) print(\u0026#39;\\t \u0026#39;) print(\u0026#39;\\e \u0026#39;) \\\\: back slash\n\\ enter: back slash : 화면에서 다음줄로 넘어가지만, newline이 생기지 않는다. 실제 저장될 때, newline이 없게된다.\n\u0026gt;\u0026gt;\u0026gt; 이렇게 적으면 \\enter \u0026gt;\u0026gt;\u0026gt; 엔터없이 \\enter \u0026gt;\u0026gt;\u0026gt; 여러줄을 적어요. \\enter \u0026gt;\u0026gt;\u0026gt; \u0026#39;이렇게 적으면 엔터없이 여러줄을 적어요\u0026#39; \\b: backspace\n\\n: newline: 문자열에 newline이 있으면, 무조건 newline이 해석되는 게 아니다.\nFigure 1: text eval\nrepl에선 text에 escape문자가 있다고 해서 evaluate되지 않는다. 하지만, 변수에 있는 문자열은 evaluate되기 때문에 newline이 해석된다. 이것은 repr()함수가 동작하기 때문이다. repr()는 built-in function이다. repr()는 escape문자를 그대로 출력한다. 따라서, repr()로 return된 값은 escape문자를 포함한 문자열을 return하기 때문에 print해도 escape문자가 출력된다. repr() 표현된 문자열은 string이 아닌 representation이라고 부른다고 한다. string은 formatting을 할수 있지만, representation은 formatting을 할 수 없다고 한다.\ntext =\u0026#34;This is \\nNewline\u0026#34; print(repr(text)) repr()는 class객체를 출력할 때도 볼 수 있다.\nclass A: pass a = A() print(a) 객체를 출력할때, str()를 overriding해서 string을 출력하게 할수도 있지만, repr()을 overriding해서 위와 같은 문자열을 출력하게 할 수도 있다.\n\\t: tab\n\\e: esc\nraw string repr()가 escape문자를 해석하지 않고 original 그대로 가지고 있다면, raw string도 escape문자를 string literal로 취급하는데, 약간 trick을 사용한다. 즉 escape문자에 \\를 덧붙이면 escape 문자가 출력이 된다. 그래서 마치 escape문자를 문자 그대로 출력하는것 처럼 보이게 만든다. 아래의 예를 보면, repr()에서 escape문자가 포함된 문자를 출력하는것과 raw string으로 표현된 문자열의 출력을 repr()로 보면 original string모습을 확인 할 수 있다.\n참고로 raw string은 r이라는 symbol을 string앞에 붙인다.\nstring = \u0026#34;여기서 \\n은 escape문자다.\u0026#34; print(repr(string)) print(string) raw_string = r\u0026#34;여기서 \\n은 string literal이다.\u0026#34; print(repr(raw_string)) print(raw_string) raw string이 사용되는 경우는 escape문자가 그대로 출력되야 하는 경우에 raw string을 사용하면 편하다. 예를 들어보자.\nlocate = \u0026#34;c:\\\\users\\\\test\u0026#34; print(locate) locate = r\u0026#34;c:\\users\\test\u0026#34; print(locate) 첫번째는 경로 문자열을 그대로 표현해야 한다. string을 사용할 경우, \\을 하나씩 더 붙여야 문자경로명이 표시된다. raw string을 사용할 경우 경로와 같은 escape문자를 그대로 출력해야 할때, 그대로 사용하면 된다. 굳이 원본 text에 \\을 붙일 필요가 없다. 예를 들어, ebook에 \\를 사용한 단어들이 많이 나왔을때, string으로 취급해서 처리할려면, ebook의 모든 \\ 글자를 찾아서 \\를 추가해야만 \\가 출력이 가능하다. 하지만, raw string은 그런 pre-processing을 할 필요가 없다.\nString의 기본 methods 기본 methods len(string) 문자의 길이를 반환한다.\ntext =\u0026#39;this is sentence\u0026#39; print(len(text)) string.upper() 대문자로 변환한다.\ntext = \u0026#34;this is string\u0026#34; print(text.upper()) string.lower() 소문자로 변환한다.\ntext = \u0026#34;this is string\u0026#34; print(text.lower()) string.capitalize() 시작 문자를 대문자로 변환\ntext = \u0026#34;this is string\u0026#34; print(text.capitalize()) string.title() 단어의 시작을 대문자로 변환한다.\ntext = \u0026#34;this is string\u0026#34; print(text.title()) string 공백 제거 methods 크롤링할때 공백을 제거할 일이 많다.\ntext = \u0026#39; 공백이 \\t 있어요. \\t\\n \u0026#39; print(text) print(text.strip()) print(text.rstrip()) print(text.lstrip()) string.strip() 좌우의 공백을 제거한다.\nstring.lstrip() 왼쪽 공백을 제거한다.\nstring.rstrip() 오른쪽 공백 제거한다.\n문자열 check predicate print(\u0026#39;12345\u0026#39;.isdigit()) print(\u0026#39;1.23e-5\u0026#39;.isdigit()) print(\u0026#39;Capitalize\u0026#39;.isupper()) print(\u0026#39;lower_case\u0026#39;.islower()) string.isdigit() string이 0-9사이의 숫자형태인지 확인한다. 위의 예를 보면, e를 사용한 지수형태가 있는데 이것은 digit이 아니다.\nstring.isupper() 모든 문자가 대문자로 이루어져 있는지 확인한다.\nstring.islower() 모든 문자가 소문자로 이루어져 있는지 확인한다.\nString Pattern matching pattern이 문자열에 있는지 궁금할 수도 있고, 있다면 어디에 있는지 알고 싶을 때 pattern matching함수를 사용한다. pattern이 있는지 없는지 여부는 in을 사용해도 된다.\ntext = \u0026#39;abc_text_abc_ee\u0026#39; pattern = \u0026#39;abc\u0026#39; print(text.count(pattern)) print(text.find(pattern)) print(text.rfind(pattern)) print(text.startswith(pattern)) print(text.endswith(pattern)) string.count(pattern) string 문자열내에 pattern의 occurs 반환\nstring.find(pattern) string 문자열 내에서 pattern을 find해서 첫 occur의 index반환\nstring.rfind(pattern) string 문자열 내에서 pattern을 reversed(뒤에서부터) find한 첫 occur의 index반환\nstring.startswith(pattern) string이 pattern으로 시작하는지 확인\nstring.endswith(pattern) string이 pattern으로 끝나는지 확인\nsplit \u0026amp; join 프로그램을 짤 때, 프로그램의 기본 구조가 있다. 파일이나 외부 입력으로 sequence data(유한개)를 입력 받고 for-loop으로 하나하나 꺼내서 if로 처리한다. 이게 기본 구조다. 여기서, 입력으로 받은 sequence가 문자열이고, 우리는 for-loop으로 하나 하나 꺼내서 list에 넣는 처리를 하고 싶다. 어떻게 해야 할까? 이때, split()를 사용하면 for-loop과 if를 사용하지 않아도 된다. python에선 어떻게 하면 이 정형화된 for-loop과 if대신 함수로 간단화 할것인가?에 관심이 많다.\ntext = \u0026#39;한국어 abc 테스트 \\n abc 중 \\t 입니다\u0026#39; print(text.split()) print(text.split(\u0026#39;abc\u0026#39;)) print(\u0026#39; \u0026#39;.join(text.split())) print(\u0026#39;, \u0026#39;.join(str(i) for i in range(10))) string.split() string이 입력으로 들어왔을 때, 단어를 list로 넣는다. white space(space,newline,tab)을 제거후 split한다. for-loop으로 문자 하나하나 꺼내고 if로 white space 확인후 제거후 list에 넣는다. for-loop과 if를 사용하지 않게 해준다.\nstring.split(pattern) split에 인자가 없다면, white space(space,newline,tab)을 기준으로 제거하고 list에 넣는다면, 이것은 인자가 주어진다. 주어진 인자를 제거하고 list에 넣는다.\nstring.join(iterable) for loop와 if로 입력 data를 처리하는게 programming에서 입력데이터를 처리하는 기본 구조라고 했다. if로 조건에 맞는 data를 처리도 해야 한다. join은 split()로 if까지 해서 조건에 맞는 data를 list로 넣었다면, list에 대한 처리까지 한다. list의 item을 꺼내서 string을 덧붙여 최종적으로 string을 만들어 낸다.\nprint(\u0026#39; \u0026#39;.join(text.split())) print(\u0026#39;, \u0026#39;.join(str(i) for i in range(10))) 위의 예에서 보듯이 join은 iterable의 item을 꺼낸 후 뒤에 string에 해당하는 문자열을 붙여서 최종적으로 string을 return한다. 첫번째는 split()에 의해서 white space가 제거된 list에서 space를 item마다 추가한 문자열을 return한다. 여기서 추가된 건 space다. white space가 아니다.\nstring formatting program에서 string을 사용하는것은 string에서 어떤 값을 도출하기 위해서,즉 계산을 위해서 사용될 수도 있으나, 출력을 위해서 사용할 때도 있다. 화면에 출력한다거나, file에 로그기록을 남긴다던가, 이럴때 formatting이 필요하다. 알아보기 쉽게 string을 재작성하는 것이다. string literal을 사용하면 되지, 왜 재 작성이냐? 출력할 string은 string literal이 아닌, 변수,객체값을 표현해야 하기 때문이다. 객체의 값이나 변수의 값을 string에 포함시키기 위해선 재작성및 재처리가 필요하다. 예를 들어, 어떤 변수가 3.141592\u0026hellip; 엄청 긴값을 가지고 있을때, 이것을 그대로 파일에 저장한다거나 화면에 출력한다면 가독성이 떨어지게 된다. 그래서 formatting이 필요하다.\na,b,c = 10,1.725, \u0026#39;sample\u0026#39; print(str(a) + \u0026#34;: \u0026#34; + str(b) + \u0026#34; - \u0026#34; + c) print(\u0026#34;%d: %f - %s\u0026#34; % (a,b,c)) print(\u0026#34;{}: {} - {}\u0026#34;.format(a,b,c)) print(f\u0026#34;{a}: {b} -{c}\u0026#34;) % formatting 문자열에 변수나 객체값을 넣어서 string을 만들려고 하기때문에 변수나 객체를 제공하는 부분과, 변수값이나 객체가 위치할 placeholder를 포함한 string template이 있다. 변수나 객체는 뒤에 % tuple형태로 제공한다. placeholder는 %형태로 되어 있다. 미리 만들어준 string template에 %로 시작하는 placeholder를 넣어둔 꼴이다. placeholder안에서 값들을 formatting한다. formatting은 3-4가지 정도가 있다. 대표적인 padding,precision,datatype을 기술하는 ppd format은 가장 많이 쓰이는 formatting방식이다.\nplaceholder =\u0026gt; %[padding+datatype] placeholder =\u0026gt; %[align + padding + datatype] etc) -,+: align placeholder =\u0026gt; %[align + precision + padding + datatype] etc) -,+: align padding 설정 %-4d: 4칸의 padding을 만들고 값을 앞에서부터 넣는다. %4d: 4칸의 padding을 만들고 값을 뒤에서부터 넣는다. %04d: 4칸의 padding을 만들고 값을 뒤에넣고 빈공간은 0으로 채운다. print(\u0026#34;%d+%d+%d\u0026#34; % (1,10,100)) print(\u0026#34;%4d+%4d+%4d\u0026#34; % (1,10,100)) print(\u0026#39; 1+ 10+ 100\u0026#39;) print(\u0026#34;%-4d+%-4d+%-4d\u0026#34; % (1,10,100)) print(\u0026#34;%04d+%04d+%04d\u0026#34; % (1,10,100)) float를 위한 precision 설정 precision은 .을 붙여준다.\nprint(\u0026#34;%f+%f+%f\u0026#34; %(123.4,12.34,1.234)) print(\u0026#34;%.3f+%.3f+%.3f\u0026#34; %(123.4,12.34,1.234)) print(\u0026#34;%8.3f+%8.3f+%8.3f\u0026#34; %(123.4,12.34,1.234)) print(\u0026#34;%08.3f+%08.3f+%08.3f\u0026#34; %(123.4,12.34,1.234)) [datatype] %datatype a %s string %d int %f float %o octet %x hexa naming placeholder를 나타내는 %와 변수는 1:1 mapping한다고 했다. 이를 명확하게 해줄 수도 있다.\nprint(\u0026#34;%(first)5.2f - %(second)5.2f\u0026#34; % {\u0026#34;first\u0026#34;: 10.2, \u0026#34;second\u0026#34;: 5.62}) format() 함수 객체나 변수의 값을 string으로 만들어 출력한다고 했다. 이때 formatting을 해서 string을 만든다고 했다. format()함수도 formatting하는 함수다. % formatting은 %로 변수값을 제공했다면, format()는 인자에 변수값을 제공한다. 그리고 만들고 싶은 형태의 string format은 미리 만들고, placeholder를 만드는 방식은 % formatting과 다를 바 없다. 다만 placeholder를 포함한 string template이 좀 다르다. %formatting은 placeholder가 %로 시작했다면, format()는 string template안에 들어가는 placeholder가 {}같은 형태다. {}는 변수와 1:1 mapping된다. mapping된 변수에 대한 formatting작업이 일어난다.\npositioning (순서 설정) {}와 변수는 1:1 mapping된다. mapping 순서를 바꿀 수 있다.\na,b,c = 10,1.725,\u0026#39;sample\u0026#39; print(\u0026#34;{}: {} - {}\u0026#34;.format(a,b,c)) print(\u0026#34;{0}: {1} - {2}\u0026#34;.format(a,b,c)) print(\u0026#34;{0}: {2} - {1}\u0026#34;.format(a,b,c)) 순서 설정은 변수와 placeholder가 mapping되는 순서를 바꿔줄 수 있다는 것이다. 마치 index같다. % formatting에는 없는 방법이다.\npadding \u0026amp; precision \u0026amp; datatype 설정 format()함수도 placeholder에서 padding과 float를 위한 precision, datatype을 넣어 줄 수 있다.\nprint(\u0026#34;{0}+{1}+{2}\u0026#34;.format(123.4, 12.34, 1.234)) print(\u0026#34;{0:.3f} + {1:.3f} +{2:.3f}\u0026#34;.format(123.4, 12.34, 1.234)) print(\u0026#34;{:8.3f}+{:8.3f}+{:8.3f}\u0026#34;.format(123.4, 12.34, 1.234)) naming 각각의 placeholder와 각각의 변수들이 1:1 mapping된다고 했다. format()에서는 index를 사용해서 placeholder에서 구분이 가능했다. 그런데 mapping이 많아지면, naming을 쓰는 것이 더 효율적이다. 아래 예를 보면, kwargs형태가 나왔다. format()를 호출할때, parameter가 stack에 쌓아지는데, keyword:value의 형태를 한꺼번에 가져갈때, dictionary를 사용하고, **kwargs로 받는다고 했다. 비슷하게 dictionary를 string template이 받는다고 생각하면 될듯하다. 강사는 unpacking이라고 얘기한다.\nprint(\u0026#34;{first:5.2f} - {second:5.2f}\u0026#34;.format(first=10.2, second=5.62)) print(\u0026#34;{first:5.2f} - {second:5.2f}\u0026#34;.format(**{\u0026#34;first\u0026#34;: 10.2, \u0026#34;second\u0026#34;: 5.62})) f string 가장 많이 사용되는 방식이라고 한다. fstring은 % formatting이나 format()와 가장 큰 차이점은 string template만 존재한다는 것이다. 이전의 2가지 방식은 모두 placeholder가 포함된 string template과, 변수와 객체값을 나타내는 formatting provider가 존재했다. f string에선 string template만 존재한다.\npositioning a,b,c = 10,1.725,\u0026#39;sample\u0026#39; print(f\u0026#34;{a}: {b} - {c}\u0026#34;) print(f\u0026#34;{a}: {c} - {b}\u0026#34;) padding \u0026amp; precision \u0026amp; datatype value = 12.34 print(f\u0026#34;{value*10} +{value} + {value/10}\u0026#34;) print(f\u0026#34;{value*10:.3f} +{value:.3f} + {value/10:.3f}\u0026#34;) print(f\u0026#34;{value*10:8.3f} +{value:8.3f} + {value/10:8.3f}\u0026#34;) Regular Expression pattern을 찾는다는것. pattern이란 무엇인가? 규칙(regular)적인 형태, 반복적인 형태를 pattern이라고 말한다. 문자열뿐만 아니라 우리는 보는 모든것에서 본능적으로 pattern을 인식할 수 있다. 우리가 pattern이라고 생각하는것을 표현할 수 있을까? 표현할 수 있다면 어디에 쓸것인가?\npattern을 표현하는 방법, programming language에서 문자열에 나타내는 pattern을 표현하는 언어가 따로 있다. regular expression이라고 한다. 규칙적인 표현? pattern의 다른말에 불과하다. 즉 pattern을 나타내고자 한다면, regular expression을 사용하면 된다.\npattern을 regular expression으로 나타낸다면, 어디에 사용되는가 사용가치가 있는가?라는 질문이 있을 수 있다. 패턴을 나타내면 검색하는데 사용할 수 있다. 즉 어떤 문자열이 주어졌을때, 어떤 pattern이 있냐 없냐를 검색할 수도 있고, 검색된 내용을 바꿀수도 있다. regular expression이란 tool이 이것을 가능하게 해준다. for-loop과 if를 사용해서 이런 기능을 구현할 수도 있겠지만, regular expression이란 tool을 사용하면, 좀 더 쉽고, 막강하게 처리할 수 있다. 참고로 pattern은 일종의 set으로 봐도 된다. 강사는 실제적인 예로 다음 예를 설명한다.\n야 이거 #%이름#꺼 아니야? #%이름#에게 물어봐 #%이모티콘# 정보보호를 위해서 이름이나, 전화번호,주소, 특정내용은 blind되서 제공된다고 한다. 이런 경우 pattern을 찾고 replace하는 일이 빈번하게 일어난다. 이 경우 find(pattern)로 찾을 수 없다고 한다. find는 명시적인 문자열이여야 하는데,#%\u0026lt;임의의 문자열\u0026gt;#으로 명확하지 않은 pattern은 regular expression을 사용해야 한다고 한다.\nRegular expression 패턴 예시 \\d{3}\\-\\d{4}\\-\\d{4} 010-1234-5678 {1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3} 192.168.0.20 #%[^#]+# #%이모티콘# 정규식을 다룬다는건 양이 많다. 참조 사이트에서 연습을 하길 추천한다. Regular Expression 문법 meta character escape문자의 일종, escape문자는 원래 용도에서 벗어난 문자. 문자의 원래용도는 화면에 출력되거나 문자열에 포함되거나, data로서의 역할이다. meta문자는 \\를 사용하지 않는 escape문자로 보면된다. 다른곳에선, 문법적인 역할이 정해진 문자. pattern을 표현할 때, 사용하는 문자다.라고 정의하기도 한다.\n. ^ $ * + ? { } [ ] \\ | ( ) regular expression에서 위 문자들은 화면에 보이는 문자가 아니다. 특수한 의미를 가진 문자로 용도가 정해져 있다. literal character로 사용하려면 \\를 앞에 붙여 줘야 한다.\n^ meta 문자\n문자를 나타내지 않는다. line의 처음을 나타낸다.\n^a a aa aaa aaaa 1aaa 위에서 보면, 1aaa빼고 다 match된다.\n$ meta 문자\n문자를 나타내지 않는다. line의 끝을 나타낸다.\na$ a aa baa aabb a$는 line의 마지막글자가 a라는 것을 나타낸다. 따라서 aabb는 매치되지 않는다.\n/d meta 문자\n하나의 숫자를 나타내는 pattern이다.\n/w meta 문자\n한 문자를 나타내는 meta문자다. 한문자는 a-z,A-Z,0-9가 될 수 있다.\n/s meta 문자\nspace를 나타내는 meta문자다.\nmeta 문자.\nregular expression에서 []라는 문자를 보면, 다음과 같은 형태로 되어 있다.\n[a-z], [A-Z0-9] [\\d\\s] [ ]는 한 문자를 나타내는 pattern이다. 어떤 문자인지는 [ ] 내부에서 -로 표현한다. [A-Z0-9]는 A~Z이거나 0~9의 범위에 있는 문자를 의미한다. [\\d\\s]는 digit이거나 space이거나라는 범위를 나타낸다.\n[^ ] meta 문자\n^란 문자는 not을 의미한다. 즉 포함되지 않는 문자를 말한다. [^ ] 도 한 문자를 의미한다.\ndot(.) meta 문자\ndot 문자도 하나의 문자를 나타내는 pattern이다. [ ]는 range가 있다. 하지만 dot은 \\n을 제외한 모든 문자를 dot으로 나타낼 수 있다. white space도 포함한다.\n\\s...\\s pattern은 \u0026#34;abcd efg hij klmnop\u0026#34; =\u0026gt; efg, hij ? meta 문자\n[]이나 dot처럼 ?문자도 한문자를 대신하는 pattern이다. 한 문자를 대신하는 pattern이 3개 이지만, 한문자를 cover하는 범위가 각기 다르다. 예를 들어 []의 경우는 안에 range가 있다. 특정 range의 문자만 대신한다. 반면에 dot은 모든 문자1개를 대신할 수 있다. 그런데 ?는 범위가 더 넓다. 1개의 모든문자와 문자가 없는 경우도 대신한다.\n반복횟수 지정({}) meta문자\n이전에는 한개의 문자에 대한 pattern이였다. 한 문자에 대한 pattern은 강력하지 않을 수 있다. 아래에 나오는 반복을 나타내는 pattern과 같이 쓰인다면 강력한 pattern을 만들 수 있다.\n{3} -\u0026gt; 3번 반복 {3,} -\u0026gt; 3번이상 반복하는, 무한 반복을 나타낼수 있다. {2,5} -\u0026gt; 2번이상 반복 5번 이하 반복 되지 않는것. star(*) meta 문자\n문자를 나타내는 meta문자가 아니다. 앞의 문자의 횟수를 나타내는 meta문자다. 0번 이상 무한 반복을 나타내는 pattern이다. 예를 들어서,\nab* pattern은 a,ab, abb, abbb, abbb... 앞의 문자인 b의 0번부터 무한까지의 반복된 문자 pattern을 나타낼 수 있다.\nmeta 문자 +도 문자를 나타내는 meta문자가 아니다. 앞문자의 횟수를 나타내는 meta문자다. 단 1회 이상의 반복을 해야하기 때문에 *와는 다르다.\nab+ pattern은 ab, abb, abbb, abbb... start와 + meta 문자의 문제점\n+와 *를 사용해서 pattern을 만들고, 만든 pattern으로 특정 text를 검색할 때 문제가 생길 수 있다. 우리가 원하는 문자열 검색이 안될 수 있다.\n예를 들어서 #%을 prefix로 갖고, #을 postfix로 갖는 pattern을 만들었다고 하자.\n#%.*# .*는 prefix와 postfix의 문자열이다. 무한개의 가능한 문자열이 들어갈수 있다. prefix와 postfix만 맞으면 된다. 이 pattern으로 아래 text를 검색해 보자.\n#% 테스트입니다.# 정말로 #% test일까요?# 결과는\n#% 테스트입니다.# 정말로 # 우리가 원한 결과는 아래였다.\n#% 테스트입니다.# 많이 다르다. 왜냐하면 *나 +의 앞문자 무한반복 가능한 pattern의 경우, greedy하다. 즉 prefix와 postfix가 일치해도, 남은 text중에 postfix가 일치하면, 더 긴 검색결과를 return하기 때문이다. 이것을 막기위해서 다음과 같은 방식을 사용할 수도 있다.\n#%[^#]+# 즉 prefix와 postfix안에 #이라는 문자가 있는 경우 제외시킨다. 이러면 우리가 원한 결과를 얻을 수 있다. 이 방식 말고도 lazy matching pattern을 사용할 수도 있다. 선호하는 방식은 위의 방법이 더 선호된다고 한다.\nlazy matching pattern\n위에서 +나 *를 사용한 pattern들은 우리가 원했던 의도로 검색이 안됐다. 안된 이유는, 가장 긴 pattern을 찾기 때문이라고 했다. greedy하다. 그래서 검색을 할때 만족하는 가장 긴 pattern이 아닌 가장 짧은 pattern을 검색하게 하려면, lazy하게 만들어야 한다. 게을러지면, 짧아도 만족만 되면 멈추기 때문이다. 그것을 lazy matching pattern이라고 부른다고 한다. 아래와 같은 pattern을 만들었다.\n\u0026lt;.+\u0026gt; prefix인 \u0026lt;과 postfix인 \u0026gt; 사이에, 무한한 문자(.+)가 올수 있는 경우다. 이것은 *와 +를 사용할 때의 문제점을 보여주고자 함이다. 아래의 문자열을 검색해 보자.\nThis is a \u0026lt;div\u0026gt; simple div\u0026lt;/div\u0026gt; test 검색 결과는 다음과 같다.\n\u0026lt;div\u0026gt; simple div\u0026lt;/div\u0026gt; 우리가 원하는 결과는 앞의 \u0026lt;div\u0026gt; 와 뒤의 \u0026lt;div\u0026gt;를 찾고 싶었던 건데, 원하는 결과가 안나왔다. 즉 pattern을 만족하는 가장 긴 문자열을 찾았기 때문이다. 이것을 lazy pattern으로 만든다면, 다음과 같다.\n\u0026lt;.+?\u0026gt; +나 *뒤에 ?를 하면 lazy pattern이 되는 것이다. lazy pattern을 사용하면 원하는 검색결과를 얻을 수 있다고 한다. 하지만, 선호되지 않는다고 한다. 그래서 보통은 다음과 같이 사용한다고 한다.\n\u0026lt;[^\u0026gt;]+\u0026gt; \u0026lt; \u0026gt; 사이에 문자들이 오는데, \u0026gt;을 포함하면 안된다는 뜻이다.\n선택(|) meta 문자\n\u0026lsquo;|\u0026rsquo; meta 문자는 두개의 pattern을 사용할 수 있게 해준다. 예를 들어 보자.\n010-1234-5678 +82-010-1234-1234 +81-42-1234-5678 024-23-4321 위 전화번호중에 010으로 시작하고, +82로 시작하는 전화번호만 검색하려고 한다. 이때 2개의 pattern을 만들고 |을 사용하면 된다.\n(0 | \\+82)\\d{1,2}-\\d{3,4}-\\d{4} Boundary meta 문자들\n\\b : 단어를 찾을 때 사용한다. 단어의 시작점을 의미\n\\babc this is not mabc but abc abc가 검색된다.\n^: 줄이나 문자열의 시작점\n^\\w+ This is sample. I like this. Life is short. 참고로 \\w 는 문자 하나를 나타내는 pattern이다. 각라인의 첫 단어를 검색하게 된다. 아래와 같은 것이 검색된다.\nThis, I, Life $: 줄의 끝에서 찾는다.\n$\\. 이것은 newline 바로 앞 단어에서 찾는다. 예제는 마침표를 찾는 것이다.\ncapturing group\ncapturing group: tomato같은 단어를 찾고 싶다면, one-to-one이란 단어를 찾고 싶다면, abdeab라는 단어를 찾고 싶다면 어떻게 해야할까?\ntomato, one-to-one, abcdebch 위 단어의 공통점은 prefix에 해당하는 문자들과 postfix에 해당하는 문자들이 동일하다는 것이다. 이것을 pattern으로 나타낼 수 있다면, 비슷한 단어들을 검색할 수 있을 것이다. 어떻게 pattern을 만들어야 할까? prefix는 capture하고, postfix는 numeric reference로 참조한다. capturing을 group화 한다고도 많이 말한다.\n우선 capture, numeric reference란 용어와 사용법을 알아야 한다. capture는 group으로 만들어 저장한다. 저장하는 방법과 capture된것을 사용하는 방법은 아래에 있다.\n(\\w)a\\1 hah bong dad bad dab gag gab 우선 pattern분석부터 해보자.\n\\w w는 한 문자다. [a-zA-Z0-9]와 같은 뜻이다. 즉 소문자이거나, 대문자이거나 digit인 한 문자다. 따라서 아래의 text에서 space를 제외한 모든 문자들이 하나 하나 다 선택된다.\nhah bong dad bad dab gag gab (\\w) 이것은 한문자가 선택되는 건 맞는데 capture된다. capture된다는건 기억된다는 것이고 기억하는 이유는 다시 사용하기 위함이다. number reference로 기억했던걸 다시 사용할 수 있다. 우선 한문자를 선택하는 건 변함이 없기 때문에 아래의 text 각각의 문자가 선택된다.\nhah bong dad bad dab gag gab 이제 한문자를 추가한 pattern을 만들자.\n(\\w)a 임의의 문자와 그 뒤에 a가 나오는 pattern을 만들었다. 이 pattern으로 아래의 text를 검색해보자.\nhah bong dad bad dab gag gab ha da ba da ga ga 위의것이 선택된다. 이제 numeral reference를 사용하자. 지금 capturing group은 1개밖에 없다. 따라서 \\1밖에 사용하지 못한다. 여튼 이 패턴을 text에 적용해보자. 즉 검색해보자.\n(\\w)a\\1 hah bong dad bad dab gag gab 결과는 어떻게 될까?\nhah dad gag 위와같이 된다. 작동 원리는 다음과 같다. 임의의 한문자뒤의 a로 된 2개의 문자, 그리고 capturing된 문자가 있는 3개의 문자를 text에서 찾아야한다. text를 보자. 첫 문자 \u0026lsquo;h\u0026rsquo;는 일치한다. 따라서 capturing한다. 이제 뒤의 문자를 보자. \u0026lsquo;a\u0026rsquo;가 있다. ok. 그 다음 문자는 h다. 우리의 pattern을 보면, \u0026lsquo;a\u0026rsquo;다음엔 capturing문자가 와야 한다. 즉,\\1에 의해 \u0026lsquo;h\u0026rsquo;문자가 와야 pass가 된다. \u0026lsquo;h\u0026rsquo;가 있다. 일치한다. 따라서 검색 완료. 그다음 space는 \\w에 해당하지 않기 때문에 pass한다. \u0026lsquo;b\u0026rsquo;는 \\w와 일치한다. 그런데 그 다음 \u0026lsquo;o\u0026rsquo;는 일치하지 않는다. \u0026rsquo;n\u0026rsquo;은 \\w와 일치한다. \u0026lsquo;g\u0026rsquo;가 일치하지 않는다. 그 다음은 space라서 \\w와 일치하지 않는다. d를 본다. \\w와 일치한다. d가 capturing된다. \u0026lsquo;a\u0026rsquo;문자를 본다. 일치한다. \u0026rsquo;d\u0026rsquo;문자가 나왔다. 이것은 capturing된 \u0026rsquo;d\u0026rsquo;와 일치한다. 따라서 검색이 완료된다. 이런식으로 계속 검색을 하는 것이다.\n위에서도 말했지만, prefix와 postfix가 같은 경우, capturing group을 사용하는게 굉장히 유용하다.\ncapturing group이 한개만 사용되는건 아니다. 2개도 사용될 수 있다. 2개가 사용되면, 2개를 기억하게 되고, 기억된 문자를 다시 numeric reference로 참조해서 사용하면 된다.\ncapturing(group) 간단 예제\nimport re m = re.match(\u0026#39;([0-9]+) ([0-9]+)\u0026#39;, \u0026#39;10 295 32 54\u0026#39;) print(m.group(1)) print(m.group(2)) print(m.group()) print(m.group(0)) print(m.groups()) 위의 pattern을 보면 2개의 group이 있다. 첫번째 group에 매치되는 문자열은 group(1)로 출력할 수 있고, 두번째 group에 매치되는 문자열은 group(2)에 출력할 수 있다. group()는 group이 몇개던 matching된 문자열을 return한다. group(0)도 group()과 같은 뜻이다. groups()는 tuple로 return한다.\nnon-capturing group\nnon-capturing group은 group이긴 한데, captuing을 하지 않는다. group()을 사용하는 이유는 우선순위를 갖기 때문이라고 한다. 사용법은 (?:)형태로 사용해야 한다. 자주 사용될지 모르겠다. 여튼 captuing은 하지 않는다. 다음과 같은 text가 있다고 하자. 여기서 010-1234-1234, +82-10-5678-5678과 같은 형태의 전화번호를 검색하고 싶다고 하자. pattern을 만들어야 한다.\n010-1234-1234 010-1234-5678 +82-10-5678-5678 +82-4123-1234 pattern을 어떻게 만들까? 5678로 나온게 뒤에 다시 5678로 나오고 1234로 나온게 뒤에 또 1234가 나온다. 이것은 capturing의 예이다. 우선 capturing만 적용시키면 다음과 같이 쓸수 있다.\n(\\d\\d\\d\\d)-\\1 그런데 반복된다. 반복은 {} meta문자로 나타낼수 있기 때문에,\n(\\d{4})-\\1 로 표현하면 된다. 그다음 해야할 것은 010-1234-1234, +82-10-5678-5678 에서 보면 010이거나 10이다. 즉 3자리의 숫자이거나 2자리의 숫자이다.\n\\d{2,3} 표시하면 된다. 이제 마지막으로 +82이거나 없거나인데, 이때, non-capturing group을 사용할 수 있다.\n(?: ?|\\+82-) 최종 결과 pattern은 다음과 같다.\n(?: ?|\\+82-)\\d{2,3}(\\d{4})-\\1 condition\npostfix 포함 여부\npostfix로 끝나는 단어를 찾는데 편한 방법이 있다고 한다. 예를 들어, 다음과 같은 text가 있다고 하자.\nTourism I don\u0026#39;t like idealism He is socialism 여기서 ism으로 끝나는 단어의 앞부분만 가져오고 싶다면, pattern을 만들어야 한다.\n[^\\s]* 이렇게 하면 ism을 postfix로 갖는 문자열을 검색하는 pattern이 된다. [^\\s]* 는 space가 포함되지 않은 문자열을 의미한다. 즉 단어를 뜻한다. 그런데 강사는 단어를 가져올때, 쉬운 방법이 있다고 한다.\n\\w+ 이게 단어를 가져오는 pattern이라고 한다. w라는게 word를 뜻한다고 한다. \\w는 단하나의 문자이기 때문에 \\w+를 해줘야 단어가 된다.\n여기서, postfix를 추가하기 위해서 ism을 추가한다.\n\\w+ism 이런 pattern을 다음의 text에서 검색한다.\nTourism I don\u0026#39;t like idealism He is socialism 결과는 아래와 같다.\nTourism idealism socialism 여기서, ism이 다 포함된다. 만일 ism을 포함시키지 않을려면 어떻게 해야 하나? 이때 ism 대신 (?=ism)을 사용하면 된다. 즉 ism은 결과에 포함시키지 않겠다는 뜻이다.\n[^\\s]*(?=ism) 이렇게 하면 결과는 다음과 같다.\nTour ideal social prefix 포함 여부\n위에서 했던것과 비슷하다. 예를 들어보자. 다음과 같은 text가 있다고 하자.\nThis is preprocessing function. The word is precompiled function. 여기서 preprocessing, precompiled라는 단어를 검색하고 싶다. 그리고 결과로 pre를 제거한 processing과 compiled를 얻고 싶다고 하자.\npattern을 만들어야 한다. pre로 시작하는 단어이기 때문에 다음과 같이 쓴다.\npre\\w+ 그런데 이 방식은 pre라는 prefix를 포함한다. 따라서 (?\u0026lt;=pre)로 바꿔줘야 한다.\n(?\u0026lt;=pre)\\w+ 이렇게 하면 다음과 같은 결과를 얻게 된다.\nprocessing compiled 주의해야 할것은 prefix경우 (?\u0026lt;=)를 사용하고 postfix의 경우 (?=)를 사용한다는 것이다.\npython에서 regular expression 간단한 사용법 import re text = \u0026#34;\u0026#34;\u0026#34; 010-1234-1234 010-1234-5678 +82-10-5678-5678 +82-4123-1234 \u0026#34;\u0026#34;\u0026#34; pattern = r\u0026#39;(?:0|\\+82-)\\d{1,2}-(\\d{4})-\\1$\u0026#39; for match in re.finditer(pattern,text,re.MULTILINE): print(\u0026#34;전체문자열\u0026#34;,match.group()) print(r\u0026#34;\\1 문자열\u0026#34;, match.group(1)) python에서 정규식은 re package를 사용한다. pattern은 r로 시작하는 문자열로 정의된다. pattern을 통해 text검색하는 함수는 여러개를 제공한다. 위의 예에도 있지만, re패키지에 보면, finditer라는 함수가 있다. 이 함수는 text에 pattern을 적용시켜서 검색을 하는데, iterator형태라서 한번 검색하는게 아니라, text끝까지 반복해서 검색한다. 이 함수의 1번째는 pattern, 두번째는 text, 3번째 인자는 multiline flag이다. text에서 multiline은 flag가 없다면 line으로 인식하지 않기 때문이다. 이 함수에서 match라는 객체를 return한다. 이 객체는 일치하는 문자열을 가지고 있다. 또한 여기선 capturing group을 사용하기 때문에, capturing된 문자열도 가지고 있다. group(0)은 일치하는 문자열이 나오고, group(1)은 capturing group의 값이 나오게 된다.\nMULTILINE option python의 re package를 사용해서 pattern을 text에 적용할 때, option들을 사용할 수 있다. 여러 option들이 있지만, MULTILINE에 대해서만 살펴보자.\nimport re pattern = r\u0026#34;^python\\s\\w+\u0026#34; text = \u0026#34;\u0026#34;\u0026#34;python one life is too short python two you need python python three\u0026#34;\u0026#34;\u0026#34; # match = re.findall(pattern,text,re.MULTILINE) match = re.findall(pattern,text) print (match) MULTILINE이란 option을 추가하지 않으면, python one만 결과로 나온다. pattern을 보면, ^는 문자열의 처음을 나타낸다. 주어진 text는 여러 line으로 이루어져 있음에도, 따옴표때문에 하나의 문자열로 인식되기 때문이다. 여기서 MULTILINE option을 넣어주면, python one, python two, python three의 결과가 나온다. 이것은 하나의 따옴표로 이루어진 문자열이라고 해도 각각의 line의 처음을 문자열의 처음으로 보겠다는 뜻이다.\n사용되는 함수들 re.search() import re text = \u0026#34;\u0026#34;\u0026#34; 010-1234-1234 010-1234-5678 +82-10-5678-5678 +82-4123-1234 \u0026#34;\u0026#34;\u0026#34; pattern = r\u0026#39;(?:0|\\+82-)\\d{1,2}-(\\d{4})-\\1\u0026#39; # pattern = r\u0026#39;(?:\\d{3})-\\d{4}\u0026#39; temp = re.search(pattern,text,re.MULTILINE) print(temp.group()) print(temp.groups()) # print(match.group(0)) search는 처음 매칭되는 문자열을 match객체로 return한다. match객체에서 group()를 사용하면 검색된 문자열을 return한다. groups()는 tuple형태로 검색된 문자열을 반환하는 match의 method다. 만일 capturing을 사용한다면, group(0)을 사용해서 capturing을 출력할 수 있다.\nre.finditer() 이것은 위에서 예제를 봤는데, iterator를 사용해서 matching될때마다 return하게 된다.\nre.sub() import re text = \u0026#39;\u0026#39;\u0026#39; 010-1234-1234 010-1234-5678 +82-10-5678-5678 +82-4123-1234\u0026#39;\u0026#39;\u0026#39; repl = r\u0026#39;치환됨\\1\u0026#39; pattern = r\u0026#39;(?:0|\\+82-)\\d{1,2}-(\\d{4})-\\1$\u0026#39; temp = re.sub(pattern,repl,text,re.MULTILINE) print(temp) # 다른예 # text = \u0026#39;\u0026#39;\u0026#39;010-1234-5678 Kim # 011-1234-5678 Lee # 016-1234-5678 Han\u0026#39;\u0026#39;\u0026#39; # text_mod = re.sub(\u0026#39;^[0-9]{3}-[0-9]{4}-[0-9]{4}\u0026#39;,\u0026#34;***-****-****\u0026#34;,text, flags=re.MULTILINE) # print(text_mod) re.sub는 substitute로, pattern을 검색해서 찾은 것을 replace하는 건데, 강사의 예제는 실행되지 않는다. 강사의 예제는 capture한것을 재가공해서 replace한건데, 제대로 안된다. replace할 문자열은 capture한 것을 사용하기 위해서 \\1 이라는 numeric reference를 사용했기 때문에, r이라는 prefix를 붙였다.\nre.split() import re print(re.split(\u0026#39;-\u0026#39;,\u0026#39;aaa-bbb\u0026#39;)) print(re.split(\u0026#39;(-)\u0026#39;,\u0026#39;aaa-bbb\u0026#39;)) import re text = \u0026#34;\u0026#34;\u0026#34; 010-1234-1234 010-1234-5678 +82-10-5678-5678 +82-4123-1234 \u0026#34;\u0026#34;\u0026#34; pattern = r\u0026#39;(?:0|\\+82-)\\d{1,2}-(\\d{4})-\\1\u0026#39; # result = re.search(pattern,text, re.MULTILINE) splited = re.split(pattern,text,re.MULTILINE) print(splited) # print(result) split는 검색결과를 list로 나타낸다. group이 있는경우는 좀 다르게 return한다. group에 match된 문자열과 전체문자열을 모두 표시한다. 따라서, 첫번째 group에 매치된 문자열과, group을 포함한 regular expression에 일치된 문자열을 return하는 것이다. group이란 독립적인 regular expression으로 볼 수 있기 때문이다.\nregular expression compile pattern을 compile해서 사용할 수 있다고 한다. compile을 한다는 의미가 와 닿지는 않는다. 강사는 pattern을 인식하는것이 시간이 많이 걸린다고 하는데, 그냥 meta와 escape문자로 이루어진 문자열에 불과한데, 시간이 더 많이 걸릴 이유는 없어보인다. 내가 봤을때, compile은 단지 pattern이란 문자열을 객체화한다고 본다. 그렇게 되면 재사용에 유리하다는 장점을 갖기 때문이다. 또한 코드의 가독성이 높아진다.\nfor string in dataset: match = re.search(pattern, string, re.MULTILINE) print (match.group(0)) 위에는 compile을 사용하지 않고, dataset으로 부터 string을 가져와서 검색하는 code다. 매번 string을 가져올때마다 pattern이 string에 적용되게 된다. 이것을 compile하면 다음과 같은 모양이 된다.\ncompiled = re.compile(pattern, flags= re.MULTILINE) for string in dataset: match = compiled.search(string) print(match.group(0)) re.search가 compiled.search(string)문장으로 대체된다. 가독성도 좋아지는 것을 볼 수 있다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture10-string\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture11-io\/": {
        "title": "lecture11-IO",
        "tags": [],
        "content": "standard Input/output 개요 input과 output의 의미 program이 하는 일은 대부분 변수나 객체 생성, for-loop, if로 이루어져 있다. 변수나 객체를 생성하는 것은, cpu와 memory간의 작업이다. 변수나 객체를 생성하는 명령어를 cpu가 실행해서, data memory에 data를 쓰는 작업이다. for loop도 code memory에 놓여 있는 code의 address를 cpu가 address를 계산하는 cpu와 memory의 계산 작업이다. if는 code or data가 놓여진 memory의 값을 가져와서 cpu의 alu가 비교하는 cpu와 memory의 계산작업이다. 결국 모든 program은 cpu와 memory사이의 통신과 계산으로 이루어져 있다. program에서 input과 output의 의미란 무엇인가? cpu와 memory가 아닌 다른 device와 통신하면 input과 output이 된다. memory에도 user program이 아닌 다른 program과 통신하면 input과 output이 된다.\nprogram과 program간의 i/o 관계 program의 input output은 program과 다른 program과의 communication이라고 볼 수도 있고, device와 device간의 통신으로 볼 수있다고 했다. 좀 더 자세히 살펴보자. device와 program은 같은 level이 아니다. device는 h/w level이고, program은 s/w level이다. 두개를 혼합해서 사용하면 햇갈린다. 우리가 만든 program은 cpu와 memory라는 장치를 이용하는 sw이다. 이 cpu에서 monitor로 data를 보낸다고 하자. 그러면 h/w level단에서는 cpu와 monitor device간의 통신이라고 볼 수 있지만 s/w level에서는 내가 만든 program과 monitor device driver라는 program과의 통신이라고 봐야 한다. 그리고 h/w level단에서의 통신은 모두 program간의 통신이라고 말할수도 있는게, 모든 h/w에는 그 h/w를 제어하는 s/w가 돌아가고 있기 때문이다.\nkernel(os) program과 다른 program간의 통신 or device와 다른 device간의 통신은 kernel이라는 program의 도움 없이는 안된다. I/O를 주관하는 kernel이라는 os라는 program이 이를 주관한다. user program이 monitor device driver라는 program과 통신하기 위해선, kernel program에 요청하는 것이다. file을 가져오기 위해서 hdd device와 통신하기 위해서도 file system이라는 s/w와 통신해야 하는데, 이것도 os에게 요청을 해야 한다.\nsystem call과 shell program과 program의 통신을 kernel의 주관한다고 했다. kernel이 user program이나 사용자에게 sytem call이라는 library를 제공한다. 이것은 다른 device에 data를 전달하거나 받거나 혹은 파일을 만든다거나 memory에 process를 만든다거나 하는 hw/resource관련한 작업을 user가 요청하게 만든것이다. c언어나 assembly로 프로그램을 짠다면, 이런 system call을 직접 호출 할 수 있다. 반면 python이나, ruby, javascript같은 script형 언어들은 shell을 사용한다. shell은 system call이라는 function들을 command형태로 바꾼 program이다. 즉 file을 open하거나 file에 directory를 만드는 작업은 c에서는 함수 호출을 하지만, shell위에 떠있는 python,ruby,js는 shell의 mkdir같은 명령어를 사용해서 directory를 만든다. 각각의 python instance아래에는 shell이 떠있다고 보면 된다.\nstandard i/o와 console i/o c언어는 system call이라는 function을 직접 호출할 수 있다고 했다. c에서는 system call을 호출하는 방식이 2가지가 있다. stdio라는 standard i/o 방식과 conio라는 console i/o방식이다. stdio는 system call을 호출하기 전에 buffer를 사용한다거나, 사용을 위한 특별한 객체나 변수등을 제공하고, system call을 wrapping해서 제공한다. 반면에 conio는 직접 system call을 호출한다.\npython에서는 shell을 통해서 system call을 호출한다. 즉 python은 kernel을 사용할 일이 있다면, shell에게 넘겨준다. shell에서는 python에서 전달받은 i/o관련 처리를 standard i/o library를 사용해서 처리한다.\nstandard output print(\u0026#34;this\u0026#34;, \u0026#34;sentence\u0026#34;) print(\u0026#34;this\u0026#34;, \u0026#34;sentence\u0026#34;, sep=\u0026#34;, \u0026#34;) 모든 program들은 shell에서 실행된다. cli로 된 shell이던, gui형태로된 shell이던 명령어 해석기를 거쳐서 program이 실행되기 때문에 중간에 shell이 개입된다. python program은 print함수를 사용해서 해당 data를 출력하고자 한다. shell은 중간에 있다가 출력할 data를 file에 써버린다. 이것은 python이 shell에 의존적인것과는 무관하다. c나 java 모든 program들의 실행은 shell에 의존적이기 때문이다. 즉 shell의 특성이지, python과는 무관하다.\npython a.py \u0026gt; results.txt 이렇게 하면 code의 print문은 shell에게 data를 전달해주고, shell은 results.txt에 저장하게 된다.\nstandard input \u0026gt;\u0026gt;\u0026gt; var = input() 입력을 받습니다. \u0026gt;\u0026gt;\u0026gt; var \u0026#39;입력을 받습니다.\u0026#39; \u0026gt;\u0026gt;\u0026gt; var = input() 12345 \u0026gt;\u0026gt;\u0026gt; var \u0026#39;12345\u0026#39; python의 input의 경우도 output과 마찬가지로 shell이란 중간단계를 거치게 된다. 즉 data를 입력받는게 kernel에 요청해서 kernel이 data를 python program에게 주는게 아니다. shell에게 요청하고 shell이 준다. shell이라는 중간 경유지를 거치기 때문에 경우에 따라서 shell에서 redirection을 사용할 수 있다. python에서 input()를 사용하면 data를 받기 위해서 기다린다. shell은 redirection으로 파일을 열고 data를 전달한다.\ntest.py \u0026lt; results.txt test.py에 input()는 results.txt로 부터 입력을 받게 된다.\nredirection 과 pipe 위에서 redirection을 봤는데, redirection은 data의 i/o를 file로부터 처리한다면, program과 program를 pipe로 연결해서 처리할 수도 있다. 예를 들어보자.\ntest1.py\nm = input() print(m) test2.py\nm = input() print(m) test1.py와 test2.py가 있다고 하자. 두개를 pipe로 연결할 수 있다. 다음을 보자.\n\u0026gt;\u0026gt;\u0026gt; python test1.py | test2.py test1.py를 실행하면 사용자로부터 입력을 받고 입력받은 data를 test.py의 입력으로 전달해서 출력할 수 있다.\n이렇게 pipe와 redirection은 shell에서는 자주 사용된다. 예를들어,\nconda list | grep numpy 위의 경우도 2개의 program을 연결하는 pipe를 보여준다. conda list의 결과가 grep numpy의 입력으로 들어가서 출력하게 된다.\nFile Input/Output file에 대한 처리는 os(kernel)에서 한다. file에 대한 처리는 system call을 통해서 한다. system call은 kernel의 함수를 외부에서 사용할 수 있게 export한 것이다. 이 system call들은 대부분 shell에서 wrapping했고, 이 wrapping된 함수를 user의 program들이 사용한다. shell은 user mode와 kernel mode 경계에 있다고 보면된다. user mode에서 실행하는 program들은(python interpreter도 포함해서) kernel mode에 접근할 수가 없다. shell을 통해서만 가능하다.\n개요 File i/o를 다루기전에 program과 file간의 관계를 살펴보자. file이란건 영구적 보존을 위해 data가 file system에 저장된 형태다. program도 file의 형태로 저장이 되어 있다. file을 생성하고 data나 code를 저장하는것은 program에서 한다. 따라서 program만이 file을 만들고 저장할 수 있기 때문에 관련 함수를 아는건 중요하다. 그런데 어떤 data를 넣을 것인가?는 다른 문제다. program에서 file을 만들고, data를 넣을수도 있고, file을 삭제할 수도 있다. 근데 왜 file을 만들어 오래 보존하는것일까? 도대체 어떤 내용이길래? 내용에 상관없이 모든것을 program을 사용해서 file로 저장할 수 있다. 좀더 정확하겐 file i/o 함수들이다.\nFile open fd = open(\u0026#34;\u0026lt;파일이름\u0026gt;\u0026#34;,\u0026#34;\u0026lt;접근모드\u0026gt;\u0026#34;, encoding=\u0026#34;utf8\u0026#34;) fd.close() \u0026lt;접근모드\u0026gt;\n접근모드 설명 r read mode - file을 text형태로 읽을 때 사용 rb binary read mode- file을 binary형태로 읽을 때 사용 w write mode - file을 text형태로 쓸 때 사용 wb write binary mode- file을 binary형태로 쓸 때 사용 a append mode - 파일의 마지막에 새로운 text를 추가할 때 사용 접근모드에서 신경써야 할것은 w다. 이미 내용이 있는 file을 open하고 write하기 위해서 w를 사용하면 안된다. 기존 내용이 다 삭제 되기 때문이다. file을 open하고 file 작업을 한 이후에는 close를 항상 해줘야 한다.\nread file read() - 파일 한번에 읽기 fd = open(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;) contents = fd.read() fd.close() print(contents) file을 읽는건 read()를 사용하면 된다. file을 다 읽은 후에 file을 close하는 것을 잊으면 안된다. resource를 낭비하기 때문이다. 그런데 file을 close하는것을 깜박할때도 많고, file을 읽다가 error가 나면, close를 하지않고 program이 종료를 할수 있다. 그래서 context manager형태를 사용하면, 자동으로 fd를 닫아준다고 한다. 아래의 구문을 사용한다고 한다.\nwith \u0026lt;contextManager\u0026gt; as \u0026lt;return value\u0026gt; with open(\u0026#34;text.txt\u0026#34;,\u0026#34;r\u0026#34;) as fd contents = fd.read() read()는 파일을 열고 한번에 읽는다.\n줄단위로 읽기 file descriptor사용\nimport os contents = [] print(os.path.realpath(__file__)) with open(\u0026#34;./data/test.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: for sentence in f: contents.append(sentence) print(contents) for-loop를 사용해서 file을 읽는데, read()를 사용하지 않는다. file descriptor가 range()같은 generator 역할을 한다. 한줄 한줄 return하게 된다.\n또한 white space도 포함해서 return하게 되어, \\n과 같은 escape문자가 포함된 하나의 string으로 return하게 된다. 즉 3줄이 있다면, 3개의 string이 return하게 된다.\n위의 예에선 return한 string을 list에 담아 두었다.\nreadlines 사용\n# contents = [] with open(\u0026#34;./data/test.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: contents = f.readlines() print(contents) 위에 나온 file descriptor와 동일한 결과를 나타낸다. for-loop을 사용하지 않는다. list도 선언하지 않는다. readlines는 파일 전체를 읽은 후, list에 line별로 넣기 때문에, code가 더 간단해 진다.\nwrite file write() with open(\u0026#34;./data/text.txt\u0026#34;, \u0026#34;w\u0026#34;) as fd: for i in range(10): fd.write(f\u0026#34;{i+1}번째 문장\\n\u0026#34;) open으로 file을 열고, write()를 사용해서 string을 쓴다. string을 여기서는 fstring으로 만들어 주었다. 변수값이나, 객체값을 string으로 출력할 목적으로 fstring을 사용하는 것이다.\nwriteline() 사용 with open(\u0026#34;./data/text2.txt\u0026#34;, \u0026#34;w\u0026#34;) as fd: fd.writelines(f\u0026#34;{i+1}번째 줄입니다.\\n\u0026#34; for i in range(10)) writelines()안에 for-loop이 있다. 계속해서 write를 할 수 있다. writelines()는 string을 write하는데,\\n은 자동으로 포함하지 않는다. 따라서 필요할 경우, \\n을 string 안에 넣어야 한다.\na(append) option 사용하기 i = 10 with open(\u0026#34;./data/text.txt\u0026#34;, \u0026#34;a\u0026#34;) as fd: fd.write(\u0026#34;내용을 추가합니다.\\n\u0026#34;) fd.writelines(f\u0026#34;{i+1}번째 줄입니다.\\n\u0026#34; append mode는 file의 contents를 지우지 않고, 이어서 작성을 해주는 option이다.\ndirectory import os os.mkdir(\u0026#34;test\u0026#34;) #folder가 이미 있으면 error if not os.path.isdir(\u0026#34;test\u0026#34;): os.mkdir(\u0026#34;test\u0026#34;) os.makedirs(\u0026#34;test/a/b/c\u0026#34;, exist_ok=True) os란 module은 directory를 생성하는 함수가 있다. mkdir이란 shell에서 사용하는 directory 생성명령어랑 동일하다. makedirs()는 subdirectory를 한번에 만드는 함수다. exist_ok=True는 이미 해당 폴더가 존재한다면 만들지 않고 pass한다. False는 새롭게 만든다. directory path에 사용되는 /문자는 window,linux 에 맞게 python이 변환해준다.\nlisting directory import os print(*[entry for entry in os.listdir(\u0026#39;img\u0026#39;)]) 여기서 *는 list unpacking 연산자다. 즉 list에 있는 item들을 unpacking 해서 출력하게 된다. *가 없다면, list가 출력하게 된다. listdir함수는 directory를 인자로 받아서 포함된 file들을 listing한다.\nglob import glob print(*[entry for entry in glob.glob(\u0026#39;img/*.txt\u0026#39;)]) os.listdir()는 directory에 포함된 파일을 for-loop으로 가져오지만, 원하는 파일만 선별해서 가져오는건 아니다. 이럴때, shell에서 사용하는 다음과 같은 명령어가 그리울 수 있다.\nls *.png ls *.pdf 이것을 가능하게 해주는게 glob()다. 현재 폴더에서 원하는 것만 가져오는 프로그램을 짠다면, for-loop로 현재폴더의 file list를 꺼내서 if로 비교연산을 해야 하는것을 meta문자를 사용해서 shell에서 편리하게 하듯, python에선 glob()를 사용해서 이것을 shell에서 하듯이 할 수 있다. 보통의 string에서 \u0026ldquo;test/*.img\u0026quot;는 그냥 문자열에 불과하다. glob()는 문자열에서 /와 *을 meta문자로 처리한다. 즉 일반 문자가 아니라 다른 동작을 하게 meaning이 별도로 지정된것을 말한다. 즉 /는 디렉토리 path separator로 meaning이 정해져 있고, *는 all character를 나타내는 것과 같다.\npickle 객체의 직렬화. program만이 file을 만들고 저장할 수 있다고 했다. 무슨 내용을 저장할까? 보통은 string으로 된 text file이나 program code를 compile한 binary file을 만든다. 에디터라는 program을 만든다면 file io를 사용해서 이런 file들을 만들 것이다. 그런데 program만을 위한 file을 만들 필요는 없을까? 내가 작업하고 있는 객체를 file로 저장하고 필요할때 program에서 load해서 사용하는 형태로 말이다. 또한 file은 network전송이 가능하기 때문에 program에서 사용하고 있는 객체를 원격에 있는 program에서 사용할 수 있게 말이다. 이것은 어떻게 보면, program file을 만들고 원격에서 사용하는 것과 무엇이 다른가?라고 말할 수도 있다. 그런데 다르다. program을 파일로 보내서 compile해서 객체를 만들었다고 해서, data도 같은것은 아니다. 객체를 저장해서 보낸다는 것은 객체라는 구조와 객체가 가진 data를 같이 보내는 것이다. 그래서 객체를 저장하고 load하는 방식에 대한 연구가 이루어졌고 그 결과가 객체 직렬화이다. 객체가 가진 구조와 data를 저장하고 load하는 api를 만들었고 이것이 python에서 pickle이다. pikckle에서는 객체를 보내기위해서 class도 같이 보낸다.왜냐면 복원을 해야 하기 때문이다. 이것을 객체 직렬화라고 한다. 하지만, 객체 직렬화는 대중적이지 않다. 옛날 방식인 data만 보내고 객체의 구조에 맞게 data를 읽어서 parsing해서 넣어주는 방식이 선호된다. 대표적인게 json이다. json은 객체형태에 맞는 data만 보낸다. structure는 보내지 않는다.\n객체 직렬화 pickle의 사용예 import pickle seq = [[ i * j for j in range(5)] for i in range(5)] print(seq1) with open(\u0026#34;test.pkl\u0026#34;, \u0026#34;wb\u0026#34;) as fd: pickle.dump(seq,fd) del seq with open(\u0026#34;test.pkl\u0026#34;, \u0026#34;rb\u0026#34;) as fd: seq = pickle.load(fd) # print(seq[12][9]) 위 코드에서 우선 살펴봐야 할것은 list comprehension이다. list comprehension은 list안에서 for-loop을 사용할 수 있다는 것이다. list comprehension의 for-loop는 item을 만들어낸다. item으로 list를 만들어낼려면, 위와 같이 list comprehension의 item에 해당하는 for-loop 앞에 위치한 곳에 list를 만들면, list안에 list item을 갖게 된다. 사용할 때는 seq[1][1] 이런식으로 사용한다.\nprimitive 객체의 Seriaization. pickle은 객체를 file에 읽고 쓸 수 있게 해준다. pickle의 dump()는 말그대로 dump한다. 덤프트럭에 담긴 객체를 file에 붓는다. 그리고 file에 있는 객체를 load()로 실어 return한다. pickle은 serialization이라고 보면 된다. 즉, serialization은 객체의 구조를 정의된 방식으로 file에 쓰고 객체 구조로 복원하게 된다. file에서 읽고 쓸때는 binary형태로 읽고 쓴다. 객체를 serialization해서 file에 저장했을때는 python이 저장한 방식으로 저장된 binary file이다. 다른 언어에서 사용할 수 없다. python의 객체는 python에서 정의된 객체의 structure를 가지고 있기 때문이다. java는 java만의 객체구조가 있고, javascript는 javascript만의 객체구조가 있기 때문에 다른 언어에서 이것을 복원한다고 해도 사용할 수가 없다.\n그리고 또하나 살펴봐야 하는것은 pickle에 의해 저장과 복원된 객체가 list라는 것이다. list는 primitive한 객체다 내부적으로 seriaization과 restoration이 정의되어 있기 때문에, pickle로 file에 썼다가 다시 복원하는게 가능하다.\nprimitive한 객체가 아닌, 내가 만든 class의 객체도 직렬화와 복원이 가능할까? 내가 만든 class의 attribute들이 모두 primitive한 객체라면 가능하다.\nmy class의 직렬화 import pickle class MyComplex: def __init__(self, real, imaginary): self.real = real self.imaginary = imaginary def __add__(self,other): return MyComplex( self.real + other.real, self.imaginary + other.imaginary ) my_complex = MyComplex(3,5) with open(\u0026#34;test.pkl\u0026#34;, \u0026#34;wb\u0026#34;) as fd: pickle.dump(my_complex,fd) del my_complex #del MyComplex with open(\u0026#34;test.pkl\u0026#34;, \u0026#34;rb\u0026#34;) as fd: my_complex2 = pickle.load(fd) print(my_complex2.real) print(my_complex2.imaginary) 우선 MyComplex라는 class의 attribute들은 모두 int type이라는 전제를 한다. 그래야 serialization이 가능하기 때문이다. my_complex라는 객체를 만들고, pickle을 사용해서 객체를 dump하고, load로 다시 복원 시켰다. my_complex라는 직렬화한 객체는 삭제하고, load()로 파일에서 복원한 것은 my_complex2라는 이름의 객체로 있게 된다. 이전 예제에서 list를 직렬화 복원과 큰 차이는 없다. 다만 여기서 차이가 있는것은 MyComplex라는 class가 삭제된다면, file에 있는 MyComplex class의 instance는 복원이 안된다는 것이다. del이라는 객체 지우는 명령어로 class를 삭제하고 복원하면 에러가 나는것을 볼 수 있다.\ncsv(comma seperated values) csv 개요 program에서 사용하는 data를 위한 file로는 예전부터 csv라는게 있었다. database도 program이 처리하기 위한 data를 저장한것이다. 그래서 일반 text파일과는 좀 다르다. program이 사용하기위한 data를 객체에 넣고 객체를 저장하고 원격에서 객체를 사용하기 위한방법으로 객체 직렬화라는게 나오긴 했지만, 이 방법은 대중화되지 않았다. program이 data를 처리하기위해서 필요한 data는 file이나 db에 넣고, 가져와서 program이 사용하는 방식의 옛날 방법이 더 선호된다. csv도 그런방식이다. data를 comma를 사용해서 저장하는 file. simple하다. excel파일도 comma separated value file이라고 볼 수도 있다. 아래와 같이 엑셀파일이 있다고 하자. 이런 data를 csv로 바꿀 수 있다.\n| id | Name | Loc | | 1 | cho | seoul | | 2 | kim | busan | | 3 | lee | daegu | | 4 | park | Gwangju | | 5 | choi | daejeon | id,Name,Loc 1,cho,seoul 2,kim,busan 3,lee,daegu 4,park,gwangju 5,choi,daejeon text data를 저장할때, 아무런 규칙없이 txt로 저장하는 것보다, csv파일로 data를 저장하고 처리하는게 더 효율적이다. comma가 아닌, tab이나, 공백으로도 처리가 가능하기 때문에 확장자가 .tsv(tab), .ssv(공백)인 파일들도 있다.\ncsv 읽고 쓰기 csv 읽기 - csv reader delimiter\nimport csv with open(\u0026#39;test/test.csv\u0026#39;,\u0026#39;r\u0026#39;) as fd: reader = csv.reader(fd, delimiter=\u0026#39;,\u0026#39;, quotechar=\u0026#39;\u0026#34;\u0026#39;, quoting = csv.QUOTE_MINIMAL) for entry in reader: print(entry) csv의 reader()는 file에서 csv파일의 각줄을 읽고 구분자를 사용해서 item을 뽑아내서 string으로 만든다. 그후 각각의 item을 원소로 하는 list 객체를 만들어 return한다. delimiter는 구분자를 말한다. 구분자를 사용해서 item을 가져온다.\nquotchar\n그런데 만일 string안에 구분자가 있는 경우는 어떻게 될까? 예를 들어보자. 다음과 같은 csv파일이 있다. delimiter가 ,로 csv reader를 만들자.\nid,name,loc 1,\u0026#34;park,hoyoul\u0026#34;,\u0026#34;incheon\u0026#34; 2,\u0026#34;lee\u0026#34;, \u0026#34;seoul\u0026#34; 이경우, 다음곽 같은 결과가 나온다.\n: [\u0026#39;id\u0026#39;, \u0026#39;Name\u0026#39;, \u0026#39;Loc\u0026#39;] : [\u0026#39;1\u0026#39;, \u0026#39;\u0026#34;park\u0026#39;, \u0026#39;hoyoul\u0026#34;\u0026#39;, \u0026#39;\u0026#34;seoul\u0026#34;\u0026#39;] : [\u0026#39;2\u0026#39;, \u0026#39;kim\u0026#39;, \u0026#39;busan\u0026#39;] ,를 기준으로 자른다. \u0026ldquo;는 그냥 문자일뿐이다. 그래서 \u0026ldquo;seoul\u0026quot;이라는 item도 \u0026lsquo;\u0026ldquo;string\u0026rdquo;\u0026lsquo;으로 만들어지고, csv에서 string안에 \u0026lsquo;,\u0026lsquo;가 있던,\n\u0026#34;park,hoyoul\u0026#34; 은 아래와 같이 가져온다.\n\u0026#39;\u0026#34;park\u0026#39;,\u0026#39;hoyoul\u0026#34;\u0026#39; 우리는 \u0026ldquo;park, hoyoul\u0026quot;이 하나의 item으로 뽑아낼 줄 알았다. 그런데 \u0026lsquo;,\u0026lsquo;에 의해서 string이 하나의 item이 아닌 2개가 되었다. 이것을 제어할 필요가 있다. 그래서 quotchar를 설정하고 csv reader를 만들어야 한다. 즉 quotchar가 \u0026quot; 라는 것은 \u0026quot; \u0026ldquo;로 둘러싼 string의 경우 안에 delimiter가 있어도 무시하라는 뜻이다.\nparsing option\nQUOTE_MINIMAL: 최소길이로 parsing한다. 이부분으 그냥 default값을 쓰고 나중에 공부할 때 채워 놓기로 한다. csv 쓰기 - csv writer import csv with open(\u0026#39;test/test1.csv\u0026#39;,\u0026#39;w\u0026#39;) as fd: writer = csv.writer(fd, delimiter=\u0026#39;,\u0026#39;, quotechar=\u0026#39;\u0026#34;\u0026#39;, quoting = csv.QUOTE_MINIMAL ) writer.writerow([\u0026#39;id\u0026#39;, \u0026#39;label\u0026#39;]) writer.writerows([I, f\u0026#39;label_{I}\u0026#39;] for I in range(10)) csv파일을 with open으로 열고, fd를 csv reader에 넣어서 csv reader 객체를 만들듯이, csv writer도 쓸 파일을 with open으로 열고 fd를 가지고 csv writer객체를 만든다. csv를 어떻게 처리할 지에 대한 option도 넣어두고, 이렇게 하면 내가 만든 string을 원소로 한 list가 csv파일에 저장될 것이다. csv reader를 만들면, csv파일을 한줄 한줄 읽어서 string item으로 된 list객체를 return했었다. 쓰는것은 반대다. list를 만들어줘야 한다. string item을 가진 list를 만들고 writer의 writerow()를 사용해서 파일에 쓴다. 여러줄을 쓰기 위해서 writerows()를 사용하기도 하고, 한줄만 쓰기위해서 writerow()를 사용하기도 한다.\njson(javascript Object Notation) json 개요 program을 위한 file이 있다고 했다. 즉, program에서 제공하는 structure와 data가 결합된 형태인 객체를 직접 file에 저장하고 꺼내서 사용하는 pickle을 말했었다. pickle과 같은 객체 직렬화 방식은 대중적이지 않아서 csv처럼 program이 필요한 data만 file에 저장하고 load하고, program의 structure는 program이 그대로 가지고 있는 옛날 방식을 사용한다고 했다. program은 적절한 구조를 만들고, csv파일에서 읽어서 객체를 초기화하는 방식이다. 그런데 csv형태에선 모든게 string이다. program에서 사용하는 structure는 여러 data type을 사용하는데, csv를 사용하면, parsing작업이 많아 진다. json은 객체의 구조에 적절한 data를 pre processing없이 사용할 수 있게 만든 방식이다. csv처럼 program에서 사용할 data만 저장한다는 면에서는 동일하다. 즉 객체를 저장하는 방법(structure+data)에서 data만 별도로 저장하는 방식인데, csv보다 upgrade된 방식이라고 볼 수 있다. key:value구조로 된 파일. csv파일의 모든 item들은 csv reader나 csv writer를 사용할 때, 모두 string으로 처리한다. 즉 csv reader로 읽을 때 모든 item들은 string이다. 저장할 때도 string으로 된 list를 csv파일에 저장한다. 이렇게 하는 이유는 csv파일 자체가 plain text파일이기 때문이다. json은 programming에 친화적인 data저장용 파일이다. csv의 모든 data가 string인 반면에, json은 int형, string형, list형 자료형태도 가질 수 있다. json파일 한개는 {}로 둘러싸인 object형이다.\njson 읽기 import json with open(\u0026#39;test/test.json\u0026#39;, \u0026#39;r\u0026#39;) as fd: data = json.load(fd) print(data[\u0026#39;hobbies\u0026#39;]) print(data[\u0026#39;hobbies\u0026#39;][2][\u0026#39;sports\u0026#39;][0]) json 쓰기 import json obj = { \u0026#34;ID\u0026#34;: None, \u0026#34;bool\u0026#34;: False, \u0026#34;bobbies\u0026#34;: { \u0026#34;sports\u0026#34;: [ \u0026#34;snowboard\u0026#34; \u0026#34;volley-ball\u0026#34; ] } } with open(\u0026#34;test/test2.json\u0026#34;, \u0026#39;w\u0026#39;) as fd: json.dump(obj, fd) csv파일을 쓸때는 csv파일에 들어갈 형태로 program에서 만든다. 들어갈 형태는 string을 item으로 갖는 list였다. 그리고 write했다.\n[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;] json도 똑같다. json에 들어갈 형태로 program내에서 만들어야 한다. json파일에 들어갈 형태라는 것은 dictionary object의 형태다. 따라서 위의 obj dictionary처럼 key:value형태로 data를 만들어서 json파일로 저장한다.\n일반적으로 program에선 객체를 가지고 작업을 한다. python에서 주로 객체를 사용한다. program에서 주로사용하는 객체를 인간이 이해할 수 있는 string이나, file에서 사용하기위해서 많은 program적 요소들이 존재한다. string을 보자. 우리는 string을 literal하게 string을 작성하지 않았다. string을 만드는 것은 file에 저장하거나, 화면에 보여준다. 이때, 순수하게 순전히 string을 작성해서 보여주거나 저장하지 않는다. 왜냐하면, program에서 주로 다뤄지는건 객체이기 때문에 객체정보를 string이나 file에 쉽게 포함되게 하는 방법이 필요했다. 왜냐? 우리가 file에 저장하거나 화면에 보여줄것은 string literal이 아닌 객체 값이기 때문이다. 그래서 string안에 객체의 값을 넣기 위해서 format이라던가, %표현, fstring을 사용했다. 마찬가지로 file도 string literal이 저장될 꺼라고 생각할테지만, 그렇지 않다. 객체의 값을 꺼내서 file에 저장하기 때문이다. python에서 사용하는 dictionary 객체, list객체등에 있는 값을 꺼내서 저장하기에는 json구조가 잘 맞는다.\n아니 그렇다면, programming에서 사용되는 객체를 파일에 저장하기에 적합한 pickle을 사용하면되지 json을 사용할 필요가 있을까? pickle은 모든 객체를 저장한다는 보장이 없다. 일부객체에만 사용할 수 있기에, 객체의 내용을 적절하게 json object형태로 만들고, json파일로 저장하는 방식이 모든 객체에 적용할 수 있기 때문에 더 인기있는 방식이 되었다. json object형태로 만들고 json파일에 저장하는것은 어떻게 보면 객체 직렬화와 동일하다. 1,\u0026ldquo;abc\u0026quot;같은 값들이 program내에선 객체다. 그리고 그것을 file에 쓸때는 객체 직렬화를 거치기 때문에, json파일로 저장하는건 객체 직렬화가 수행된다고 볼 수 있다. 그래서 program내에서 만든다는 json object의 구성품들은 모두 직렬화가 가능한 primitive data type이라는 것을 알수 있다.\nXML(Extended Markup Lanugage) xml 개요 csv에서 string만 사용한다는 단점을 json은 잘 극복했다. program에서 주로 사용하는 int, list와 같은 다양한 종류의 data도 사용할 수 있게 했다. 원래 객체를 저장하려는 방식(직렬화)에서 객체의 구조를 떼어내고 data만 저장하고 load하겠다는 의도였기 때문에 json은 구조도 객체형태의 data이기 때문에 매우 적합하다. xml은 json과 비슷하게 사용된다. 하지만 xml은 시작이 다르다. json은 program이 사용하는 객체를 혹은 program의 일정 단위를 파일의 형태로 저장및 복원하는 객체 직렬화의 대안으로 나온 구조이기 때문에 객체가 가진 구조적 특징, 이름, 여러종류의 data type을 key:value형태로 해서 비슷하게 구현했기 했다. 즉 json객체를 load만 잘하면, 그대로 program의 객체를 저장하고 load하는 직렬화랑 거의 비슷하게 된다. xml은 program을 위한게 아니라, 사람들이 보는 문서를 tag를 사용해서 좀더 구조적으로 만든것이다. tag에는 name에 해당하는 tag도 있고 attribute들을 설정할 수 있기 때문에, json과 거의 비슷하게 사용될 수도 있다. json이 객체가 가진 data를 객체의 구조에 맞게 만들었듯이 xml도 객체가 가진 구조에 맞게 만든다면 json처럼 사용될 수 있을 것이다. 하지만 역사에도 보았듯이 xml은 인간이 보는 text파일을 구조적으로 작성한 방식이라서 tag라는것도 객체를 위한것이라기 보단 문서를 어떤식으로 보이게 할 것인가? 그런데 촛점을 둔 문서다. html을 보면 알 수 있을 것이다. 따라서 json처럼 객체를 위한 data저장 파일로 보면 안된다. xml은 이미 html형태로 대중화가 되어있다. python에서는 xml을 파싱해서 적절한 처리를 할 library를 제공할 뿐이다. python에선 xml을 parsing할 수 있다는건 수많은 인터넷 문서, 즉 html로되어 있는 문서를 가지고 와서 program이 사용할 수 있다는 큰 장점이 있다. json과는 의도 자체가 다르다. xml문서는 순전히 data의 역할을 할뿐이다. 일반 책이나 문서파일이라고 봐도 된다. tag라는 부가적 정보가 있을뿐이지 그냥 data다. json처럼 code의 structure를 고려할 필요가 전혀 없다. 그냥 data다. 어떻게 보면, csv도 마찬가지다. 순전한 data다.\nxml parsing beautifulsoup xml 파일을 처리하기 위한 default library를 제공하긴 하나, 불편하다. parsing을 위한 외부 library가 존재한다. beautifulsoup을 사용하면 xml문서에 대한 처리가 가능하다.\nbeautifulsoup 설치 conda install beautifulsoup4 xml 파일 읽기 by beautifulsoup 예제\nfrom bs4 import BeautifulSoup with open(\u0026#34;test/test.xml\u0026#34;, \u0026#34;r\u0026#34;) as fd: soup = BeautifulSoup( fd.read(), \u0026#39;html.parser\u0026#39; ) to_tag = soup.find(name=\u0026#39;to\u0026#39;) print(to_tag.string) for cite_tag in soup.findAll(name = \u0026#39;cite\u0026#39;): print(cite_tag.string) cites_tag = soup.find(name=\u0026#39;cites\u0026#39;) print(cites_tag.attrs) print(cites_tag[\u0026#39;attr\u0026#39;]) cites_tag = soup.find(attrs={\u0026#39;attr\u0026#39;: \u0026#39;name\u0026#39;}) for cite_tag in cites_tag.find_all(name=\u0026#39;cite\u0026#39;): print(cite_tag.string) Beautifulsoup은 xml파일을 읽고 parsing을 한다. file을 읽고 처리해야 하기 때문에, with open절을 사용한다. fd.read()는 xml파일을 읽고, 지정된 parser로 parsing한다. 이렇게 하면 Beautifulsoup 객체는 xml의 모든 내용을 접근할 수 있다.\nfind()\nsoup에서 가장 많이 사용하는건 find()다. tag를 찾아서, tag의 값이나, tag의 속성을 가져올 수 있다.\nmytag = soup.find(name=tag) print(mytag.attrs) print(mytag.string) print(mytag[\u0026#39;attr\u0026#39;]) find()로 tag를 찾은후 tag의 속성은 attrs로 접근하고, tag의 값은 string으로 접근한다. tag의 속성은 dictionary형태이기 때문에 위처럼 mytag[\u0026lsquo;attrs\u0026rsquo;]로 접근이 가능하다.\n속성으로 tag를 찾을 수도 있다. 속성은 dictionary형태이다. 따라서 아래처럼 찾는다.\ncites_tag = soup.find(attrs={\u0026#39;attr\u0026#39;: \u0026#39;name\u0026#39;}) findAll()\nfind()는 find(name=\u0026lsquo;tag\u0026rsquo;)로 해서 하나의 tag를 찾는다면, findAll(name=\u0026lsquo;tag\u0026rsquo;)는 같은 이름의 tag를 찾아서 sequence로 만든다. sequence로 만들면, for-loop에 사용할 수 있다.\nfind_all()\nfindAll()는 xml내에서 정의된 tag를 모두 찾는다면, find_all()는 찾은 객체 내에서 검색이 가능하다.\ncites_tag = soup.find(attrs={\u0026#39;attr\u0026#39;: \u0026#39;name\u0026#39;}) for cite_tag in cites_tag.find_all(name=\u0026#39;cite\u0026#39;): print(cite_tag.string) 위에서 보면, cites_tag는 속성을 갖는 tag를 가져오는데, tag는 하나의 객체로 봐도 된다. 가져온 tag안에 sub tag들이 엄청 많을 수 있다. 그 tag안에 검색을 한다. find_all(name=\u0026lsquo;cite\u0026rsquo;), 즉 cite라는 tag가 있다는 뜻이다.\nYAML(YAML Ain\u0026rsquo;t Markup Language) 개요 객체 직렬화는 program에서 객체를 파일로 저장하고 복원하겠다는 idea다. program을 위한 file을 만들고 사용하겠다는 based idea가 있었다고 했다. 그래서 pickle도 있었지만, 대중화되지 않고, 옛날방식, data는 file에 저장하지만 복원시 parsing을 통해 적절하게 객체를 초기화하겠다는 생각이 지금도 널리 사용된다고 했다. 그래서 json이란 형태로 객체의 data를 저장하고 복원하는 방식이 인기가 있었다. json에도 많은 문제가 있다.\njson의 문제점 주석을 지원하지 않는다. 큰따옴표만 지원한다. escape문자의 처리가 힘들다. YAML json처럼 객체, dictionary, list를 나타낼수 있고, 위에 말한 단점들도 다 보완했다.\nyaml은 json의 superset으로 보면 된다.\ndictionary 표현법\ndoe: \u0026#34;this is a value\u0026#34; pi: 3.141592 xmas: true list 표현법\ncalling-birds: ​ - huey ​ - dewey ​ - louie ​ - fred dictionary 안의 dictionary\nxmas: tree-birds: four french-hens: 3 tab을 사용해서 inner dictionary를 표현한다.\n설치 conda install pyyaml -c anaconda yaml 읽기 import yaml import pprint with open(\u0026#39;test/test.yaml\u0026#39;) as fd: data = yaml.load(fd, Loader = yaml.FullLoader) pprint.pprint(data) 위에서 with open에 \u0026lsquo;r\u0026rsquo;은 생략할 수 있다. pprint는 standard library라서 import해서 사용하면 된다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture11-io\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture12-setting-exception-logging\/": {
        "title": "lecture12-setting-exception-logging",
        "tags": [],
        "content": "Command Line Argument 개요 python을 실행할때, gpu개수, epoch같은 변수들을 program이 동작할때 cmd line interface에서 argument에서 전달받겠다, 입력받겠다고 처리할 수 있다. program안에서 상수값으로 처리하는게 아니라, program을 실행할 때, 해당 값을 설정해서 실행하는 것이다.\n(1) python main.py (2) python main.py arguments (3) python main.py --options 12345 위와같이 program을 실행할 때, 아래와 같이 하면 command line argument를 건네 받을 수 있다.\nimport system print(sys.argv) 각각의 결과는 아래와 같다.\n(1) python main.py =\u0026gt; [\u0026#39;main.py\u0026#39;] (2) python main.py arguments =\u0026gt; [\u0026#39;main.py\u0026#39;, \u0026#39;arguments\u0026#39;] (3) python main.py --options 12345 =\u0026gt; [\u0026#39;main.py\u0026#39;, \u0026#39;--options\u0026#39;, \u0026#39;12345\u0026#39;] argument들은 공백을 기준으로 item이 도출된다. parsing이 복잡하다. item이 string형태라서 int,float로 형변환도 해야 하기 때문에 쉽게 사용할 수 있는 argparser를 사용한다.\nargparser 사용법 import argparse parser = argparse.ArgumentParser() parser.add_argument(\u0026#39;-l\u0026#39;, \u0026#39;--left\u0026#39;, type= int) parser.add_argument(\u0026#39;-r\u0026#39;, \u0026#39;--right\u0026#39;, type= int) parser.add_argument(\u0026#39;--operation\u0026#39;, dest=\u0026#39;op\u0026#39;, help=\u0026#39;Set Operation\u0026#39;, default=\u0026#39;sum\u0026#39;) args = parser.parse_args() print(args) if args.op == \u0026#39;sum\u0026#39;: out = args.left + args.right elif args.op == \u0026#39;sub\u0026#39;: out = args.left - args.right print out argv로 cmd명령어와 option을 하나의 문자열로 입력받아 parsing해서 처리하지 않고, 위와 같이 argparse 모듈을 사용하면, option에 대한 처리를 미리 정의할 수도 있다. 짧은 option과 긴 option을 사용해서 받아올 값의 type도 설정이 가능하다. 어떻게 사용하는지 정리해 보자.\nArgumentParser라는 객체를 만든다.\n이 객체에서 argument에 대한 설정을 할수 있다.\nparser.add_argument(\u0026#39;-l\u0026#39;, \u0026#39;--left\u0026#39;, type= int) parser.add_argument(\u0026#39;-r\u0026#39;, \u0026#39;--right\u0026#39;, type= int) parser.add_argument(\u0026#39;--operation\u0026#39;, dest=\u0026#39;op\u0026#39;, help=\u0026#39;Set Operation\u0026#39;, default=\u0026#39;sum\u0026#39;) command argument가 program에 전달되면, parsing이 가능하다.\nargs = parser.parse_args() add_argument로 정한 argument값에 대한 접근을 할 수 있다.\nargs.left, args.right, args.op로 접근 가능 args.operation은 dest옵션으로 args.op로 접근 가능하다.\nException Handling 개요. 0으로 나누거나, 파일을 열었는데, 해당 파일이 없다거나, server와 연결이 끊겼을 때.. 이런 예외가 발생했을때, 다른 대응 코드를 사용해서 처리해야 한다.\ntry except 코드 예외 발생이 예상되는 코드가 있다. 그 code에 다음과 같이 처리하면, 예외가 발생했을 때 그냥 program이 종료하는게 아닌, 적절한 대응을 해서 계속 진행이 가능하다.\ntry: \u0026lt;예외 발생 가능 코드\u0026gt; except \u0026lt;예외클래스\u0026gt;: \u0026lt;대응 코드\u0026gt; exception handling example for i in range(-5,5): try: print(10/i) except ZeroDivisionError: print(\u0026#34;Zero Division, skip the number.\u0026#34;) i가 0이 되면 zero division error가 발생한다. try exception처리가 없다면, program은 종료한다. exception처리를 했기 때문에 for-loop를 계속 진행한다.\nBuilt-in Exception Exception class 설명 발생 가능 예시 Index Error List의 index범위를 넘어감. list[001] Name Error 존재하지 않는 변수를 호출 not_exist+1 Zero Division Error 0으로 숫자를 나눔 10/0 Value Error 반환할 수 없는 문자열/숫자를 변환 float(\u0026ldquo;abc\u0026rdquo;) FileNotFoundError 존재하지 않는 파일 호출 open(\u0026ldquo;not exist.txt\u0026rdquo;,\u0026ldquo;r\u0026rdquo;) 이것 외에도 많은 built-in exception들이 있다.\nException class Exception들은 BaseException에서 상속받은 class들이다.\nexception이 inheritance를 갖기 때문에 try except에서 처리할 때 부모 class를 잡아서 처리하는게 효율적이다. 참고로 위 tree에서 exception처리할 수 있는 class는 Exception아래 클래스만 해당한다.\ntry: except Lookuperror: 이렇게 하면, index error와 key error에 대한 처리가 가능하다. 사용자 정의 Exception도 만들 수 있는데, 만들기 위해선 Exception class를 상속해서 만들면 된다.\nRaising \u0026amp; Referencing Exception raise구문으로 예외를 발생시킬 수 있다. 그리고 as 구문으로 잡힌 에러를 참조 할 수 있다.\ntry: while True: value = input(\u0026#34;A,B,C중 하나를 입력하세요:\u0026#34;) if len(value) ==1 and value not in \u0026#34;ABC\u0026#34;: raise ValueError(\u0026#34;잘못된 입력입니다. 종료합니다.\u0026#34;) print(\u0026#34;선택된 옵션:\u0026#34;, value) except ValueError as e: print(e) 위 코드에서 raise로 Exception객체를 만든다. 이렇게 만들어진 exception객체는 except구문에서 잡을 수 있다. ValueError 클래스 객체라면 e로 잡고, e를 출력하면 Exception객체가 가진 값을 출력한다. 만일 except문에서 처리하지 못한다면, program은 종료하게 된다.\nAssertion assert문이 있다. 조건을 확인해서 참이 아닐때 AssertError를 발생한다. raise가 무조건적인 error를 발생시킨다면, assert는 조건을 확인하고 발생시킨다.\nassert \u0026lt;조건\u0026gt; assert \u0026lt;조건\u0026gt;, \u0026lt;에러 메시지\u0026gt; def add_int(param): assert isinstance(param,int), \u0026#34;int만 된다.\u0026#34; return param+1 try: print(add_int(10)) print(add_int(\u0026#39;str\u0026#39;)) except AssertionError as e: print(e) try except는 try~catch구문과 동일하다. add_int가 try문에 걸려 있는데, 여기서 assert문이 있다. param이 int가 아니기 때문에 AssertionError가 발생한다. 그리고 except에서 해당 error를 catch해서 처리한다.\npost-error processing try-except문에는 except로 error를 잡아서 처리하는 것 외에 다른 처리를 할 수 있게 else와 finally같은 keyword가 존재한다. 3개의 각각의 경우를 비교해 보자. functions()에서 SomeError가 발생하거나 다른 Error가 발생하지 않을때, 대비하는 코드인 except, else, finally가 어떻게 수행되는 지 보자.\nexcept만 있는 경우 try: functions() except SomeError as e: print(e, \u0026#34;예외 발생\u0026#34;) print(\u0026#34;예외 이후\u0026#34;) 예외발생이 없는 경우 \u0026ldquo;예외 이후\u0026quot;를 출력. SomeError가 발생한 경우 \u0026ldquo;예외 발생\u0026quot;을 출력 \u0026ldquo;예외 이후\u0026quot;를 출력. 다른 예외가 발생한 경우. 프로그램 비정상 종료 else가 있는 경우 try: functions() except SomeError as e: print(e, \u0026#34;예외 발생\u0026#34;) else: print(\u0026#34;예외 이후\u0026#34;) else의 의미가 좀 애매하다. 왜냐면, try-except에서 처리가 되는 경우에 대한 else이기 때문이다. 즉 except에서 처리가 되지 않는 경우는 else를 수행하기 때문이다.\n예외발생이 없는 경우 \u0026ldquo;예외 이후\u0026quot;를 출력. SomeError가 발생한 경우 \u0026ldquo;예외 발생\u0026quot;을 출력 다른 예외가 발생한 경우. 프로그램 비정상 종료 finally구문이 있는 경우 try: functions() except SomeError as e: print(e, \u0026#34;예외 발생\u0026#34;) finally: print(\u0026#34;예외 이후\u0026#34;) finally구분은 모든 경우에 출력되는 것을 볼 수 있다.\n예외발생이 없는 경우 \u0026ldquo;예외 이후\u0026quot;를 출력. SomeError가 발생한 경우 \u0026ldquo;예외 발생\u0026quot;을 출력 \u0026ldquo;예외 이후\u0026quot;를 출력. 다른 예외가 발생한 경우. \u0026ldquo;예외 이후\u0026quot;를 출력. 프로그램 비정상 종료 Exception Handling Example for i in range(5,-5,-1): try: value /= i except NameError: print(\u0026#34;No value on Value: set 0\u0026#34;) value = 10 except ZeroDivisionError: print(\u0026#34;Zero Division: Skip\u0026#34;) except Exception as e: print(type(e),e) raise e else: print(value) finally: print(\u0026#34;step\u0026#34;) 첫번째로 발생하는 error는 NameError다. NameError가 발생하는 이유는, value /= i에서 발생한다. 이것은 value = value/i인데 좌변은 문제 없지만 우변이 문제가 있다. 우변의 value는 값을 가지고 있지 않다. 따라서 NameError가 발생한다. 그리고 finally가 수행된다. finally는 try except에서 처리하던 안하던, 수행이 되는 구문이기 때문이다. else는 try-except에서 error를 처리하지 못하면 수행된다. 따라서 zerodivisionerror가 발생한 이후는 계속해서 else와 finally만 수행되게 된다.\nLogging 처리 개요 program안에서 일어난 일을 logging할 수 있다고 한다. debug를 위해서 logging을 할 수도, 사용자 패턴파악을 위해서 logging을 할 수 있다고 한다.\nLogging module 사용 import logging logging.debug(\u0026#34;디버깅\u0026#34;) logging.info(\u0026#34;정보 확인\u0026#34;) logging.warning(\u0026#34;경고\u0026#34;) logging.error(\u0026#34;에러\u0026#34;) logging.critical(\u0026#34;치명적오류\u0026#34;) 상황에 따라 다른 level의 log출력이 가능하다고 한다. 아래 처럼 level을 갖는 log를 보여준다.\ndebug \u0026lt; info \u0026lt; warning \u0026lt; error \u0026lt; critical 디버그를 할때 print debug라는게 있다. 즉 tracer를 사용해서 debugging을 할 수도 있지만, 값을 찍어서 확인할 수도 있는데, 그때 이 log 모듈을 사용할 수 있다. log가 level이 있다면, 저장될때도, level에 따라 file에 저장되거나, 혹은 화면에 출력되는것도 결정하는걸로 알고 있는데, 그것에 대한 설명은 없다. 다만 아래 표를 읽어줬는데, 이표만 가지고는 별 도움이 안되는거 같다.\nlevel 설명 예시 DEBUG 상세한 정보, 문제를 진단할 때 사용 변수 A에 값대입, 함수 F호출 INFO program이 정상동작중 발생하는 event보고 서버시작, user의 서버접속 WARNING 예상치 못한 일이 발생하거나, 발생할 문제에 대한 보고 문자열 대신 숫자 입력, 인자로 들어온 list가 길이가 안맞음 ERROR 오류가 발생했으나 program은 동작가능 파일이 없거나 외부 서버 연결이 불가능 CRITICAL 심각한 오류 발생, 프로그램이 실행되지 않을 때 중요 파일이 없거나 사용자 강제 종료시 root logging 왜 root logging이라고 부르는지는 모르겠다. 하지만 여기서 logging을 할때 저장되는 문자열에 root가 있다고 한다. 예를 들면,\nWARNING:ROOT: this is warning message ERROR:ROOT: this is error message import logging logging.basicConfig( filename=\u0026#39;test.log\u0026#39;, level=logging.INFO ) logging.debug(\u0026#34;기록 안됨\u0026#34;) logging.info(\u0026#34;기록 됨\u0026#34;) logging.ERROR(\u0026#34;기록 됨\u0026#34;) basicConfig에서 설정하는 내용을 보면 log가 저장될 파일과 level이 정해진다. debug가 기록되지 않는 이유는 info보다 level이 낮기 때문이다. 우리가 program을 개발할때, develop단계에서는 debug를 위해서 print문을 많이 쓴다. 그리고 그 코드가 product단계로 가서, 그대로 출시될 수도 있다. logging을 사용하면 그런 문제를 막아줄 수 있다. logging에서 print의 level을 정할 수 있기 때문에, basic config만 설정하면된다. print문이 많다면, 모든 print문을 찾아서 지우거나 혹은 필요한것만 남겨야 하는데, logging을 사용하면 간단히 처리할 수 있다.\nlogger management root logger가 아닌, 새로운 이름의 logger를 만들기 위해선, getlogger를 사용한다고 한다.\nimport logging logging.basicConfig( filename=\u0026#39;test.log\u0026#39;, ) # logger = logging.getLogger(\u0026#34;main\u0026#34;) # 새로운 logger생성 logger = logging.getLogger(__name__) # module이름으로 logger생성 logger.setLevel(logging.INFO) logging.info(\u0026#34;Root에 info 기록\u0026#34;) logging.warning(\u0026#34;Root에 warning 기록\u0026#34;) logging.info(\u0026#34;메인에서 info기록\u0026#34;) logging.warning(\u0026#34;메인에서 warning기록\u0026#34;) basicConfig라는게 root logger의 설정이라고 한다. 하지만 getLogger로 새로운 user logger를 만들면 root logger의 설정을 그대로 사용하게 된다고 한다. 강의가 좀 부실하다. 나중에 더 조사해야 할듯하다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture12-setting-exception-logging\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture13-web\/": {
        "title": "lecture13-web",
        "tags": [],
        "content": "web crawling web crawling 개요 우리가 browser로 보는 화면은 html문서를 formatting한 것이다. web 문서인 html문서를 browser가 우리 컴퓨터에 down받고 down받은 html문서를 formatting해서 보여주는 것이다. browser가 html문서를 down받아서 보여주는 것처럼, python에서 html문서를 down받아서 분석할 필요가 있다. 이것을 web crawling이라고 한다. python에서 html문서를 가져오기 위해서는 requests라는 사용자 library를 사용해야 한다.\nRequests 설치 conda install requests requests 사용법 예시 import requests URL = \u0026#39;https://www.naver.com\u0026#39; response = requests.get(URL) print(response.status_code) print(response.text) request.get으로 html문서와 여러 응답결과를 객체로 만들어 return한다. return한 객체에 html문서가 있다. 문서는 text라는 변수가 가리킨다.\nCrawling 예시 import requests from bs4 import BeautifulSoup URL = \u0026#34;https://sports.news.naver.com/index\u0026#34; response = requests.get(URL) soup = BeautifulSoup( response.text, \u0026#39;html.parser\u0026#39; ) headline = soup.find(name=\u0026#39;ul\u0026#39;, attrs={\u0026#39;class\u0026#39; : \u0026#34;today_list\u0026#34;}) for title in headline.find_all(name=\u0026#39;strong\u0026#39;, attrs={\u0026#39;class\u0026#39;:\u0026#34;title\u0026#34;}): print(title.string) 간단한 web scrawl의 경우 beautifulsoup으로 해도 되지만, 복잡한 구조의 html문서의 web crawling은 scrapy패키지를 사용한다.\n강의 끝 강의에서 미흡된 부분은 아래와 같다.\nMulti thread Networking ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture13-web\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture3_data-structure\/": {
        "title": "lecture3 data structures",
        "tags": [],
        "content": "Data Structure List list의 특징 대괄호로 만들어진다. 아무 type의 객체를 가리킬수 있다. list가 con cell로 이루어져있고 car, cdr이 모두 pointer라서 어떤 type의 객체를 가리키는건 너무 자연스럽다. 길이가 정해져 있지 않다. seq = [12345,101, \u0026#34;Text\u0026#34;, None, True] print(seq) list index \u0026amp; slicing indexing\nindex로 개별 원소를 접근한다. 이 부분이 좀 특이하다. lisp에서 개별 원소에 접근할 때는, linked list이기 때문에 car과 cdr을 사용해서 access했기 때문에, 마치 배열처럼 index로 접근한다는건 좀 특이하다. 배열이 index로 접근할 수 있는건 각각의 원소가 위치한 메모리 공간이 붙어있기 때문에, index로 해당 원소의 메모리 공간을 지정할 수 있기 때문이다. 그런데, list는 그렇지가 않다. index를 지정해도, index만큼 포인터를 이동해야만 하기 때문이다. 예를 들어, list의 2번째 원소에 접근하는것은 car(car a)을 의미한다. 즉 a[2] =\u0026gt; car(car a)를 변환될 듯하다. 음수도 indexing이 가능하다. slicing\n사용법: seq[start: end: step:] default값은 생략 가능하다. start: end: 가 0이거나, step:이 1인 경우 생략 가능하다. example seq=[1,2,3,4,5,6,7,8,9,10] print(seq[:3]) print(seq[3:]) print(seq[3:-1]) print(seq[-3:-1]) print(seq[::2]) print(seq[9:2:-1]) print(seq[9:2:1]) seq[:3]은 index가 0,1,2를 의미한다. 3은 포함하지 않는다. seq[3:]은 index가 3,4,5\u0026hellip;9까지를 의미한다. seq[3:-1]은 index가 3,4,5\u0026hellip;8까지를 의미한다. seq[::2]는 step만 지정하는 것도 가능하다. seq[9:2:-1]는 9부터 시작해서 2로 간다. 9보다 작은것으로 갈려면 step을 -값으로 해주어야 한다. seq[9:2:1]은 9부터 시작해서 2로 가는데, 1씩 더해서 간다. 이런 경우, []를 얻는다. lisp의 list와는 다른 list원소 접근법이다. index로 접근하는것은 직관적이긴 하다. function과 같이 쓰일때 강력한 성능을 보일지는 모르겠다. List operators\nappend(+)\na = [1,2,3,4] b = [5,6,7,8] print(a + b) a = a + b print(a) list는 mutable객체라서 a = a + b를 해도 새로운 객체가 만들어지진 않을 듯하다. 원소 값 바꾸기\na[0] = \u0026#39;something\u0026#39; multiply(*)\nlist에 곱하기도 연산이 가능하다. a = [1,2,3,5] print(a * 2) in 연산자.\na = [1,2,3,4] print(3 in a) len(): 길이 구하는 operator\nseq = [1,2,None, True] print(len(seq)) append(): 원소를 추가한다. 뒤에 추가된다.\nextend(): list를 추가한다. 뒤에 추가된다.\ninsert(index,value): index에 value를 추가한다.\ndel: list의 element를 삭제한다. method나 operator형태가 아니다.\na = [1,2,3] del a[1] print(a) remove(value): list의 method. list의 특정 값을 삭제한다. 하나만 삭제한다. 동일한 값이 또 있어도 삭제하지 않는다.\na = [1,\u0026#34;sth\u0026#34;,23, \u0026#34;sth\u0026#34;] a.remove(\u0026#34;sth\u0026#34;) print(a) python은 모든것이 object이고, 모든 function은 method다. 강사는 내장함수와 메소드를 나누어 설명한다. 또한 예약어를 말하기도 한다. 나는 내장함수도 method라고 생각한다. 그런데, fluent python이란 책에서는 len은 method가 아니라고 한다. 예약어는 ()를 사용하지 않는다. 내장함수(built-in function) len() sum() range() method .append() .insert() 예약어 del assert 강사는 예약어, 내장함수, method, 내부 library, third-party의 순서로 원하는 기능을 구현한 함수를 찾으라고 한다. list의 time complexity big-Out 표기법\nbig-O는 함수는 아니고, 표기법이 함수 형태일 뿐이다. 나는 big-O의 O가 out(결과)를 나타낸다고 생각한다. 입력 argument의 개수를 I로 표시하기로 했다. I(N) = O(1) : n개의 입력이 있다면, 1번의 computation이 일어날때 이렇게 표기한다. 이 말은 무한의 데이터가 있어도, 1번만 혹은 10번만 computation하면 된다는 말이다. 즉 input의 개수와 상관이 없다. O에 N이 포함이 안되었다는건 관련이 없다는것이다. 무한대의 입력이 있으나, 없으나 상관이 없다. I(N) = O(logN) : n개의 입력이 있다면, logN번의 computation이 일어날때 이렇게 표기한다. ex) 16개의 입력이 있다면, 4번만 계산하면 된다. I(N) = O(N): n개의 입력이 있다면, n번의 computation이 일어난다. I(N) = O(NlogN): n개의 입력이 있다면, NlogN의 computation이 일어난다. I(N) = O(N^2): 보통 double loop I(N) = O(N^n): list의 operator와 big-O 표현법\nindex: l[i] =\u0026gt; O(1) index는 list의 원소를 꺼낼때, O(1)이 걸린다. 즉 한번에 데이터를 꺼낼수 있다는 말이다. linked list나 lisp을 사용하는 입장에선 조금 이해가 안 갈 수가 있다. 100개의 item으로 구성된 list에서 하나의 원소를 꺼낼때, list의 첫번째 원소가 원하는 값이면 1번의 계산, 최악의 경우 마지막 원소와 일치한다면 100번의 이동이 필요하다. 따라서 O(N)을 예상한다. 그런데 python에선 O(1), 마치 array와 같은 속도를 보인다고 하니까 놀랠 수 밖에 없다. array가 O(1)의 속도를 갖는 것은 address와 index를 더해서 특정 메모리공간을 지정할 수 있기 때문이다. 즉 한번의 덧셈만 하면 된다. 그런데 linked list에서는 그렇지 않다. 매번 list item을 거쳐가야 한다. 어떻게 O(1)이 나오는지는 모르겠다. python에서 list는 동적배열(dynamic array)라서 가능하다고 하는데, 아직 설명이 없다. 참고로 list operator의 입력으로는 list가 들어간다고 생각하면 된다. store: l[i] =\u0026gt; O(1) store도 array처럼 현재 address + index로 특정 메모리 공간을 한번에 지정이 가능하기 때문에 O(1)이다. len: len(i) =\u0026gt; O(1) 왜 length가 O(1)인지 모르겠음. append: l.append(5) =\u0026gt; O(1) append는 list의 마지막에 추가하는것이기 때문에 list객체가 1000개의 item이 있던, 10000개가 있던간에 O(1)이 될 것이다. pop: l.pop(n) =\u0026gt; O(1) pop 함수는 n번째 요소를 제거한다. 그리고 꺼낸 요소를 반환한다. array라면, index와 address를 사용해서 item의 위치를 지정할 수 있기 때문에 한번의 연산으로 해결될 수 있을껄로 보인다. clear: l.clear() =\u0026gt; O(1) list의 clear()는 모든 요소가 제거된다. 그런데 왜 O(1)이 걸릴까? list 객체가 가진 value에 list가 pointer로 연결되어 있다면 그 Value값을 0로 만들면 되는 것이기 때문이지 않을까? insert: l.insert(n,v) =\u0026gt; O(N) list의 특정 index에 특정값을 입력하는것은 최선의 경우는 마지막원소 끝에 insert하면 하나의 list cell을 추가 하기 때문에 1번의 계산이면 된다. 최악의 경우, 첫번째 item에 삽입하면, 그 뒤의 요소들을 하나씩 뒤로 이동 시켜야 하기 때문에 O(N)이 된다. delete: l.delete(n) =\u0026gt; O(N) delete도 list의 특정 item을 삭제하고, list의 item별로 위치 재조정을 하기 때문에 O(N)이 걸린다. remove: l.remove(value) =\u0026gt; O(N) remove함수는 value를 list에서 찾아서 삭제한다. 최악의 경우 list 마지막 item에 원하는것이 있을 수 있다. 이 경우 마지막까지 원소를 비교해야 하기 때문에 O(N)이 걸릴 수 있다. 동적 배열에 대해서 list를 array로 만든다. linked list가 아닌, array다. array가 가진 특징인 fixed된 array와 다르게 dynamic array는 특정길이의 array가 할당되지만 할당된 크기를 넘어가면 자동으로 array가 늘어나는 방식이다. 이것은 lisp의 vector와 비슷할 것이라고 생각된다. Tuple tuple의 특징 tuple의 모양: ()를 사용한다. ,로 사용해도 된다.\nt = (1,2,3,4) t = 1,2,3,4 print(t) tuple은 immutable하다.\nassign이 불가능하다.\nt = (1,2,3,4) # t[3] = 8 ;; 실행되지 않는다. immutable하기 때문이다. immutable은 update가 안된다. assign이 가능할 수도 있다.\nt = (1,2,[5,6,7]) t[2].append(8) print(t) 함수 return값으로 사용된다. 아래와 같이 여러 값을 return할 수 있다.\nreturn 1,2,3 하나의 요소를 가진 tuple\nt = (1) # tuple이 아니다. int다. print( type(t)) t = (1,) # tuple이다. print(type(t)) string은 immutable하다는 면에서 tuple로 봐도 된다.\npacking과 unpacking packing: 여러 데이터를 묶기, unpacking: 여러 데이터를 풀기\nt = 1,2,3,4,5 ;; packing a,b,c,d,e =t ;; unpacking print(d) unpacking의 관습: _를 사용해서 필요없는값은 사용하지 않는다.\nt = \u0026#34;holy\u0026#34;,1,2,3 name,_,_,_ = t print(name) unpacking과 packing은 list에서도 가능하다.\nt = [\u0026#34;holy\u0026#34;,1,2,3] name,_,_,_ = t print(name) 특이한 unpacking: *를 사용해서 나머지 해당 요소들을 list로 묶는다.\nt = [1,2,3,4,5] a, *b, c =t print(a,b,c) dictionary dictionary의 특징 {}을 사용한다.\ndictionary는 사전형태다. 즉 key를 사용해서 빠르게 찾는게 가능하다.\ndictionary는 mutable하다.\n요소는 key: value로 되어있다.\nkey는 immutable하다.\n{key1: value1, key2:value2, key3:value3} example\ndictionary = { 1: \u0026#39;something\u0026#39;, (1,2.5): 1.5, \u0026#39;text\u0026#39;: 2, } print(dictionary[1,2.5]) 위의 예에서 (1,2.5)라는 key가 있고, 이 key값에 접근할 때, dictionary[1,2.5]라는 표기를 눈여겨 볼 필요가 있다. 왜냐하면, key가 tuple이기 때문에 ()없이 사용할 수 있다.\n만일 a[1,2,3], dict[a,[1,2],3:5] 이런식의 표현법을 보면 key가 tuple이라고 생각하면 된다.\ncomma(,)에 대해서\ndictionary를 만들때나 list, tuple의 마지막 원소 다음에 ,를 입력해도 아무 문제 없다. dictionary 기본 동작 dictionary의 생성\ndictionary = {} dictionary의 삽입\ndictionary = {} dictionary[\u0026#39;text\u0026#39;] = 1 dictionary[\u0026#39;list\u0026#39;] = [5,6,7] print(dictionary) 동일한 key값을 갖는 item은 생성 불가능, overwrite된다.\ndictionary = {} dictionary[\u0026#39;key\u0026#39;] = \u0026#39;value\u0026#39; dictionary[\u0026#39;key\u0026#39;] = \u0026#39;updated value\u0026#39; print(dictionary) dictionary item제거: del을 사용한다.\ndictionary = {} dictionary[\u0026#39;key1\u0026#39;] = \u0026#39;value1\u0026#39; dictionary[\u0026#39;key2\u0026#39;] = \u0026#39;value2\u0026#39; del dictionary[\u0026#39;key2\u0026#39;] print(dictionary) len으로 크기 확인\nlen(dictionary) dictionary의 변환\ndictionary을 list로 변환할 수 있다. 이 때 items()라는 method를 사용한다. key와 value는 tuple형태로 list의 item으로 들어가게 된다. dictionary = { \u0026#34;한국어\u0026#34;: 0 , \u0026#34;영어\u0026#34;:1, \u0026#34;중국어\u0026#34;:2} print(dictionary.items()) key만 list로 만들 수 있다. 이 때 keys()라는 method를 사용한다.\ndictionary = { \u0026#34;한국어\u0026#34;: 0 , \u0026#34;영어\u0026#34;:1, \u0026#34;중국어\u0026#34;:2} print(dictionary.keys()) value로만 list를 만들 수 있다.\ndictionary = { \u0026#34;한국어\u0026#34;: 0 , \u0026#34;영어\u0026#34;:1, \u0026#34;중국어\u0026#34;:2} print(dictionary.values()) in을 사용하는 경우\n어떤 collection의 특정 요소가 있는지 없는지 확인할때나, loop를 돌릴때 in keyword를 사용한다. dictionary와 in과는 어떤 관계가 있을까? in의 뒤에는 보통 list가 있어야 한다. in뒤에 dictionary를 직접 사용하지는 않는다. 따라서 dictionary를 list형태로 바꿔야 한다. 그래서 keys(), values(), items()라는 메소드가 존재하는 것이다. dictionary를 list로 변환후 in을 사용해서 특정값의 존재 여부를 확인할 수 있다. 여기서 2가지를 더 말하고 싶다. 첫번째로 dictionary라는게 어차피 key를 통해서 값을 꺼내면 되는건데, 굳이 in을 써서 값을 확인하기 위해 list로 변환해야 하는가? 하는 의문이 들수 있다. key를 알고 있다면, 별문제 없지만, key를 잘못썼거나, key를 모를때는 dictionary에서 key list를 뽑아서 in을 사용해서 check하는것은 그리 나빠보이지 않는다. 두번째로 in이라는건 이렇게 있는지 없는지 여부의 기본 기능보다 for-loop에서 많이 쓰인다. dictionary를 for-loop에서 사용한다고 했을때, in을 사용한다. 따라서 dictionary를 list형태로 바꿀 필요가 있다. 즉 dictionary와 in을 같이 사용한다는 것은 list로 변환해서 사용한다는 것을 의미한다. dictionary = { \u0026#34;한국어\u0026#34;: 0 , \u0026#34;영어\u0026#34;:1, \u0026#34;중국어\u0026#34;:2} print(\u0026#34;한국어\u0026#34; in dictionary.keys()) dictionary의 time complexity dictionary는 key마다 index값이 있다. index가 있다는 말은 address로 접근 한다는 뜻이다. 따라서 value에 접근하는 time complexity는 O(1)이다. 이것을 hash구조라고 한다. index: d[k] =\u0026gt; O(1) key로 값을 가져오는것은 dictionary의 크기가 엄청 커도 1번의 computation으로 가능하다. store: d[k] = v =\u0026gt; O(1) length: len[d] =\u0026gt; O(1) delete: del d[k] =\u0026gt; O(1) clear: d.clear =\u0026gt; O(1) d = {} or d= dict()와 같다. Set set 개념 dictionary의 key만 모여 있는 형태.\nset을 만들때, list를 사용한다.\ns = set([1,2,3,\u0026#39;text\u0026#39;]) print(s) set에 원소 추가\ns = set([1,2,3]) s.add(4) print(s) set 원소 삭제(remove)\nset 원소에 해당하는 값이 있다면 삭제 없다면 error가 생긴다. s = set([1,2,3]) s.remove(2) print(s) set 원소 삭제(discard)\nremove는 값이 없다면 error가 생긴다. discard는 에러가 생기지 않는다. s = set([1,2,3]) s.discard(44) print(s) update 메소드\ns = set([1,2,3]) s.update([5,None, True, False, 33]) print(s) set operator 수학적 집합 연산자 존재.\n교집합(\u0026amp;)\ns1 = set([1,2,3,4]) s2 = set([3,4,5,6]) print(s1 \u0026amp; s2) 합집합(|)\ns1 = set([1,2,3,4]) s2 = set([3,4,5,6]) print(s1 | s2) 차집합(-)\ns1 = set([1,2,3,4]) s2 = set([3,4,5,6]) print(s1 - s2) 배타적 합집합(^)\ns1 = set([1,2,3,4]) s2 = set([3,4,5,6]) print(s1 ^ s2) frozen set( immutable)\nset은 mutable하다. 반면 frozen set은 immutable하기 때문에 dictionary key값으로 사용할 수 있다. a = frozenset([1,2,3]) d = {a:3} print(d) ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture3_data-structure\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture4_condition-and-loop\/": {
        "title": "lecture4_condition-and-loop",
        "tags": [],
        "content": "Condition \u0026amp; Loop 조건문은 if else, 반복문은 while-for 들여 쓰기: space 4칸, tab을 써도 된다. Conditional Statement if문 사용법1 - if,elif,else 사용법 if를 사용해서 원하는 조건을 만족하면 수행하게 한다.\nexample 1\nscore = 80 if score \u0026gt; 60: print (\u0026#34;Over 60\u0026#34;) if score \u0026gt; 70: print(\u0026#34;Over 70\u0026#34;) if score \u0026gt; 80: print(\u0026#34;Over 80\u0026#34;) 위에서 보듯이 조건에 맞으면, 출력을 한다. example 2\nexample1에서 보면, 3가지 case가 있다. 이 중에 맞는 경우가 2가지가 있다. 이럴 때, 만족하는 모든 case를 출력하지 않고 하나를 만족하면 수행을 하지 않게 하고 싶다면, elif를 사용한다. score = 80 if score \u0026gt; 60: print (\u0026#34;Over 60\u0026#34;) elif score \u0026gt; 70: print(\u0026#34;Over 70\u0026#34;) elif score \u0026gt; 80: print(\u0026#34;Over 80\u0026#34;) example 3\n만일 모든 조건을 만족하지 않을 때, 조건을 만족하지 않습니다.라는 메시지를 내보낼려면 어떻게 해야 하는가? 이 때, else를 사용한다. score = 10 if score \u0026gt; 60: print (\u0026#34;Over 60\u0026#34;) elif score \u0026gt; 70: print(\u0026#34;Over 70\u0026#34;) elif score \u0026gt; 80: print(\u0026#34;Over 80\u0026#34;) else: print(\u0026#34;wrong value\u0026#34;) if문 사용법2 - false에 해당하는 것들 false에 해당하는 값들. if False: print(\u0026#34;This sentence does not show\u0026#34;) if \u0026#34;\u0026#34;: print(\u0026#34;Empty is False\u0026#34;) if 0: print(\u0026#34;0 is False\u0026#34;) if None: print(\u0026#34;None is also False\u0026#34;) if문 사용법3 - 비교연산자와 논리연산자의 사용 example\na,b = 5,8 if a == 5 and b ==6: print (\u0026#34;This is False\u0026#34;) if not a \u0026lt; b \u0026lt; 9: print(\u0026#34;This is False\u0026#34;) if a + 3 == b: print(\u0026#34;This is True\u0026#34;) 여기서, a,b = 5,8을 보는 순간, tuple의 unpacking임에 익숙해 져야 한다. 생소하게 바라보면 안된다. ternary operator 사용법 [value1] if [Condition] else [value2] 형태. if else문인데, 생소하다. condition이 참이면 value1을 거짓이면 value2를 반환 연산자이다.라고 강사가 말했는데, 왜 연산자인지 모르겠다. 연산자 운선순위에서 가장 아래에 위치한다. 햇갈리지 않게 하기 위해서 괄호를 사용한다. value = 32 \u0026#34;odd\u0026#34; if value % 2 else \u0026#34;even\u0026#34; 연산자라 다른 연산자와 같이 사용될 수 있다고 한다. value =32 print((\u0026#34;odd\u0026#34; if value % 2 else \u0026#34;even\u0026#34;) + \u0026#34;_number\u0026#34;) Loop loop의 기본 생각은 연산을 100번 200번 적용하는 방법이다. 함수를 100번 호출하겠다. 200번 호출하겠다. 이럴때 loop를 사용한다. while while 사용법\n기본 모양\n​- while \u0026lt;조건\u0026gt;: 명령1 명령2 example\n조건을 만족하는 동안 수행한다. i = 1 while i \u0026lt; 4: print(i) i = i+1 for 기본개념\n주어진 객체를 순환하는 개념 while의 반복은 연산을 몇번 수행한다는 제어문이 포함되어 있지않다. for loop은 몇번 반복 할지를 설정하고, 몇번 반복했는지를 알 수 있는데, 이를 이용할 수도 있다. for [element] in [Iterable]의 형태로 사용 list 기본 사용예\nlist 사용 example1 for i in [0,1,2,3,4]: print(i) example2 for i in [0,1,2,3,4]: if i % 2: print(i, \u0026#34;is odd\u0026#34;) list range iterator 사용예\nrange 사용\nfor-loop에서 list를 사용하는건 비 효율적.\n100번 반복하고 싶다고 해서 0~99까지 list를 작성하는건 비효율적.\nrange라는 내장함수를 사용. generator를 반환한다.\ngenerator는 숫자를 하나씩 생성 반환한다.\nfor-loop에서 필요한것은 counting. counting을 위해서 list를 사용하면 많은 메모리 필요, generator는 next counting값을 하나만 가지고 있다. 따라서 메모리 효율적.\nrange(start,end,step) 형태.\nrange는 지정된 횟수가되면 error를 발생하고, 이 error를 받아서 loop가 종료된다.\nexample1\nfor i in range (5): print(\u0026#34;test2\u0026#34;, i) range(5)는 0-4까지를 의미한다. example2\nfor i in range(1,6): print(\u0026#34;test3\u0026#34;, i) range(1,6)은 1~5까지를 의미한다. example3 for i in range(1,10,2): print(\u0026#34;Test4\u0026#34;,i) string iterator, dictionary 사용예\nexample1\nfor c in \u0026#34;This is text\u0026#34;: print(c) example2\nfor word in [\u0026#34;한국어\u0026#34;,\u0026#34;문장\u0026#34;,\u0026#34;처리\u0026#34;]: print(word) example3\nfor key in {\u0026#34;text\u0026#34;:1, \u0026#34;word\u0026#34;:2}: print(key) example4\nfor key in {\u0026#34;text\u0026#34;:1, \u0026#34;word\u0026#34;:2}.values(): print(key) example5\nfor key in {\u0026#34;text\u0026#34;:1, \u0026#34;word\u0026#34;:2}.items(): print(key) dictionary를 list로 바꾸는 이유는 in하고 같이 쓰일 때이다. in은 for와 같이 쓰이기 때문에, dictionary를 list형태로 바꿔야 한다. keys(),values()는 자주 변환되는 형태다. 그런데 items()는 어디에 쓰일지 궁금하다. key와 value를 tuple형태의 item list가 어디에 쓰일지도 궁금하다. 이것을 강사가 설명한다. example6에 작성했다. example 6\nfor key, value in {\u0026#34;a\u0026#34;:1, \u0026#34;b\u0026#34;:2}.items(): print(key,value) items()가 반환하는 tuple list를 어떻게 사용하는지 궁금했다. tuple list의 형태로 되어 있는것을 꺼내서 쓸때는 unpacking한다. tuple이기때문이다. tuple을 사용하는 방식은 unpacking이기 때문이다. 그래서 위의 key, value in dictionary 형태로 사용된다. break \u0026amp; continue break\nbreak를 사용하면, 여러개의 loop로 둘러싸여 있더라도 가장 바깥쪽의 loop를 벗어날 수 있다. 강사 자료 오타. range문의 수정. for i in range(1,100): if i % 17 == 0: break print(i) continue\ncontinue문은 loop의 처음으로 되돌아간다. example for i in range(100): if i % 17: continue print(i) loop에서 else\npython의 loop에 있는 특별한 기능\nelse를 loop와 같이 사용할 수 있다. 반복문이 끝났을 때 실행되는 block으로 보면된다.\nexample\nfor i in range(10): print(i) else: print(\u0026#34;loop complete with break\u0026#34;) 0-9까지 loop를 돌고 \u0026ldquo;loop complete with break\u0026quot;를 출력한다. example2\nfor i in range(10): print(i) if i \u0026gt; 5: break else: print(\u0026#34;loop complete without break\u0026#34;) else는 for block안에 있진 않다. 그래서 break문으로 for loop를 벗어난다면, else블럭이 실행되야 한다고 생각하지만, 실행되지 않는다. 이걸로 알 수 있는건 for block과 else블럭은 연관되어 있다고 볼 수 있다. ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture4_condition-and-loop\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture5_function\/": {
        "title": "lecture5_function",
        "tags": [],
        "content": "function python에서 모든것은 객체다. function은 method이면서 객체다. function이 method인건, 내부인자로 self를 넣을 수 있다는것만 봐도 객체의 method다. object의 method다. function 그자체는 symbol object의 구조를 갖기 때문에 또한 객체다. 내가 봤을 때는 lisp의 symbol structure를 그대로 가져온 듯하다. lisp에서 function은 symbol structure에 저장된다. 마치 symbol을 object로 말한다는 느낌이다. 참조:https://medium.com/swlh/everything-is-an-object-in-python-learn-to-use-functions-as-objects-ace7f30e283e 변수의 경우, assignment(=) operator로 객체를 만들었다면, function의 경우 def란 keyword로 function객체를 만드는 거 같다. 함수가 호출된다는 것은 이미 function객체가 어딘가에 만들어져 있다는 것이다. 함수 호출시 값을 전달할때 값을 stack에 넣고, function definition의 argument와 binding될 꺼 같은데, function definition의 argument는 global,nonlocal로 선언되었는지, 아니면 그냥 local 변수인지 모르겠다. python interpreter는 def를 보면, name,body에 해당하는 function값을 객체로 만든다. 호출할때 만드는게 아니라, def를 보고 만들거나, 이미 만들어져 있다. 만들어진 객체들은 symbol table(name space)에 저장된다. 혹은 저장되어 있다. def로 함수를 정의할때 함수의 인자들은 body에 있는 local 변수로 보면된다. 함수 호출이 일어나면, stack에 parameter를 넣어두고, body를 실행하는데, 이때, argument를 하나씩 binding시키면서 처리가 된다. function의 기본구조 def name(arg1,arg2...): statement1 statement2 return [value] return값이 없는 경우 None값이 return된다.\nexample\ndef rectangle_area(x,y): return x * y row = 10 col = 100 print(rectangle_area(row,col)) print(rectangle_area(20,1.5)) 여기서 눈 여겨 봐야 할 것은 x,y는 동적 typing이 된다는 사실이다. 함수가 호출되서 객체가 만들어 질때, x,y에 해당하는 값들이 eval되어 전달 된다. 첫번째는 10,100이 전달되고, 두번째는 20,1.5가 전달된다. 전달 되면 binding이 된다.즉 assignment가 실행되는데, assignment는 rvalue에 해당하는 값(여기선,10 or 100)의 type을 가져온다. 즉 int를 가져오기 때문에, 만들어지는 객체는 int객체가 만들어지고, 그들의 이름은 x,y가 되는 것이다. 따라서 return값도 int가 된다. 두 번째 함수에서는 float가 된다. 동적 typing에 따라서 만들어지는 객체 type이 결정되는 과정을 알 필요가 있어서 적었다. call by reference 구조의 문제점. 함수를 호출할때, 인자 전달을 할때 주소를 전달할 때, call by reference라고 한다. 값을 전달하면 call by value.\npython에서 call by reference 사용예라고 보여준다. 그런데 난 이 설명이 잘못되었다고 생각한다.\nexample\ndef function(seq2): seq2 += [1] seq1 = [1,2,3,4,5] function(seq1) print(seq1) seq1은 [1,2,3,4,5]와 binding되어 있다. 즉 seq1의 이름을 갖고, list [1,2,3,4,5]값을 갖는 객체다. 함수 호출을 하면 argument와 binding을 한다. binding하면, seq2의 이름을 갖고 list [1,2,3,4,5]의 값을 갖는 객체가 만들어진다. 여기서 seq2에대한 operator(+=)연산을 한다. operator는 해당 객체의 값을 update한다. 따라서 seq2의 값인 [1,2,3,4,5]를 [1,2,3,4,5,1]로 update한다. 여기서 중요한것은, seq1의 값은 list 객체이고, seq2의 값도 list객체를 값으로 갖는다. seq2에서 list객체의 값을 update했기 때문에 seq1이 참조로 하는 list는 변경되게 된다.\n그리고 call by reference는 function에서 수정한 값이 function밖의 값에 영향을 미치는 side-effect가 존재한다. 따라서 권장되지 않는 방식이라고 한다. 그리고 그것의 해결법을 강사는 제시한다.\ncall by reference 문제의 해결. example\ndef function(seq2): seq2 = list(seq2) seq2 += [1] seq1 = [1,2,3,4,5] function(seq1) print(seq1) 강사가 제시하는 해결책은 list객체를 전달해서 seq2객체가 만들어지고, 내부에서 수정할 수 없게 새로운 객체를 만들어 사용하자.인데, 내 경우 seq += [1]이라는게 기본적으로 객체의 값을 udpate하는 operator이기 때문에, assignment로 만들면 새로운 객체가 생성될 것이기 때문에 굳이 list()으로 새로운 객체를 만들 필요가 없다는 생각이다.\nexample\ndef function(seq2): seq2 = seq2 + [1] seq1 = [1,2,3,4,5] function(seq1) print(seq1) [1, 2, 3, 4, 5] variable scope variable scope의 예 example\nvar1 = 10 var2 = 20 def function(var2): var2 += 1 print(var1 + var2) function(var2) print(var2) 여기에서 function안에 있는 var1과 var2를 보면 외부에 있는 var1을 참조한다. 이것은 lisp과는 다르다. lisp에서는 전역변수를 참조하지 못한다. scope를 벗어나기 때문이다. 그러나, python은 여타 다른 언어와 비슷하게 참조가 가능하다. variable scope예2 example\nvar1 = 1 def main(): var2 = 10 def function(): var3 = 100 print(var1,var2,var3) function() print(var1,var2) main() print(var1) 여기서 매우 재밌는 형태의 함수가 사용된다. 즉 함수 안에 함수가 있다. 여기서 global 변수라는 것은 다른 file에서 접근해서 사용할 수 있다고 한다. 반면에 local에 있는 변수들은 local scope 밖에서 참조는 불가능하다. global과 nonlocal의 사용 global\npython의 scope와 관련한 keyword중에 global이란게 있다. 이것은 말 그대로,local변수를 전역변수로 만들겠다는 의미다.\n그런데, 다른 쓰임이 한개 더 있다. example2에서 설명한다.\nexample1\ndef test(): global a a =3 b =2 return a+b test() print(a) 위에서 보면 a를 global로 선언했다. 이말은 local에 정의된 a라는 변수는 global변수로 만들겠다?라는 의미다. 따라서, a =3은 local에서도 접근 가능하고, print(a)에서도 접근 가능하다. example2\n또 다른 예를 들어 보자. a = 1 def test(): a = 3 b = 2 return a+b print(a) 그냥 정상적인 코드다.\n하지만, 우리가 다른의도를 가지고 있다면? 즉, test안의 local변수 a를 생성해서 쓰고싶은게 아니라, global변수 a의 값을 변경하고 싶을때 어떻게 할 것인가? 그런데 a =1 이라고 생성된 객체는 immutable하기 때문에 test()내에서 변경자체가 안되는데 무슨 소리야라고 할 수 있다. 하지만, global로 선언하면 비슷한 효과를 낼 수 있다. 비슷한 효과라기 보단, 내 생각엔 global로 선언한다는 의미가, a =3이라는 문장에서 객체를 만들면, global에서도 a라는 새로운 객체가 만들어진다고 생각한다. 그래서 이전에 a=1로 생성한 객체는 접근할 수가 없다. 새롭게 a라는 이름을 가진 객체를 만들었기 때문이다.\na = 1 def test(): global a a = 3 b = 2 return a+b print(test()) print(a) 결론적으로 local scope내에서 global로 선언하면 local scope 외부에서 참조할 수 있다.라고 보면된다. nonlocal\nnonlocal도 local변수를 local scope외부에서 만들겠다는 의미다. global하고 비슷하다. 다만, global은 top-level의 전역 scope를 갖게 한다면, non-local은 local scope의 바로 바깥 outer scope를 의미한다.\n이것을 설명하기위해 예를 든다면, 중첩 function을 사용해야 한다.\nvar = 1 def main(): var = 10 def function1(): global var var += 1 def function2(): nonlocal var var += 1 function1() function2() print(var) main() 여기에서 global과 nonlocal이 같이 쓰였다. function1이 호출되면, var변수는 global에서 생성된다. function2가 호출되면, var변수는 바로 바깥쪽 scope에서 생성된다. 전체 과정을 살펴보자. 전역변수 var은 1값을 갖는다. main()가 호출된다. local변수 10값을 갖는 var이 만들어진다. function1()이 호출된다. local과 global에 var변수를 생성한다 값은 11을 갖는다. main의 local변수인 var은 읽기만 할뿐이다. function2()를 호출한다. function2의 nonlocal은 main에 있는 var값과 동일한 이름의 var변수를 만든다. 그 값은 11이된다. print(var)은 (7)에의해 11값을 출력한다. variable capture 우선 용어의 의미는 잘 모르겠다. 예제를 보자.\nvar = 1 def function(): print(var) var += 1 function() 여기서 var +=1은 2가되고, function에선 var값을 출력한다. 강사는 말한다. 이것은 pure function이 아니라고, function의 연산은 주어진 argument를 계산하고 return해야 하는데, 외부에서 변경될 수 있는 변수가 함수를 control하고 있다는 것이다. 이것은 전역변수에 의해 control되는 function도 동일한 의미를 갖는다.그래서 pure function이 아니다. 함수형언어에서 variable capture라는 용어가 있다고 한다. 환경이라는 말과, closure라는 말이 나온다. 정확히는 모르겠다. 이런형태의 코드는 피하라고 한다. closure closure example1\n강사가 closure를 설명하면서 환경얘기를 많이 하는데 뭔소린지 모르겠다. 예제를 보자.\nexample\nnumber = 10 def print_closure_factory(number): def print_closure(): print(number) return print_closure print_5 = print_closure_factory(5) print_10 = print_closure_factory(10) number += 10 print_5() print_10() python에서는 function은 객체이기 때문에, print_closure_factory라는 객체안에 print_closure라는 객체가 선언된걸로 밖에 안보인다. 그냥 print_closure_factory(number)를 호출하면 함수가 return값으로 나온다는 것밖에 모르겠다. 왜냐면 여기서 이렇게 복잡하게 짤 필요가 없기 때문이다. 그냥 argument를 갖고, return값을 갖는 하나의 함수를 만들어서 사용하면 된다. 굳이 이렇게 짤 필요가 없다. 이것은 예제가 잘못된거 같다. 굳이 closure로 설명할 필요가 없다. closure를 보면 lazy evaluation이 생각난다. 함수 내부의 함수로 정의되며, return이 함수인경우 return되는 함수는 바로 evaluation되지 않는다. closure example2\nexample def add(var): return var + 2 def multiply(var): return var * 2 def factory(function, n): def closure(var): for _ in range(n): print(\u0026#34;test\u0026#34;) return var return closure print(factory(add,4)(10)) print(factory(multiply, 4)(3)) closure는 함수를 입력받고, 함수를 출력하는 함수를 뜻하는 것 같다. factory를 보면 인자가 2개다. 함수와, 그 함수를 몇번 수행하겠다는 횟수를 입력받는다. factory의 return값은 함수다. 어떤 함수냐 하면, 반복하는 함수다. 반복하는 함수를 return하는데, 함수명과 반복횟수는 argument로 되어 있고 argument를 이용해서 return하는 함수를 만든다. 실제 실행은 return 받은 함수에 인자를 전달하면 실행이 되게 했다. return 되는 함수의 모양은 인자로 받는 함수와 모양이 비슷하다. argument의 개수가 같다. 여기서 또 한가지 눈에 띄는 부분은 var = function(var)이다. 이게 재귀적인 모습이라고 한다. add,4를 인자로 건네주면 add(add(add(add(var))))과 같은 모양이라고 한다. Decorator Decorator의 개념\n함수를 입력으로 받아서 함수를 return하는데, 같은 이름의 함수로 return하는 함수를 받을때 decorator를 사용한다.\nexample\ndef print_closure_factory(function): def print_closure(var): print(\u0026#34;Input:\u0026#34;, var) out = function(var) print(\u0026#34;Output:\u0026#34;, out) return print_closure def add(var): return var + 2 print_add = print_closure_factory(add) print_add(10) print_closure_factory(add)를 호출한다. 전달되는 add는 function 객체다. 함수가 호출되면서 binding이 일어난다. function은 add라는 function object와 binding된다. body의 function은 add로 바꿔준다. add로 변경한 print_closure function 객체를 return한다. print_add(10)을 계산한다. 이것은 decorator를 사용하지 않았다.\ndecorator 사용 예\nexample\ndef print_decorator(function): def print_closure(var): print(\u0026#34;Input:\u0026#34;,var) out = function(var) print(\u0026#34;Output:\u0026#34;,out) return print_closure @print_decorator def add(var): return var + 2 add(10) 우선 @print_decorator라는건 위의 function를 인자로 받아 function을 return하는 함수를 사용하겠다는 뜻이다. 두번째로 @print_decorator 아래는 add라는 함수와 add(10)이라는 문장이 있다. add함수는 인자로 들어가고, return값은 add라는 이름으로 받겠다는 뜻이다. 그리고 10 값을 주어 출력하겠다. Decorator의 또다른 예\nDecorator에 argument를 사용하는 경우. decorator라는것은 함수를 입력받아 함수를 return하는 것을 간략화 한것이다.\ndecorator를 선언하고 아래의 인자를 전달해서 closure를 return받아야 하는데, 그전에 먼저 decorator함수를 wrapping할 수 있다고 한다.\n즉 먼저 decorator(인자)를 수행하면, 인자값이 해당 closure에 적용된다. 이렇게 적용한 후, 다시 아래의 인자를 적용해서 함수를 return받는다.\nexample\ndef times_decorator_factory(times): def times_decorator(function): def closure(var): for _ in range(times): var = function(var) return var return closure return times_decorator @times_decorator_factory(5) def add(number): return number + 2 print(add(5)) 구조가 복잡한데, 우선 @times_decorator_factory(5)를 실행하면, times가 5로 바뀌고, times_decorator가 return받는다. return 받은 times_decorator는 또다른 decorator다. 즉 def times_decorator(function)이 된다.\n이 상태에서 아래에 있는 add함수가 인자로 decorator에 넘겨진다. function이라는 argument가 add로 replace되면서 closure를 return 받는다. return 받은 함수는 동일한 이름인 add를 갖는다.\ndecorator를 사용하면 동일한 이름의 함수를 return 받는다.\ndecorator의 주의 사항\nexample\ndef print_decorator(function): def print_closure(var): print(\u0026#34;Input:\u0026#34;, var) out = function(var) print(\u0026#34;Output:\u0026#34;, out) return print_closure @print_decorator def add(var): return var +2 print(add.__name__) decorator를 사용하면 동일한 이름으로 넘겨받은 함수객체를 사용할 수 있다고 했다. 하지만, 넘겨받은 함수객체는 function name을 가진 객체다. add.__name__은 넘겨받은 객체의 이름이다. 그렇다면 add는 무엇인가? add가 넘겨받은 함수객체와 binding이 되었다면, add.__name__은 add가 되어야 하는게 맞을 것이다. 그런데 어떤 과정으로 이것이 이렇게 되었는지는 모르겠다. appropriate Decorating\n위의 예에서 function 객체의 이름이 add가 아니고 return받은 function객체의 이름이였다. 이것을 수정하려는 것 같다.\nfrom functools import wraps def print_decorator(function): @wraps(function) def print_closure(var): print(\u0026#34;Input: \u0026#34;, var) out = function(var) print(\u0026#34;Output:\u0026#34;, out) return print_closure @print_decorator def add(var): return var + 2 print(add.__name__) 여기서 @wraps(function)라는 함수를 사용해서 입력받은 함수의 이름을 꺼내서 함수 객체를 만들때 이름으로 넣는것 같다. Recursive function factorial example def factorial(n): if n == 1: return 1 return n * factorial (n - 1) print (factorial(5)) function의 parameter parameter 사용법1 def function(var1, var2): print(var1, var2) function(var2 = 10, var1 = 15) parameter 사용법2 def function(var1, var2 = 20): print(var1, var2) function(10) function(var2 = 10, var1 = 15) parameter 사용법3 def function(var1, var2 = 20, var3): print(var1, var2,var3) 위의 예는 잘못된 case다. var2=20으로 default값이 있는경우 뒤에 옮겨야 한다. variable Length Parameter 인자의 개수가 많을 경우 남는 인자를 packing해서 사용할 수 있다.\n가변인자라고 하는데, 가변인자는 맨마지막에 한개만 위치 가능하다.\n반드시 *args라고 할 필요는 없다. *a로 해도 상관없다.\n넘겨받는 값이 몇개인지 알수 없기 때문에, stack에 있는 값들을 pointer로 전달하겠다는 뜻이다. 이렇게 하면 stack에 있는 나머지 값들이 tuple형태로(참고로 tuple은 array다.) 함수에 전달된다.\nkwargs라는 keyword argument하고 햇갈리면 안된다. *args는 stack에 올라온 값만 있는 argument를 pointer로 전달 받는다. 만일 stack에 keyword가 있는경우는 전달 받지 못한다.\nexample\ndef add_all(a,b,*args): print(args) sum = 0 for elem in args: sum += elem return a + b + sum print(add_all(1,2,3,4,5)) 함수 호출시 전달되는 (1,2,3,4,5)라는 parameter는 stack에 저장된다. 그리고 함수의 body에 대한 처리가 시작된다. 함수 정의시 지정한 argument들은 local변수이다. 표기만 ()안에 표기했을뿐 실제는 local변수와 똑같다. 따라서 stack과 body에 있는 local변수의 binding이 제일 먼저 실행된다. a =1, b=2, args=(3,4,5)이렇게 처리가 된다. args는 packing된 tuple이기 때문에 unpacking을 해줘야 한다. keyword variable length parameter 명시적으로 지정된 parameter가 남는다면, 키워드 가변인자 **(Double asterisk)를 사용하여 남는 keyword변수를 packing할 수 있다. example1 def print_args(a, *args, **kwargs): print(args,kwargs) print(print_args(1,2,3,var1=100,var2=200)) example2 parameter에는 순서가 있다. 일반인자 -\u0026gt; 기본값인자 -\u0026gt; 가변인자 -\u0026gt; 키워드 가변인자 가변인자가 tuple로 packing되었다면, keyword가변인자는 dictionary로 packing이 된다. def function(var1, var2=10, *args, **kwargs): print(var1,var2,args,kwargs) function(1,2,3,var3 =10) parameter unpacking example1\nfunction의 argument에 *가 있으면, 함수호출시 전달되는 parameter를 packing해서 받는다면, 함수 호출시 인자가 *가 있는 경우 unpacking해서 stack에 넣어야 한다. def function(a,b,c): print(a,b,c) l = [1,2,3] function(*l) example2\ndictionary를 인자로 packing해서 호출한다. packing해서 호출하는게 엄청 자주 쓰인다. def function(var1,var2,**kwargs): print(var1,var2,kwargs) d = { \u0026#39;var1\u0026#39;:10, \u0026#39;var2\u0026#39;:20, \u0026#39;var3\u0026#39;:30 } function(**d) typing hints type을 명시하지 않는다면, 가독성이 떨어진다.\nfunction의 인자와 return값에 대한 type을 명시할 수 있다.\nexample\ndef multiply_text(text: str, n: int) -\u0026gt; str: return text * n example\nvariable에도 type을 달 수 있다. a: int =4 s: str =\u0026#34;a\u0026#34; function에 대해서 (내생각) 가끔 보면, len()같은 경우 어디선 len()가 function으로 define되어 있다고 생각할 텐데, method로 정의 되어 있을 수 있다는 것을 알아야 한다. __로 시작하는 dunder method의 경우 객체.method로 접근이 안된다. 왜냐면 __로 이름이 시작되면 mangling된다. mangling된다는 것은 이름이 변경된다는 것이다. __라는 이름으로 access할 수 없다. 이런 dunder method는 사용법도 다르다. 예를 들어, a()는 method가 어떤 class에 정의되어 있다면, a(객체) 이런 식으로 사용된다. 따라서 모양만 보곤, a라는 function이 어딘가에 정의되어 있다고 생각하겠지만, 인자로 들어가는 객체 class에 __a라는 dunder method일 확률이 높다. 내생각에 python에서 모든 function은 특정 class의 method일거 같다는 생각이다.\n우리가 function을 사용하는 이유 우리가 programming을 작성하다보면, 대부분의 작업이 유한개의 data sequence를 입력을 받고, 입력받은 data를 for-loop과 if를 사용해서 다른 형태의 data sequence로 만든다던가, 값을 출력하는 일이다. 이것을 python에서는 내장 method나 외부 library의 method들이 내부적으로 이런 일을 한다. function은 일반화 한단 말을 많이 한다. 일반화 한다는 것은 여러개의 data에 모두 통용되는 계산이기 때문에, 보통은 많은 data를 처리할수 있는 기능이 있다. 그래서 for-loop를 내부적으로 처리한다. 내가 하고 싶은 말은 function이나 method를 작성할때도 고려해야 하지만, 사용할때, 내가 사용하는 함수가 내부적으로 data sequence를 입력받고 for-loop과 if를 처리한다는 것을 염두에 두어야 한다. 외장 function이나 우리가 가져다 쓰는 function들은 대부분 우리가 for-loop if로 처리해야 할것을 미리 해둬서 그냥 가져다 쓰기만 하게 만든 것이기 때문이다. 우리가 for-loop과 if를 사용할 일이 있다면, function을 찾아보고 사용하면 된다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture5_function\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture6-pythonic-programming\/": {
        "title": "lecture6-pythonic programming",
        "tags": [],
        "content": "Pythonic Programming for-in-iterator-loop, iterator,generator in predicate \u0026lsquo;in\u0026rsquo; keywords를 사용하는 건 2가지가 있다. predicate으로 in과 for-in-loop에서 사용이 있다.\n내가 보기에 \u0026lsquo;in\u0026rsquo;은 rvalue와 lvaue를 취하는 \u0026lsquo;=\u0026lsquo;과 비슷하다. 즉 rvalue와 lvalue를 보고 동작이 결정된다.\n\u0026lsquo;in\u0026rsquo;의 rvalue는 iterable객체가 와야 한다. lvaue는 name이 오거나,값이 와야 한다.\nrvalue test\nfruits = 3 print(\u0026#34;banana\u0026#34; in fruits) in 뒤에 나오는 rvalue는 iterable 객체여야 한다. 아니면, error. test2\nrvalue의 처리 : in 뒤에 객체가 iterable하다면, __self__로 객체를 얻어와서 __next__를 호출하면 값이 return된다. in은 lvalue도 처리한다. 만일 lvalue를 처리하지 않고 rvalue만 처리한다면? 즉 rvalue의 값만 return한다면? # fruits = [\u0026#34;apple\u0026#34;,\u0026#34;orange\u0026#34;] print(\u0026#34;banana\u0026#34; \u0026#34;apple\u0026#34;) 위의 예처럼 rvalue만 처리하는건 위의 경우 처럼, 값만 2개 있는 꼴이다. 즉 lvalue를 처리해야 한다. lvalue가 값인경우 비교해서 true 면 종료된다. 만일 false면 계속 next를 호출해서 비교한다. 즉 rvalue로 return한값과 lvalue값에 is함수를 적용하는 것과 같다. fruits = [\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;] print( \u0026#34;apple\u0026#34; in fruits ) for-in-loop 위에서 봤듯이 in keyword는 rvalue에 해당하는 값을 return후 lvalue와 true가 나올때까지 비교한다. 만일 lvalue가 name이고 for가 있다면, 값을 비교하지 않고 binding을 한다. fruits = [\u0026#34;banana\u0026#34;,\u0026#34;apple\u0026#34;,\u0026#34;orange\u0026#34;] for i in fruits: print(i) range range개념\nrange는 generator다. 즉 함수내부에 yield라는 keyword가 있다. 그리고 function객체다. range라는 generator를 설명하기 앞서 iterator에 대한 간략한 소개가 필요하다. iterator는 객체에 __iter__와 __next__가 구현되어 있고, 내부적으로 cur이란 변수를 갖는다. in keyword에 의해 next함수고 호출되고 next함수는 cur이 가리키는 값을 return한다. 그러면, for는 return한 값을 binding한다. generator도 마찬가지다. in 에 의해서 yield까지 수행하고 값을 return한다. 다음 수행될 주소를 cur에 가지고 있다. iterator와 generator 모두 start,cur,end라는 변수를 가지고 있다는 게 공통점이다. range 사용법\nrange(5) start:0, end:5로 counting된다. range(1,3) start:1, end:3으로 counting된다. iterator와 generator객체의 출력 iterator객체와 generator객체를 출력하기위해서 print문을 사용할 경우, 객체임을 출력하지 , 객체가 가진 내용을 출력하지 않는다. gen1 = (i *2 for i in range(10)) print(gen1) 이럴 때는 list객체로 만들면 출력이 된다. gen1 = (i *2 for i in range(10)) print(list(gen1)) Comprehension과 Generator list나 dictionary같은 것을 만드는 이유는 data의 저장과 사용하기 위해 만든다. 거기에 들어가는 data들은 직접 작성될 수도 있고, code로 만들 수도 있으며, 외부로 부터 가져올 수도 있다(network, file, etc). 여기서는 외부 data는 신경쓰지 않기로 한다.\n우리가 직접 list 데이터를 쓰는건 작은 데이터일 경우, 문제가 되지 않는다. 큰 data일 경우 for-loop을 이용해서 data를 생성해서 list에 저장하는 방식을 쓰거나, 방식은 같지만 list comprehension으로 많은 data를 만들수가 있다. 하지만 for-loop, list-comprehension은 모두 유한의 자료를 대상으로 한다는 것이다. 무한한 자료의 처리는 할수 없다. 무한한 자료의 처리는 실시간 data를 필요하는 경우에는, generator가 필요하다. Generator를 사용하는 이유는 무한의 data를 만들어 낼 수 있다는 데 있다. 예를들어서 경비행기 simulator를 만든다고 하자. 우리는 매번, 온도 습도 고도와 같은 정보를 실시간으로 입력받아야 한다. simulator에서 그런 data가 미리 준비되어 있다고 할지라도, 그 data들은 유한하다. 유한한 data를 나타내기 위해서 list를 직접작성하던, 직접작성하는게 노가다라서 list comprehension을 사용하던 유한의 data밖에 만들어낼 뿐이다. 언젠간 끝이 있다. 실제와 같은 simulator에서는 유한하지 않는 무한한 data가 제공되어야 한다. 그것은 generator로 만들어질 수 밖에 없다. 하지만, 우리가 지금 말할려는 것은 compreshension이다. list를 직접사용하는게 아닌 코드를 이용해서 긴 list를 만드는 방법에 대한 얘기다. 아래처럼 수동으로 작성하는게 아닌 code를 사용하는 방식이다.\n[1,1,2,3,5.....] 그런데, code를 사용해서 list data를 만들때, 가장 먼저 떠오르는 것은 for-loop으로 만들 것이다.\nresult = [] for i in range(10): result.append(i * 2) print(result) 그런데, for-loop으로 data를 만드는 방식 말고, 더 간단한 문법으로 만드는 방식을 제공한다. 그것을 comprehension이다. 위의 for-loop를 comprehension으로 표현하면 아래와 같다. for-loop와 달리, list안에다 직접 데이터를 쓴다는 느낌이다.\nresult = [i * 2 for i in range(10)] print(result) 그래서, 문법도 보면 [ ]가 나오고, 꺽쇠 안에 처음에 표현될 data의 형태가 나온다. 아래와 같은 방식이다.\n우리가 원하는 data가 어떤형태인가? list면 , dictionary면 { } 원소는 어떤 형태인가? 정수이고 짝수다. 2*i 형태 원소는 몇개인가? 10개, range를 사용하자. for i in range(10) 최종적으로 [ 2*i for i in range(10)] comprehension examples Comprehension example 1\n10개의 data를 갖는 dictionary를 만들고 싶다. 아래와 같은 형태로.\n{\u0026lsquo;0\u0026rsquo;: 0, \u0026lsquo;1\u0026rsquo;: 1, \u0026lsquo;2\u0026rsquo;: 2, \u0026lsquo;3\u0026rsquo;: 3, \u0026lsquo;4\u0026rsquo;: 4, \u0026lsquo;5\u0026rsquo;: 5, \u0026lsquo;6\u0026rsquo;: 6, \u0026lsquo;7\u0026rsquo;: 7, \u0026lsquo;8\u0026rsquo;: 8, \u0026lsquo;9\u0026rsquo;: 9}\n10개의 data가 필요하니까 range(10)을 사용하고, for in을 사용해서 index를 가져와서 dictionary에 하나씩 하나씩 쓴다.\n이런 dictionary를 하나하나 쓰긴 그렇다. 이 경우 dictionary comprehension을 사용한다.\nexample\nresult = {} for i in range(10): result[str(i)] = i print(result) dictionary에 이런 data를 만들기 위해서, dictionary comprehension을 사용하자.\nexample\nresult = {str(i):i for i in range(10)} 위에서 보다시피, dictionary에 들어갈 형태는 \u0026lsquo;index\u0026rsquo;:index 형태다. 즉 key:value의 형태다. dictionary안에서 str(i):i로 만들고, 루프-for i in range(10)를 사용하면 된다. Comprehension example 2\n이번에 만들 list는 10개의 data를 갖는데, 10이하의 정수가 random하게 배열된 list다.\n이런 걸 만들기 위해서, 어떻게 할 수 있을까? 아래에서는 set객체를 만들고, set객체에 add로 집어넣었다. 그런데 결과값은 random하다. 이건 좀 신기하다.\nexample\nresult = set() for i in range(10): result.add(str(i)) print(result) 이제 dictionary comprehension으로 이런 dictionary를 만들려고 한다. 어떻게 해야 할까?\nresult = {str(i) for i in range(10)} print(result) 여기서도 만들려고 하는 list item의 형태를 본다. string타입의 item이다. 그런데 {}이기 때문에 dictionary아니면 set이다. item이 key:value형태가 아니다. 따라서, 이것은 set이라는 것을 알수 있다. for i in range(10) 이렇게 하면 set comprehension이 만들어졌다. comprehension example 3\nexample1\ncomprehension의 구조를 보면, for문 다음에 if문이 나올 수 있다. for문 다음에 for문이 나올 수도 있다. 해석은 순차적이다. 아래를 보면, for에서 binding된 i를 if를 거쳐서 item으로 만든다. evens = [i for i in range(100) if i % 2 == 0] print(evens) [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98] 50개의 정수를 원소로 갖는 list다. 각각의 원소는 2의 배수 형태다. 어떻게 만들 것인가? range(n)에 대해서 정확히 알아야할 듯 하다. range는 개수를 입력으로 받는다. 시작은 0부터 한다. 아래와 같이 만들면 된다. 위에 처럼 복잡하게 만들 필요는 없는 듯 하다. 위에서 눈여겨 봐야 할 것은 for i in range(100) 다음의 if문이 나온다는 것이다. result = [ 2* i for i in range(50)] print(result) example2\n이것은 for문 다음에 for문이 나오는 형태다. 이중 for문으로 보면 된다. 3중 for문, 4중 for문도 만들 수가 있다. result = [(i,j) for i in range(5) for j in range(i)] print(result) 10개의 tuple을 원소를 갖는 list다. tuple의 첫번째 원소는 규칙을 가지고 있다. 반면에 두번째 원소는 규칙을 모르겠다. test result = [(i,j) for i in range(1) for j in range(i)] print(result) example3\n아래 구조는 다차원 배열을 만드는 것이라고 한다. 동작 원리를 보면, 가장 밖에 있는 for i in range(5)가 돌면서 내부의 list를 만들게 된다. 내부의 for-loop은 []가 없다면 내부 for-loop 다음에 옆에 for-loop이 실행 되었을것이다. 하지만 [ ]때문에 외부 for문에 따라 내부 for문이 도는 형태가 된 것이다. 결과적으로 정수 값을 갖는 2차원 table을 만든다. identity matrix를 만든다고 한다. eye = [[int(i ==j) for j in range(6)] for i in range(5)] print(eye) eye = [[int(i ==j)] for j in range(6) for i in range(5)] print(eye) Generator Generator의 개념 range가 가장 대표적인 예, range는 숫자를 생성하고, 요청이 있으면 숫자를 return하고 새로운 수를 만든다. list를 만들지 않는다. 따라서 메모리 효율적이다. function에 yield가 있다면, generator이다. generator를 이해하기 위해선, iterator와 for in loop의 동작 방식을 살펴볼 필요가 있다. for in loop와 iterator for in loop에 대해서 알 필요가 있다. for in loop를 알려면 iterator에 대한 이해가 필요하다. for in loop의 구조는 다음과 같다. for index in iterator iterator는 객체다. python의 모든것이 객체라서 iterator가 객체라고 말하는것은 좀 불 성실해 보인다. 좀 더 자세하게 말하자면 __iter__라는 dunder method와 __next__를 구현하고 있는 객체라고 말하는게 좀 더 정확할 것이다. list, tuple, dictionary, set과 같은 collection type의 class는 2개의 method가 구현되어 있다. 이 메소드가 어떤 역할을 하는지 살펴보자. for i in iterator라는 구문이 있다고 하자. python interpreter는 iterator의 _iter__라는 메소드를 호출해서 self객체를 얻는다. 그다음 self._next()를 통해서 iterator가 가진 원소를 꺼내온다. 그리고 i와 binding을 한다. loop를 돈 다음에, iterator의 __next__메소드를 호출해서 다음 원소의 값을 가져온다. 단지 __next__메소드를 호출한다고 다음값을 가져오는가? 그렇게 말하면 너무 무성의하다. iterator객체들은 내부적으로 cur이라는 변수를 유지하고 있다. 일종의 pointer인데, 현재 참조하는 data를 가리킨다. __next__를 호출할 때마다 다음 데이터를 return하는 구조다. stop이라는 마지막을 나타내는 pointer를 next가 가리키면 exception이 나고 for-loop은 끝나게 된다. Generator에 대한 생각. for in loop와 iterator에 대한 개념이 생겼으니, Generator에 대해서 알아보자. Generator는 yield가 있는 함수라고 한다. yield가 뭔지도 알아야 한다. 여튼\u0026hellip; iterator가 있어야 할 곳에 Generator가 있을 수 있다고 한다. Generator에는 iter,next같은 함수가 구현되어 있지 않다. iterator라고 부르는 객체들은 data를 가지고 있는 collection객체 였다면, Generator는 function객체다. Generator는 객체가 가진 data를 return하는게 아닌 말그대로 data를 만들어서 return한다. 그렇게 하기 위해선 명령어의 주소를 가지고 있고, 다음 명령어를 실행하는 방식이다. iterator와 비교하면, iterator는 cur이라는 pointer로 다음에 return할 data를 가리킨다면, Generator는 다음에 수행할 statement를 yield로 가리키고 있다고 보면 된다. for loop의 동작방식은 __iter__로 객체를 얻어와서 self.__next__를 호출한다. 이것이 generator에게 다르게 적용되진 않는다. 즉, __iter__를 호출하면 function객체가 return되고, __next__메소드가 호출되면, yield가 가진 다음 명령어부터 실행된다. 계속 수행되다가 yield를 만나면 어떤 data를 return할 것이다. 그러면 index와 binding해서 for-loop의 body를 수행한다. example def my_range2(): yield 1 yield 2 yield 3 for i in my_range2(): print(i) def my_range(stop): number = 0 while number \u0026lt; stop: yield number number += 1 for i in my_range(5): print(i) Generator는 lisp에서도 macro로 존재하는 기능이다. 동작과정을 살펴 보면, 제일 먼저, python interpreter는 my_range라는 function 객체를 만든다. for-in-loop에서 my_range라는 객체를 __iter__로 얻고, 5를 stack에 저장후, __next__를 실행시킨다. generator(function object)의 __next__는 수행할 명령어의 주소를 cur에 가지고 있는데, cur은 __init__을 가리키고 있다. 처음 호출이기 때문이다. __init__에선, function객체는 argument binding을 한다. stack에서 5라는 값을 my_range객체의 argument stop과 binding한다. stop은 일종의 멤버변수다.따라서 함수 호출 후 body를 수행할 때 stop이 binding된다. 쭈욱 body를 실행한다. while에 진입한 이후에 yield를 만난다. yield는 다음 명령어의 주소를 cur과 같은 변수에 저장한다. 다음 __next__호출시 cur에 저장된 명령어를 수행하기 때문이다. 그리고 yield는 값을 return한다. 주의해야 할것은 yield는 값을 return할 뿐이지, 함수의 종료를 뜻하지는 않는다. 만일 return문이 있다면, return문을 만나면 함수는 종료를 하게 된다. 특이한 generator even_generator = (i * 2 for i in range(10)) for i in even_generator: print(i) even_generator는 언뜻보기에 tuple comprehension처럼 보인다. tuple안에 comprehension이 들어가 있기 때문이다. 그러나 tuple comprehension은 존재하지 않는다. dictionary와 set, list는 comprehension이 있어도, tuple comprehension은 존재 하지 않는다. 저것은 comprehension을 generator로 만든것으로 보면 된다. Generator이기 때문에 for-loop으로 출력해보면 위와 같은 결과가 나온다. 근데, tuple comprehension, 즉 tuple형태로 된 generator에서 ()를 제거해도 문제가 없다고 한다. tuple은 ()가 생략 가능하기 때문이다. Built-in Functions sum([iterable]) iterable의 합을 구한다. generator도 iterator로 간주한다. example print(sum([1,2,3,4,5])) print(sum(i for i in range(1,101) if i%2 == 0)) any([iterable]), all([iterable]) any는 하나라도 참이면 참, all은 모두가 true여야 True다. example any_value = any([False,True,False]) all_value = all([False,True,False]) print(any_value,all_value) max([iterable], min([iterable]) max는 주어진 iterable에서 최대값을 return한다. min은 주어진 iterable에서 최소값을 return한다. iterable대신 generator도 쓸수 있는가? 유한 generator는 된다. 무한 generator는 가능한가? print(max([7,6,-2,5,8])) print(min([7,6,-2,5,8])) print(max((i *2 for i in range(10)))) zip([iterable],[iterable],\u0026hellip;) zip은 seq를 인자로 받아서 sequence를 column별로 묶는다고 보면된다.\nexample\nseq1 = [1,2,3,4] seq2 = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;] seq3 = [True,False,True] print(list(zip(seq1,seq2,seq3))) 각각의 sequence의 첫번째 원소를 묶어서 tuple을 만든다. 두번째 원소들을 모아서 두번째 요소를 만든다. 두번 째 요소도 tuple형태다. 3개씩 3개가 만들어진다. 그런데 seq1의 4는 짝이 없다. 이런 경우, 그냥 버린다. zip 사용법 예제\nexample\narray = [[1,2,3],[4,5,6],[7,8,9]] for row in array: print(row) for col in zip(*array): print(col) row와 col출력을 하는 예제다. row는 이해가 되지만, column이 이해가 안간다.\ncolumn을 나타내기 위해서 생각나는 방식은 아래와 같은 방식 일 것이다.\nfor col in zip(array[0],array[1],array[2]): print(col) 그런데 이것은 [[1,2,3],[4,5,6],[7,8,9]]라는 list를 unpacking해서 array[0],array[1],array[2]로 만든것과 같다. 이것을 다시 packing하면,*array로 나타낼 수 있다.\nzip함수의 흥미로운 부분이 있다.\nseq2 = zip(*seq1)이라고 하면, seq1 = zip(*seq2)와 같다. 근데 윗 부분은 좀더 예제라던가 동작방식을 살펴봐야 할 듯 하다.\nEnumerate iterable을 for문으로 돌릴때, index가 필요한 경우가 있을 수 있다. 어떤 list의 값과 index를 사용해야 한다면, 다음과 같이 코드를 짤 것이다.\nseq = [\u0026#34;this\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;sentence\u0026#34;] for i in range(len(seq)): print(i, seq[i]) enumerate를 이용한다면 더 간단하게 짤 수 있다.\nexample1\nseq = [\u0026#34;this\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;sentence\u0026#34;] for i, word in enumerate(seq): print(i, word) example2\nseq1 = [\u0026#34;this\u0026#34;, \u0026#34;sentence\u0026#34;] seq2 = [True, False] for i, (a,b) in enumerate(zip(seq1,seq2)): print(i, a,b) generator객체나 enumerate객체는 출력되지 않는다. 출력을 하기 위해선 list를 사용한다.\nprint(list(enumerate([\u0026#39;This\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;sentence\u0026#39;]))) lambda function lambda function은 이름이 없는 함수\nexample\ndef add(a,b): return a+b 이것을 lambda expression으로 바꾸면, add = lambda a,b: a+b lambda [param1],[param2]\u0026hellip;[expression]형태로 만든다.\nmap ([function],[iterable]) 각 요소에 function함수를 적용하여 반환 seq = [6,-2,8,4,-5] print(list(map(lambda x: x* 2, seq))) filter ([function], [iterable]) 각 요소에 predicate을 적용하여 참이 나오는것만 반환 seq = [6,-2,8,4,-5] print(list(filter(lambda x: x \u0026gt; 2, seq))) ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture6-pythonic-programming\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture7_object-oriented-programming\/": {
        "title": "lecture7_Object-Oriented-Programming",
        "tags": [],
        "content": "OOP programming class 기본 class 선언 예시 example\nclass Courier(object): # (object)는 생략가능 NATIONALITY = \u0026#39;KOR\u0026#39; # 클래스 속성 def __init__(self, name: str, address: str): # 생성자 self.name = name # attribute 초기화 self.address = address elf.parcels = [] def assign(self, parcel: str) -\u0026gt; None: self.parcels.append(parcel) def deliver(self) -\u0026gt; None: for parcel in self.parcels: print(parcel, \u0026#34;배달중\u0026#34;) class 특징들 class이름은 대문자. 상속은()를 사용한다. class attribute는 전역적으로 선언 class의 member attribtue는 init에서 self로 초기화. class 생성 example class Courier(object): # (object)는 생략가능 NATIONALITY = \u0026#39;KOR\u0026#39; # 클래스 속성 def __init__(self, name: str, address: str): # 생성자 self.name = name # attribute 초기화 self.address = address self.parcels = [] def assign(self, parcel: str) -\u0026gt; None: self.parcels.append(parcel) def deliver(self) -\u0026gt; None: for parcel in self.parcels: print(parcel, \u0026#34;배달중\u0026#34;) courier1 = Courier(\u0026#34;김기사\u0026#34;,\u0026#34;경기도 성남시 정자동\u0026#34;) print(courier1.name, \u0026#34;-\u0026#34;, courier1.address, \u0026#34;근무중\u0026#34;) courier1.assign(\u0026#34;편지\u0026#34;) courier1.deliver() class declaration class Courier(Object): class 이름은 CamelCase가 관습적으로 사용된다. 부모 class가 지정되지 않으면, object가 자동 상속된다. 그런데 object는 class가 아니라 객체라는것도 유의해야 한다. 모든 class는 object객체를 상속한다. Object class가 아니다. object객체에 있는 method를 built-in function이라고 부른다. class Attribute class Courier(Object): Nationality = \u0026#39;KOR\u0026#39; 속성은 2가지가 종류가 있다. class attribute와 member attribute. 둘다 객체가 갖는 속성이다. 하지만 여러 모로 다르다.\n우선 의미가 다르다. 붕어빵틀로 붕어빵을 찍어낼때, 붕어빵의 내용물은 붕어빵 객체마다 다를수 있다. 하지만, 붕어빵의 크기에 대한 속성은 모든 붕어빵 객체가 동일한 값을 갖는다. 생성하는 순서와 방식이 다르다. class를 python interpreter가 읽으면서 class객체를 만든다. 그때, class 객체의 attribute는 객체의 한 요소로 값이 만들어진다. 반면에 member attribute는 객체가 생성될때 init이라는 생성자에서 local하게 생성된다. python interpreter가 class로 쓰여진 부분을 읽어서 만들어지는 class객체에는 class변수에 해당하는 pointer와 function들에 대한 pointer들이 있을 뿐이다. python interpreter가 객체선언을 읽으면 그때 객체를 만들게 되는데, 그때는 init이라는 생성자를 호출 시켜서 member attribute를 생성하게 된다. 접근하는 방식이 다르다. class attribute는 class 자체 객체에 포함된 속성이라서 아래와 같이 사용한다. 반면에 member attribute는 객체를 만든 후에야 생성자에 의해 만들어진다. 그리고 그 이후에 객체.attribute로 사용될 수 있다. print Courier.Nationality class의 function들. class 내부에 있는 함수들이 있다. 이 함수들은 method라고 부른다. 이 method는 내부에 self라는 argument들을 가지고 있다. 이 self라는것은 객체를 의미한다. 예를들어서, python interpreter가 아래에서 보듯이 class Holy를 읽게 되면, Holy라는 이름의 class객체를 생성하고 method를 등록한다. Holy class 자체에서 method를 호출하려면, 첫번째 인자가 self라는 객체를 요구받는다. class자체객체를 전달할 순 없다. 즉 method를 사용하려면, 아래처럼 Holy class로부터 tempholy같은 객체를 만든다. 만들어진 객체에는 method들이 등록되어 있지는 않다. 객체에서 method를 호출하는것은 class객체에 등록된 method를 호출하는것이고, 그래서 첫번째 인자는 self로 되어 있는 것이다. self에는 tempholy가 인자로 들어가서 수행하는 것이다. tempholy객체에는 자신의 class에 대한 포인터가 등록되어 있기 때문에 class에 정의된 method들을 호출 할 수 있다. 다시 말하면, class는 class멤버변수와 method의 껍데기만 가진채로 생성이 되고, 객체가 만들어지면, 그 객체에는 class pointer가 있기 때문에, class의 class attribute와 method를 수행할 수 있는 것이다. class의 method를 수행하는 방식은 2가지가 있다. 하나는 class자체 객체에서 호출하는 것이다.\nclass Holy(object): class_var = \u0026#34;temp\u0026#34; def __init__(self, name: str): self.name = name print(\u0026#34;constructor\u0026#34;) def assign(self, newname:str) -\u0026gt; None: self.name = newname print(self.name,\u0026#34;assign method\u0026#34;) print(Holy.class_var) tempholy = Holy(\u0026#34;holy\u0026#34;) print(tempholy.assign(\u0026#34;park\u0026#34;)) print(Holy.assign(tempholy,\u0026#34;lee\u0026#34;)) 생성자(객체 속성) 객체를 생성할때 init()가 호출된다. init()는 class에 정의되어 있다. python에서 객체를 생성할 때는 무조건 =(asignment)를 사용한다. 이때 생성자의 모양에 따라 argument를 넣어 주어 생성한다.\ncourier1 = Courier(\u0026#34;김기사\u0026#34;, \u0026#34;경기도 성남시\u0026#34;) = 은 rvalue와 lvalue를 입력으로 받는다. rvalue의 type인 Courier가 courier1 객체에 들어가고, Courier의 method인 init()가 호출된다. 인자로는 \u0026ldquo;김기사\u0026rdquo;,\u0026ldquo;성남시\u0026quot;가 stack에 저장되고, Courier의 init()의 argument들은 function의 local변수이기 때문에 stack의 값으로 초기화된다. __init__함수에 보면, self는 courier1이 전달 되기 때문에, init()에 보면, self.name과 같은 식으로 객체를 만드는게 보인다. 이것은 courier1이라는 객체내에서 value값으로 만들어 지는 것이다. 따라서 courier1에서는 접근할수 있다. 그런데, 특이한게 있다. value는 생성자에 있는 member 변수가 아니다. java에서는 member변수가 아니라면, 객체에서 아래처럼 마음대로 member객체를 만들수가 없다. 그런데 python은 객체에서 member변수? member객체를 생성해서 사용할 수 있다.\ncourier1.value = 10 magic method: 생성자 initializer\ndunder method를 magic method라고 부르기도 한다. 즉 __로 시작하고 __로 끝나는 method를 뜻한다. init method도 dunder method다. 위에서도 이 init method에 대한 설명을 했는데, init method는 객체가 생성될때 호출된다. 예를 들면,\ncourier1 = Courier(\u0026#34;김기사\u0026#34;, \u0026#34;경기도 성남시\u0026#34;) 여기서 Courier class객체는 이미 만들어져 있다. class로 정의하면 생성이 되기 때문이다. 즉 이미 만들어진 type객체인 Courier의 init()를 호출하는 것으로 보면 된다. courier1은 인자로 전달되어 self로 assign되게 된다.\nmagic method: 소멸자\nclass Courier(object): def __del__(self): self.parcels.clear() 객체가 소멸할 때 호출된다고 한다. python에선 GC(Garbage Collection)을 가지고 있는데, 주기적으로 참조 되지 않는 객체를 삭제한다고 한다.\n객체지향의 3요소와 특성들 상속 inheritance class Courier(object): object는 부모 class, Courier는 자식 class가 된다.\n다형성 polymorphism 같은 이름의 method를 다르게 작성. 다중 상속이 가능하다고 한다. 그리고 super를 통해서 상위 class에 대한 접근이 가능하다. 이것이 polymorphism과 큰 관련이 있는지는 모르겠다. super를 사용하는 예제를 보여준다.\nclass Courier: def __init__(self, name:str): print(self) self.name = name print(\u0026#34;courier 생성자\u0026#34;) self.address = \u0026#34;부산\u0026#34; self.parcels = [] def assign(self, parcel: str) -\u0026gt; None: self.parcels.append(parcel) def deliver(self) -\u0026gt; None: for parcel in self.parcels: print(parcel, \u0026#34;super 배달중 -\u0026#34;, self.address) class JejuCourier(Courier): def __init__(self, name: str, ticket: int): print(\u0026#34;생성자juju\u0026#34;) # super().__init__(name) super(name) self.ticket = ticket def deliver(self) -\u0026gt; None: print(self.ticket, \u0026#34;티켓으로 제주도 이동\u0026#34;) super().deliver() # courier = JejuCourier(\u0026#34;김기사\u0026#34;, 15) JejuCourier(\u0026#34;김기사\u0026#34;, 15) # courier.assign(\u0026#34;편지\u0026#34;) # courier.deliver() # super(JejuCourier, courier).deliver() python은 모든 게 객체이기 때문에, class도 객체다. 그리고, class로부터 만들어지는 instance도 객체다. 각각의 객체엔 type(class)이란 항목이 있다. type(class)이란 항목엔 instance를 만든 class 객체를 가리키고 있다. 예를 들어서, A라는 class가 있고, a라는 instance가 있다면, A class도 객체가 있고, a도 객체 인 것이다. 객체인 A class와 a에는 객체이기 때문에 type(class)이란 항목이 존재한다. a객체의 type(class)에는 A class객체를 가리킨다. 그러면 A class객체의 type(class)이란 항목은 무엇을 가리키고 있을까? A class 그자체도 객체이기 때문에, class의 부모 class를 type(class)으로 가리키고 있을 것이다.\n위에서 type에 대해 설명한 것은 super()를 설명하기 위함이다. 우선 super는 내부적으로는 class로 정의되어 있다. init()만 가지고 있는 class다. super()는 type의 class의 init()를 호출하여 객체를 만든다. 소스를 보면서 설명해보자.\npython interpreter는 Courier, JejuCourier라는 class 정의를 보고, class 객체를 만든다. class 객체엔 name이란 항목, type이란 항목, value라는 항목이 설정된다. name에는 class의 이름이 들어가고, type에는 Courier의 경우는 object, JejuCourier에는 Courier가 들어간다. value에는 body부분이 들어가게 된다. class객체를 만들때, body부분은 실행하지 않는다. 즉 body에선 수많은 객체 생성을 할텐데, class객체는 body 전체만 가리키는 포인터만 가질뿐이다. class객체로 부터 instance객체를 만들고 instance 객체에서 body부분을 실행할 때 처리되는 것이다.\npython interpreter는 아래를 읽고 실행한다.\ncourier = JejuCourier(\u0026#34;김기사\u0026#34;, 15) = 은 객체를 만드는 명령어다. 객체를 만들고, name은 courier로 지정하고. type은 JejuCourier로 한느 객체를 만든다. 그리고 JejuCourier라는 class객체의 __init__함수를 호출한다. 인자는 지금 만든 courier객체, \u0026ldquo;김기사\u0026rdquo;, 15값을 stack 넣어 전달한다. courier라는 객체는 단순하다. 왜냐면, courier객체는 JejuCourier를 type으로 갖기 때문에 JejuCourier의 method를 그대로 상속해서 사용한다. type이라는 것은 부모 class로 보면 되기 때문이다.\n[JejuCourier의 __init__함수]\ndef __init__(self, name: str, ticket: int): print(\u0026#34;생성자juju\u0026#34;) super() super().__init__(name) self.ticket = ticket print문을 출력하고, super()라는 부분이 나온다. self는 courier라는 객체를 나타낸다면, super()는 현재 수행되는 class객체인 JejuCourier객체의 type, 즉 부모 class를 생성하는 것이다. 부모 class의 __init__을 호출해서 부모의 class의 instance객체를 만든다. 물론 그전에 부모 class객체는 만들어져 있는 상황이다. 예를 들어, JejuCourier()를 호출한다면, JejuCourier class객체는 이미 만들어져 있고, JejuCourier class객체의 init()를 호출해서 instance객체를 name없이 만드는것과 같다. 즉 저기서 super()는 부모인 Courier의 _init__메소드를 호출해서 instance객체를 만드는 것이다. 그런데 super()를 실행하면, Courier의 init()이 일치하는게 없다. Courier의 init(self, name:str)의 형태이기 때문에, 부모인 object의 init()가 호출될 것이다. Courier의 init(self, name :str)을 호출하기 위해서는 명시적으로 호출해야 한다. 즉, super()._init(name)으로 호출해야 한다. 그런데 여기서 질문, Courier의 init메소드의 인자 self는 무엇으로 초기화 되는가? 그리고 만일 super(name)으로 Courier의 _init__을 호출 할 수 있는가? 어떻게 self가 초기화 되는가? 자식객체가 type의 method를 호출할때는 자기자신이 인자로 전달된다. 그러면 super(name)도, super()._init(name)이 수행되듯이 수행되어야 할 것이다. 그런데 수행되지 않는다. 이것은 정말 이상한데, super라는게 부모 class를 가리키고, super()를 하면 instance를 만들고 인자 없는 init()을 호출하는 과정이다. super(name)하면, 부모 class에대한 instance를 만들고, init(self, name:str)을 호출해야 맞는데 호출 되지 않는다. super()는 Courier()를 실행하고, 그다음 init()를 호출하는건, JejuCourier()를 실행했을 때, JejuCourier instance를 만든후 __init__메소드를 수행하는것과 동일한데, 이상하게 안된다.\n그리고, 맨 마지막의 실행문을 보자.\nsuper(JejuCourier, courier).deliver() 이것은 어떻게 해석 할 것인가? 이전의 super()는 특정 객체의 method에 있었다. 즉 특정 객체의 method가 호출되어 실행되기 때문에 그 context에서는 super가 가르키는게 특정 class객체임을 알 수 있었다. 하지만, 여기서 super는 어떤 class객체를 가리키는가? 이게 module하고 관련있는것 같다. 즉 class내가 아닌 밖에서 사용되는 function도 module하고 어떤 관계가 있어 보인다.여기서는 별 다른 설명이 없다.\noverloading과 overriding overloading과 overriding은 모두 부모와 같은 이름의 함수를 뜻한다. overloading은 argument가 다른 함수다. 즉 다른 함수라고 봐도 된다. 하지만, overriding은 동일한 함수를 재정의 하는것이다. 단어만 보면 overwrite하고 비슷하다. 위 코드에서 보면, deliver는 overriding한것이고 __init__은 overloading한 함수다.\nstatic \u0026amp; class method 우선 예제를 보자.\nclass Number: Constant = 10 @staticmethod def static_factory(): obj = Number() obj.value = Number.Constant return obj @classmethod def class_factory(cls): obj = cls() obj.value = cls.Constant return obj number_static = Number.static_factory() number_class = Number.class_factory() print(number_static.value, number_class.value) staticmethod와 classmethod는 이름만 봐선, 우선 class method는 class객체에 포함되는 method고, static method는 일종의 전역함수로 봐도 되지 않을까? 일반 method는 self라는 argument가 있었다. 하지만, class method와 static method에는 self가 있을 필요가 없다.\n사용방법을 보면, 둘다 다음과 같이 호출한다.\nnumber_static = Number.static_factory() number_class = Number.class_factory() static method는 선언만 class안에 선언되었을 뿐이지, 밖에 선언되어도 상관없을 method다. 하지만, python에선 모든것은 객체고 method이기 때문에 안에서 선언되고 접근만 가능할 뿐이여서 class에 포함된 method라고 보기 힘들다. 여튼 코드 해석을 해보자.\npython interpreter는 Number라는 class를 읽고 Number class객체를 만든다. 그리고 다음 code를 실행한다.\nnumber_static = Number.static_factory() = 은 객체를 만든다. number_static이란 name을 갖고, Number.static_factory()함수를 호출 결과의 type과 value를 가질 것이다. static_factory()는 외부 함수로 봐도 된다. 여튼 여기서는 Number의 instance를 만들어서, return한다. 따라서 Number라는 type이 지정되는 객체가 만들어진다.\n두번 째로, 다음 코드를 보자.\nnumber_class = Number.class_factory() 여기서는 Number의 instance를 만들지는 않는다. 제일 처음에 python interpreter가 Number라는 class객체를 만들었기 때문에, Number class객체의 class method인 class_factory()를 접근한다.\n@classmethod def class_factory(cls): obj = cls() obj.value = cls.Constant return obj 여기서 눈여겨 봐야 할것은 cls이다. 우리가 객체를 생성해서 객체에서 method를 호출할 때는 객체.method() 형태로 method를 호출한다. 이 때, method는 class객체에 있기 때문에, 객체가 인자로 넘어가서 실행된다. 근데 여기서는 class method는 class에 정의되어 있다. 그리고 class객체 자기자신이 인자로 넘어간다는게 좀 다르다. cls는 Number class객체의 이름이 넘어간다. 그리고 그 이름으로 Number instance를 만들어서 return하는 구조다.\n위의 두 함수 모두, class의 instance를 만들고, instance의 method를 호출하는 방식과는 다르다. instance는 내부적으로 만들어져 return 하는 형태다. factory design pattern을 사용하기 때문이다.\n또 한가지 static method와 class method 모두 decoration을 사용하고 class객체에서 호출 가능하다는 공통점이 있지만, 둘 사이의 커다란 차이점은, class method는 상속이 되지만, static method는 상속이 되지 않는다는 것이다.\nAbstraction (visiblity) Abstraction으로 알고 있던 용어를 여기서는 visiblity라고 부른다. 다른 class에서 객체 내부 요소를 감추는 캡슐화 작업이라고 한다. java에서 private이나 protected로 설정했던거라고 보면 된다. 즉 내가 김기사라는 instance를 만들었을때, instance라고 해서 자신의 member attribute를 다 접근할 수 없게 만들었다. class에서 정의된 방식으로만 접근할 수 있게 할 수 있는데, 예를들면, set과 get이라는 method에서만 직접적 처리가 가능하게 했다. instance는 이 method를 호출해서 해당 변수에 접근이 가능하다. 이것을 capsule화라고 한다. java에서는 private과 protected라는 keyword로 제공했지만, python에서는 private이나 protected라는 keyword는 없다고 한다. 다만, __로 시작하면 private이라고 하고, _라고 하면 protected라고 일종의 규약처럼 사용되는데, 문법적 요소는 없다고 한다.\n예를 들어 보자.\nclass TestClass(object): def __init__(self): self.attr = 1 self._attr = 2 self.__attr =3 instance = TestClass() print(dir(instance)) print(instance.attr) print(instance._attr) # print(instance.__attr) dir은 instance가 가진 모든 attribute를 보여준다고 한다. 여기보면, _attr과 attr은 보이지만, __attr은 보이지 않는다. 강사는 mangling이 적용되었다고 말한다. mangling은 __가 앞에 붙어 있으면 이름이 _TestClass__attr로 변경된다. mangling이 되면, 객체에서 직접적으로 접근할 수 없게 된다. 즉, private한 효과가 있다. 위에서 직접 접근을 시도했지만, 에러가 발생되는 것을 볼 수 있다. 굳이 접근할려고 하면, instance._TestClass__attr로 접근할 수 있다. mangling된 이름으로 접근하면 된다. protected는 별다른 처리를 하진 않는다. 여기서 __로 시작하는것을 dunder method나 magic method로 보면 안된다. dunder method는 __로 시작하고 __로 끝날때만을 의미한다. __는 attribute와 function에 적용되고 mangling하는 특징을 갖는다.\nabstraction (visibility2) java같은 oop언어에서는 private을 사용하고, setter, getter 메소드를 정의해서 사용하는 경우가 많다. python에서는 명시적인 private과 protected keyword를 제공하지 않는다고 했다. 어떻게 보면, python에서는 기존의 oop언어가 member variable을 private으로 감추고, setter와 getter를 사용하는것이 쓸모 없다고 생각했을 수도 있다. 그래서 그냥 member variable에 값을 넣고 꺼내면 되지 않냐? 이런식의 주장을 하는 것 같기도 한다. 그렇지만, 직접적으로 그렇게 사용하진 않는다. python도 java처럼 setter와 getter를 사용한다. 하지만, 마치 직접 변수를 접근하는 것처럼 눈속임을 한다. 이때 사용되는게 @property와 @name.setter를 사용한다. 이것을 사용하면, python이 원래 의도했던, 마치 instance에서 setter getter라는 method도움없이 직접 입력하는 것과 같은 착시효과를 준다.\n예를 들어보자.\nclass Circle(object): PI = 3.141592 def __init__(self, radius=3.): self.radius = radius def get_area(self): return Circle.PI * self.radius ** 2 def set_area(self, value): self.radius = (value / Circle.PI) ** .5 circle = Circle(5.) print(circle.get_area()) circle.set_area(10) print(circle.radius) 위에는 일반적으로 coding할 때의 예다. radius라는 attribute가 있고, get_area, set_area함수에서 해당 radius에 접근해서 area계산값을 return한다. 그리고 instance에서 radius값을 직접 출력해 보기도 한다. 만일 radius가 private하다면, 아래의\nprint(circle.radius) 는 수행 될 수 없다. get함수를 써야, OOP의 개념을 살린 coding이라고 말할 수 있을것이다. 그런데 python에는 애초부터 private한 keyword가 없기 때문에 굳이 get함수를 사용할 필요는 없다. 다만 oop형태로 set과 get method를 만들지만, 직접 사용하는 것처럼 만들 수 있다. 아래의 예를 보자.\nclass Circle(object): PI = 3.141592 def __init__(self, radius = 3.): self.radius = radius @property def area(self): return Circle.PI * self.radius **2 @area.setter def area(self,value): self.radius = (value /Circle.PI) ** .5 circle = Circle(5.) print(circle.area) circle.area = 10. print(circle.radius) 여기에서 보면, @property와 @name.setter라는 decorator가 추가되었다. 이것은 setter, getter method를 마치 변수처럼 만들어준다. @property를 해주면, method가 변수처럼 되어 버린다. 위의 예에서는 마치 getter럼 정의된 area란 method에 @property가 있다. 따라서 아래와 같이 출력이 가능하다.\nprint(circle.area) area가 변수처럼 보이지만, area는 함수다. @property처럼 보여라하는 decorator가 붙어서 property처럼 처리한다.\n다음은 setter method처럼 정의된 함수에 decorator를 붙였다.\n@area.setter def area(self,value): self.radius = (value /Circle.PI) ** .5 그리고 다음과 같이 사용한다.\ncircle.area = 10. 보기에는 area변수에 10.0을 assign한것 처럼 보이지만, 실은 area라는 함수다.\nmagic method (dunder method) 파이썬에는 magic method를 많이 제공한다. 위에서 봤듯이 magic method는 __를 prefix와 postfix에 사용한다. 그리고 대부분이 object 객체에 있는 함수들이다. 이것은 built-in function들로 불린다.\nindexing method\nclass DoubleMapper: def __init__(self): self.mapping = {} def __getitem__(self, index): return self.mapping.get(index, index * 2) def __setitem__(self, index, item): self.mapping[index] = item mapper = DoubleMapper() print(mapper[10], mapper[1,2]) mapper[10] = 15 print(mapper[10], mapper[1,2]) [ ] 를 재정의 한 코드라고 강사는 말한다. __getitem__과 __setitem__을 class에 정의하게 된다면,\nmapper[10] = 5 이런 statement의 경우 __setitem__이 호출되고,\na = mapper[20] 이런 statement의 경우 __getitem__이 호출 된다고 한다. 이제 코드를 분석해 보자.\nprint(mapper[10], mapper[1,2]) 여기서, mapper[10]과 mapper[1,2]는 __getitem__을 호출한다. 처음은 10이라는 값을 넘기고, 두번째는 (1,2)라는 tuple값을 넘기는 것이다. 두 번째의 경우가 좀 이해하기 힘들긴 하다. 여튼 저런 값은 tuple값으로 생각하면 된다.\ndef __getitem__(self, index): return self.mapping.get(index, index * 2) 첫번째는 10이란 index를 __getitem__에 넘겼다. 여기서 get이란 함수가 좀 특이한데, 만일 index값이 없다면, 2를 곱해서 return한다는 뜻이다. 10이란 index에 값이 없기때문에, 20일 return된다. 마찬가지로 (1,2)라는 index가 존재하지 않기 때문에 2를 곱해서 (1,2,1,2)를 return한다고 한다. 즉 이제는 index가 10이거나 (1,2)에 대해선 값이 존재한다.\n이제 __setitem__을 수행하는 코드를 보자.\nmapper[10] = 15 이 코드는 class의 __setitem__을 호출한다.\ndef __setitem__(self, index, item): self.mapping[index] = item mapper객체의 index가 10인 값은 15로 저장되게 된다. 이렇게 해서 mapper객체의 값들은 {10:15, (1,2):(1,2,1,2)} 이렇게 유지된다.\n이렇게 __setitem__과 __getitem__을 사용한다면, index관련한 처리를 재정의가 가능하다. dictionary와 tuple array, list같은 index를 사용한 연산에서 index의 기능을 재정의하는게 가능하다. 위에서도 index를 사용해서 값을 return받거나, index에 값을 삽입하는 것을 getitem, __setitem__을 재정의하면 해당 method가 호출되는 것을 볼 수 있다.\n이런 형태가 pandas나 tensorflow에서 많이 보이는데, 안에 구조를 보면 setitem과 getitem을 재정의해서 사용하는 경우가 많다고 한다. tensor class가 이런 형태라고 한다.\nlength method\n예제를 먼저 보자.\nclass Dataset: def __init__(self, data, times =3): self.data = data self.times = times def __len__(self): return len(self.data) * self.times def __getitem__(self, index): if index \u0026gt; len(self): raise IndexError() return self.data[index % len(self.data)] dataset = Dataset([10,2,5,2], times=5) print(len(dataset)) 코드를 분석하자.\ndataset = Dataset([10,2,5,2], times=5) 이 부분은 dataset이라는 객체를 만든 것이다.\nprint(len(dataset)) 여기서, len(dataset) 이 부분이 해석하기가 좀 어려운데, dataset._len_()이 아니라 len(dataset)의 형태이기 때문이다. 두개가 형태만 다를뿐 동일한 것같다. 여튼, dunder method의 경우, len(dataset)형태로 많이 사용되어진다는 게 특이하다. 그리고 len(dataset)은 Dataset class의 len()를 호출한다고 보면 된다. 그리고 object 객체에 미리 정의되어 있다.\ngetitem()는 dataset[2], dataset[10] 처럼 index를 사용해서 값을 가져오는 명령에서는 __getitem__이 정의되어 있다면 호출된다. 연산자 재정의와 유사하다고 했다. code를 보면 다음과 같이 되어 있다.\ndef __getitem__(self, index): if index \u0026gt; len(self): raise IndexError() return self.data[index % len(self.data)] pass받은 index값이 원래 dataset이 가진 객체의 len()보다 작다면 에러가 나는데, len()는 객체가 가진 data의 길이다. 즉 index가 가진 data보다 큰 값으로 접근하면 에러가 발생된다는 얘기다.\ntyping magic method\nclass Courier: def __init__(self, name: str, address: str): self.name = name self.address = address def __str__(self): return self.address + \u0026#39;담당\u0026#39; + self.name courier = Courier(\u0026#34;김기사\u0026#34;, \u0026#34;경기도 성남\u0026#34;) text = str(courier) print(courier) 여기서도, str(courier)과 같은 형태가 나온다. courier.str()의 형태가 아니다. 이것은 object에 정의된 dunder method라고 바로 추측한다. 물론 위에선 재정의한 것이다. object에서 dunder method로 정의하는덴 그만한 이유가 있다. str이다. str은 int float와 같은 type이다. str(courier)라는 형태는 좀 이상해 보이지 않는가? 보통은 형변환시 사용되는 방법이다. str클래스가 있고, 생성자에 객체를 전달해서 str객체로 형변환한다고 생각한다. 또다른 예로, int객체 3이 str생성자에 전달되어 str(3)은 str 객체로 변환된다고 생각한다. 하지만, 이것은 int 클래스에 정의된 str dunder method의 호출이다. python에선 그렇다. int라는 class에 __str__메소드가 정의되어 있는것이다. 우리가 형변환이라고 부르는 int(courier)이나, float(courier), bool(courier) 모두 class의 dunder method로 정의되어 있다는 것이다. str dunder method를 정의해서 편리하게 쓰는 경우는 객체를 print할 때다. __str__메소드가 리턴하는 값이 출력된다.\ncomparison operator magic method\nclass Courier: def __init__(self, name: str, cid: int): self.name = name self.cid = cid def __lt__(self, other): return self.cid \u0026lt; other.cid couriers = [ Courier(\u0026#34;김기사\u0026#34;, 56), Courier(\u0026#34;박기사\u0026#34;, 72), Courier(\u0026#34;정기사\u0026#34;, 62) ] print(dir(Courier)) print(*[courier.name for courier in sorted(couriers)]) 여기서 눈여겨 볼 것은 list comprehension에서 sorted(couriers) 문장이다.\nprint(*[courier.name for courier in sorted(couriers)]) 이전에도 보았듯이 couriers.sorted()의 객체 method가 아닌, sorted(couriers)형태가 나온다. 이것은 sorted가 dunder method임을 말하고, class에 정의되어 있다. couriers객체의 type은 list이다. 즉 list에 sorted()가 정의 되어 있을 것이다. sorted()의 내부 동작은 정확히 모르지만, 객체들의 lt()를 사용해서 크기 비교를 하는것 같다. 예를 들면, a \u0026lt; b, a\u0026gt; c, 혹은 if a == b 와 같이 많은 비교를 할 것이다. sorted가 아니더라도, 객체를 비교하는 연산을 사용하는 경우는 많다. 이때, class에서 lt()를 정의하고 있다면, a \u0026lt; b라는 일견 평범한 연산은, a._lt_(b)로 해석될 수 있는 것이다. 즉 python에서는 모든 것은 객체고, 모든 operator는 method이기 때문이다. 마찬가지로 le, gq, ge, __ne__등 많은 것이 존재한다.\n연산자 재정의에 대해서.\n1\u0026gt;2, 1\u0026lt;3, 1 ==3 같은 logic operator ||, \u0026amp;\u0026amp;, ! 같은 관계연산자. +, , / ,*, % 같은 arithematic operator = assign operator len함수 같은것들. 이런 연산자들은 3\u0026gt;4, 1+4, a ** b 이런식으로 사용하는게 너무나 자연스럽게 생각하지만, 객체지향 언어에선 당연하다거나 자연스럽다고 생각하면 안된다. 왜냐하면, 객체 지향언어에서는 객체.method의 형태로 함수나 operator를 사용하지, 수학이나 c언어에서 사용하듯이 사용하는 저 방식은 매우 낯선것이기 때문이다. python에선 모든것은 객체고 모든 function은 method이다. 따라서 저 operators들은 class에 정의된 method이다. 우리가 class를 만들때마다 저런 operator를 모두 method로 만들어줘야 한다. 근데, Object에 이미 만들어져 있기 때문에, 자동으로 상속된다. 우리가 만든 dunder method는 모두 재정의한 것이다. overloading을 했던가 혹은 overriding을 한것이다.\n근데 한가지 궁금한 게 생겼다. 위에서 설명한 dunder method들, len, comparison 연산자들은 모두 객체에서 정의된 그대로 호출 할수 있었다.\na.__len__() 그런데 실제 사용할 때는\nlen(a) 와 같이 사용한다. 어떻게 해서 이렇게 사용할 수 있는것인가? 그리고, 위의 경우는 이름이 비슷하기라도 하다. 전혀 다른것들이 있다. 아래를 보면 \u0026lt; 심볼은 실제 lt()를 호출 한다. 이것은 어떻게 가능한 것인가? 여기에도 mangling이 되는 것인가? 그렇지는 않다. 왜냐면 dunder method는 직접 호출이 가능하기 때문이다.\na \u0026lt; b def __lt__(self,...): self.a \u0026lt; other.a 또 재밌는건, lt() method로 선언한 내부에는 \u0026lt;,\u0026gt;와같은 기호를 그대로 쓴다는 것이다. 그럴바에는 lt()를 만들 필요가 있었는지 모르겠다. 사용할때도 \u0026lt;,\u0026gt;같은 기호를 쓰고, 내부적으로도 사용한다면, 굳이 __lt__라는 이름뿐인 함수를 왜 정의하는지 모르겠다.\narithmetic operator : magic method\nclass MyComplex: def __init__(self, real, imaginary): self.real = real self.imaginary = imaginary def __str__(self): return str(self.real) + \u0026#39;+\u0026#39; + str(self.imaginary) + \u0026#39;j\u0026#39; def __add__(self, other): return MyComplex( self.real + other.real, self.imaginary + other.imaginary ) a = MyComplex(3, -5) b = MyComplex(-6,7) print(a + b) 어떤 class를 만들었을때, class로 만든 instance가 + 연산을 할 수 있게 하려면, class에 add()가 있어야 한다. 물론 object에도 정의되어 있다. overloading이나 overriding으로 재정의할려면 위와같이 add()를 재정의한다. str()도 재정의해서 print문에 사용할 수 있다. sub(), mul()도 존재한다.\niadd()도 존재한다. 이것은 = 을 사용해서 객체를 만드는 대신 +=을 사용해서 객체를 새롭게 생성하지 않는다고 한다. 왜냐면, +=는 연산자이기 때문이다.\nCallable : magic method\nclass AdditionNumber(object): def __init__(self, number: int): self.number = number def __call__(self, number: int): return number + self.number addition_5 = AdditionNumber(5) print(addition_5(10)) 이건 또 뭐야? 할정도로 이상한 모양이다.\nprint(addition_5(10)) addtion_5는 instance다. AdditionNumber(5)로 부터 만들어진 instance다. 그런데 instance에 (10)을 붙였다. 이것은 syntax error가 날 만도 하다. 근데 정상 동작이 된다. 어떤 이유에서일까? addition5자체는 instance객체의 이름이다. ()는 call method를 의미한다고 한다. object객체에 정의된 built-in function이기도 하다. 따라서, addition5._call_(10)을 addition5(10)으로 사용한다는 건데 그러면, ()와 __call__간의 mapping은 어디에 정의 되어 있는가?\nfor : magic method iterable\nseq = [1,2,3,4,5] for elem in seq: print(elem) 위와 같은 for문은 다음과 같은 형태라고 한다.\nseq = list([1,2,3,4,5]) iterable = iter(seq) while True: try: elem = next(iterable) except StopIteration: break print(elem) python에서 for문은 다른언어와 다르게 iterable객체에서 값을 가져와서 처리하게 되어있다. 즉 유한한 값을 반복한다. 그래서 구조도 좀 다르다. for in이 같이 쓰인다. in 다음에는 collection이 들어가는데, 이 collection은 iter()를 사용해서 iterable객체가 된다. iterable객체에는 start,end, cur이라는 내부변수가 있다. next()가 있어서 cur이 가리키는 값을 return한다. return한 값은 변수와 binding되고, 다음 명령어가 수행된다.\ncontext manager: magic method\nclass Courier: def __init__(self,name: str): self.name = name def __enter__(self): self.parcels = [] return self def __exit__(self,exec_type,exec_value, trace): for parcel in self.parcels: print(parcel, \u0026#34;배달 실패\u0026#34;) # parcel.clear() courier = Courier(\u0026#34;김기사\u0026#34;) with courier: courier.parcels.append(\u0026#34;소포\u0026#34;) with courier as c: c.parcels.append(\u0026#34;소포\u0026#34;) with로 시작되는 구문이 있다. 생소하다. as도 생소하다. 우선 with 다음에는 객체가 온다. 그리고 block이 정해진다. 해당 객체가 block에서 사용될때, class의 enter()가 실행되고, block을 빠져나올때, exit가 수행된다. as는 객체의 이름을 block에서 c라고 사용하겠다는 뜻이다. exit는 error나 exception이 발생되도 실행이 되게 되어 있다. 그래서 error의 정보를 나타내기 위해서 exec_type, exc_value같은 인수를 제공한다.\nwith as가 가장 많이 사용되는 경우는,\nwith fopen(\u0026#34;test.txt\u0026#34;) as fd 과 같이 file을 열때, context를 유지해야할 때 많이 사용한다고 한다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture7_object-oriented-programming\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture8-module-and-package\/": {
        "title": "lecture8-module-and-package",
        "tags": [],
        "content": "module import 사용법 module은 .py로 끝나는 파일 한개를 의미한다. python으로 작성된 모든 file들은 python module이라고 부를 수 있다. import구문으로 module을 불러올 수 있다. 예를 들어보자. 내가 작업하고 있는 file에서 functions.py라는 파일에 있는 qr()를 사용하고 싶다면, 우선 import로 가져와야 한다. 가져온다기 보단, 실행한다고 말을 해도 된다. 오히려 그게 직관적이다. 여튼 가져오던 실행하던 문맥에 맞게 이해하면 된다.\nimport functions print(functions.qr()) import로 가져온 file의 함수를 사용하기 위해선, 모듈명.함수명()으로 사용한다. import로 가져온 함수다라는 꼬리표를 달아두는 것이다. import뒤에는 module이 올수도 함수나 변수가 올 수도 있다. import뒤에 모듈이 올 경우에는 모듈 이름으로 class를 만들고 module이 담고 있는 내용이 복사가 된다고 생각하면 된다.\nimport 사용시 주의점 내가 작업하는 파일에서 import로 모듈을 가져올 때, 가져올 파일은 내가 지금 작업하는 파일과 같은 폴더이거나 하위폴더에 있어야 한다. 그래야 가져올 수 있다. 상위폴더는 안된다.python interpreter는 import로 모듈을 가져오면서 처음부터 끝까지 읽고 객체들을 만든다. 만일 모듈에 print문이 있다면, 그냥 출력시킨다.\nmodule의 이름 이전에 말했듯이 .py로 끝나는 파일을 module이라고 했고, 파일의 이름이 module의 이름이다. 그런데, 특이한게 있다. main이라는 module 이름이다. 이것은 python에 의해서 정해진 이름이다. 다음을 보자. 나는 test.py라는 파일을 만들고, 모듈이름을 출력하는 코드를 만들었다.\nprint(__name__) python test.py 이렇게 실행하면, test라는 이름이 출력되야 한다. 우리는 test module을 실행시켰기 때문에 test가 출력되야 하는데, main이라는 이름이 출력된다. python에 의해 실행되는 file의 모듈이름은 main인 것이다. 모듈이 실행되는 경우는 2가지다. python interpreter에 의해서 직접적으로 실행되거나, import문에 의해서 실행될 수 있다. 직접 실행되는 module의 이름은 main이 되고, 나머지는 파일이름을 module이름으로 갖는다.\nmain이란 module이름을 가장 많이 사용하는 예에는 다음과 같은 경우가 있다.\nif __name__ == \u0026#39;__main__\u0026#39;: 즉, python에 의해서 실행된 파일인 경우, 파일이름과 상관없이 수행하게 된다는 뜻이다. python으로 직접 실행하면, main이라는 이름을 갖기 때문이다.\nimport하는 예시들. 우선 가정을 하자.\nFigure 1: 구조.\n위와 같이 functions.py라는 파일이 directory라는 폴더 아래에 있다고 하자. main.py에는 아래와 같이 import할 수 있다.\nimport directory.functions print(directory.functions.add(1,2)) import뒤에는 module이 올수도 있고 함수나 변수가 올수도 있다. import뒤에 module이 오는 경우, class를 만든 후 붙여 넣기한다. import할 module이 같은 폴더내에 없다면, 경로를 위와같이 명시해야 한다. 그래야 정확하게 현재 파일의 윗 부분에 붙여 넣는다. 붙여 넣을때, directory라는 class가 만들어지고, 그 안에 functions라는 class가 만들어진다고 보면 된다. 따라서 그 안의 add라는 함수를 사용할 때는 위와 같이 꼬리표를 달아야 한다.\nimport directory.functions as func print(func.add(1,2)) as는 alias의 준말이라고 한다. 2개의 class를 만들어서 import하는게 아니라, as를 사용해서 func라는 class를 만들고, 그 안에 붙여 넣는다.\nfrom directory import functions print(functions.add(1,2)) from이라는게 나왔다. from은 경로만 얘기한다. functions를 import하겠다. functions의 위치는 directory아래에 있다. functions은 module이다. 따라서 functions라는 class를 만들고, functions의 내용을 다 붙여 넣기 한다. functions class의 내용을 사용할때는 class의 함수를 사용하기 때문에 class이름을 사용하여 접근한다.\nfrom directory.functions import add print(add(1,2)) 위에 표기법과 비슷하다고 생각할 수 있다. 근데 import뒤에 있는건 module이 아니라 function이다. module이 아니기 때문에 class를 만들고 copy \u0026amp; paste를 하지 않고, 바로 copy \u0026amp; paste할 것이다. 하지만, 여기서 알아야 하는건 import뒤에 module이 아닌 function이라는게 올 때는 조건이 필요하다는 것이다. from으로 module을 지정해야 한다. 그렇지 않고, import로 직접 function이나 variable을 가져오면 에러가 난다. 예를 들면 다음과 같은 경우가 있다.\nimport directory.functions.add import만 쓰이는 경우는 module을 써야 하는데, add는 function이라서 에러가 난다.\nimport add from directory.functions import * print(add(1,2)) 이것도 import하는게 module이 아니다. 그래서 그대로 functions module의 모든 내용을 copy \u0026amp; paste한다. 이것은 문제가 될 수 있다. 내가 작성한 함수와 import로 가져온 함수가 동일할 때, overwrite가 된다.\n주의 해야할게 있는데, import는 module,변수,함수만 할 수 있다. 경로라고 생각하면 안된다.\nFigure 2: example\n예를 들어 위에서 directory를 import하고, 하위 모든것이 import된다고 생각해선 안되는 것이다.\nimport 예시2 import할 때, 파일의 경로문제가 있다. main module과 import하는 module의 경로에 따라서 다음과 같은 에러가 발생할 수 있다.\nImportError: attempted relative import with no known parent package ValueError: attempted relative import beyond top-level package 경로에 따른 import문제가 발생하는 이유는, 경로는 main모듈 기준으로 상위폴더에 접근이 되지 않는다. 또한 하위폴더들은 절대경로로 주어지며, package를 사용했을 때만이 상대경로를 사용하여 상위폴더나 하위폴더에 접근할 수 있기 때문이다.\nimport의 경로(상위폴더와 경로의 기준) Figure 3: import example2\n경로의 개념이 os기준도 아니고, python interpreter기준도 아니고, main모듈 기준이라고 했다. function2 module을 import해서 경로가 어떤 것을 의미하는지 확인해 보자.\nfunction2에 대한 경로 import\nimport Users.holy.temp.pythontest.test_nlp.parent_dir.mydir.child_dir1.functions2 Users.holy.temp.pythontest.test_nlp.parent_dir.mydir.child_dir1.functions2.sub(3,2) python main.py import의 경로는 os의 root를 기준으로 설정했다. 에러가 나지 않는다면 import의 경로는 os기준이다.라고 말할 수 있을 것이다.\nFigure 4: import error\n경로라는게 os입장에서의 절대경로가 아닌것을 알 수 있다. 그렇다면 혹시 python의 실행위치가 경로의 기준인 top-level directory일까?\nimport parent_dir.mydir.child_dir.functions2 parent_dir.mydir.child_dir.functions2.sub(3,2) python parent_dir/mydir/main.py python의 실행위치는 project의 최상단에서 시작한다. python 실행위치 기준에서는 parent_dir이 하위디렉토리이기 때문에, 위와 같이 import하면 경로를 인식할 수 있을것이다.\nFigure 5: error2\n그런데 python은 하위폴더인 parent_dir도 인식하지 못한다. top-level directory가 파이썬의 실행위치가 아님을 알 수 있다. 그러면 main module 기준인가? 확인해 보자. main module을 기준으로 하위폴더의 function2를 import해서 test해보자.\nfunction2의 import\nimport child_dir1.functions2 child_dir1.functions2.sub(3,2) python parent_dir/mydir/main.py Figure 6: import success\n성공적으로 import하는 것을 알 수 있다.\npackage와 import 상대 경로 python으로 program을 만들때, file하나만 만들어 사용하지 않는다. 여러개의 file을 import해서 사용하고, 배포를 통해서 다른사람에게도 전달한다. 그래서 package라는게 나왔다. 정해진 규격에 따라 여러 파일들을 모아서 배포도 가능하고 그 자체가 하나의 독립적인 program이 되는 것이다. main.py같은 main 모듈은 package를 사용할 뿐이지, package에 포함되는 건 아니다. package에서 import문은 여러 특징이 있다. python에서 package를 만들어 test해보자.\npackage를 만드는 것은 간단하다. folder안에 init.py를 만들어 넣으면 package가 된다. init.py가 하는 역할은 단순히 이 폴더가 package라고 말하기도 하지만, import를 처리하기도 한다. 기존 import구문을 확장해서 처리한다. import구문에서는 module, 함수,변수만이 올 수 있었다. 그런데, init.py를 사용해서 import뒤에 폴더가 오게 할 수도 있다. 또한 상대경로도 사용할 수 있다.\nimport뒤에 폴더가 오는 경우\n우선 다음과 같이 game이란 package와 package를 이용할 main.py를 만들었다.\nFigure 7: package example\ngame package안에는 init.py가 있어서 package를 나타낸다. sound도 또다른 package다. sound에는 echo모듈 아래 echo_test()가 있다. main에서 이 함수를 import해서 사용해 보자.\nimport game.sound.echo game.sound.echo.echo_test() Figure 8: package test\n별다른 문제없이 실행되는 것을 볼 수 있다. 다음을 test해보자.\nimport game game.sound.echo.echo_test() Figure 9: package test2\n당연히 에러가 나온다. 왜냐면 import뒤에는 module이 나오거나, from이 있다면, function, 변수가 나와야 하는데, game이란 그냥 폴더가 나왔기 때문이다. 그래서 에러가 나온다. 그런데 package에선 이것이 가능할 수 있다.\ngame의 init.py에 다음을 추가하자.\nimport game.sound.echo 그리고 아까와 동일하게 main.py에서 game만 import하고 echo_test()에 접근하자. 동작이 되는 것을 확인 할 수 있다.\nimport game game.sound.echo.echo_test() Figure 10: package test\n즉 이것은 import game을 읽으면, game폴더안의 init.py의 설정된 내용으로 대체가 된다.\n즉 game이 game.sound.echo로 replace된다.\nimport game.sound.echo game.sound.echo.echo_test() import뒤에 *가 오는 경우\n다음을 test 해보자.\nfrom game.sound import * echo.echo_test() 이것은 문제가 있다. import *를 사용하기 위해선, from에서 module을 포함해야 하는데, from에 있는 sound는 module이 아니다. 따라서 error가 날 수 밖에 없다. 또한 echo.echo_test()도 echo를 import했을 때만 이렇게 사용될 수 있기 때문에 이것도 문제가 있다. 그런데, 이것도 package에선 가능할 수 있다.\nsound폴더의 init.py를 다음과 같이 설정하자.\n__all__ = [\u0026#39;echo\u0026#39;] import에서 *를 사용할 경우, 참조할 module을 지정하는 것이다. 결국 sound폴더의 init.py를 읽고, *가 echo로 replace된다는 뜻이다.\nfrom game.sound import * echo.echo_test() 위의 내용이 아래와 같이 바뀐다.\nfrom game.sound import echo echo.echo_test() 상대 경로 사용하기.\n다시 한번 우리의 package를 살펴보자.\nFigure 11: package example\n여기서 graphics폴더에 graph module을 추가해보자. 그리고 gameplayer라는 module도 상위 폴더에 만들자.\nFigure 12: package example\ngraph 모듈에서 상위폴더의 gameplayer.py라는 module을 import해 보자. 우리는 import구문은 하위 folder의 모듈만 access할 뿐 상위폴더의 module은 access할 수 없다고 했다. package에선 가능하다.\n내가 시도하려는 것은 graph라는 module에서 상위 폴더의 gameplayer라는 module의 pplayer()를 상대경로로 import해서 사용할려고 한다.\ngraph.py에 다음을 추가하자.\nfrom ..gameplayer import pplayer def render(): pplayer() ..은 상위 폴더를 의미한다. 상위 폴더의 module의 pplayer()를 import해서 사용하는 것이다.\n이제 main에서 graph module을 import해서 test해보자.\nfrom game.graphics import graph graph.render() 아래와 같이 동작되는 것을 알 수 있다.\nFigure 13: package results\ninit.py와 전역변수\ninit.py에서 import만 처리하는게 아니라, package에서 전역적으로 사용하는 변수도 넣어도 된다. 예를 들어, game 폴더 아래 init.py에 number_of_players = 10을 넣고 main에서 사용 할 수 있다.\nimport game.sound.echo NUMBER_OF_PLAYERS = 10 main에서 다음과 같이 사용할 수 있다.\nimport game print(game.NUMBER_OF_PLAYERS) summary\ninit.py가 없어도 최신 버전에서는 폴더를 package로 인식한다고 한다. 하지만, init.py가 있으면 많은 import기능을 확장할 수 있고, 전역적으로 사용되는 것을 모아둘 수도 있다. 일종의 convention 비슷하다. 또한, package에서 구현을 하고, main.py는 package를 test하는 용도로 사용한다는 것이다. main에서 모든것을 하려고 하면 안된다. 즉 main은 package에 있는 module을 import해서 test하는 역할이면 된다.\npython standard library 우리가 모든 package를 만들어서 사용하지 않아도 python에서 설치하지 않아도 제공하는 library(package)들이 있다. 이것을 standard library라고 부른다. 가장 많이 사용하는 standard library를 정리한다.\nrandom package import random print(random.randint(0,100)) print(random.uniform(0,1)) 0-100까지의 정수를 반환하거나, 0-1사이의 uniform distribution에서 한개를 sampling할 때 위 package를 사용한다.\ntime import time start = time.time() time.sleep(1) print(time.time() - start) time은 시간관련 standard library다. time()는 현재 시간을 return한다. sleep()는 1초 기다린다.\nthreading import threading import time def print_function(): print(\u0026#34; python은 GIL때문에 single thread이다.\u0026#34;) time.sleep(1) thread = threading.Thread(target=print_function) #쓰레드 만들기 thread.start() #Thread 시작 thread.join() #Thread 수거? GIL은 Global Interpreter Lock이라고 한다. interpreter기반이라서 그렇다고 한다.\npython 외장 library 와 package manager 외장 library python은 많은 외장 library를 제공한다.\n수치 그래프 -\u0026gt; matplotlib 웹서버 -\u0026gt; flask, django gpu연산 -\u0026gt; cupy deep learning library -\u0026gt; tensorflow, pytorch package manager와 virtual env 개요 package manager는 외부 package를 system에 설치하는 프로그램이다. virtual env는 python이 설치된 가상환경을 의미한다.\n문제점 python project마다, 다른 version의 python interpreter를 사용한다거나, 외장 library를 가져와서 사용할 수 있다. 예를 들어서, web개발을 위해 django를 설치하고 deep learning을 위해서 pytorch를 설치했다고 하자. 해당 framework마다 내부적으로 다른 version의 package들을 가져와서 사용하는데, 이게 충돌의 위험이 있다고 한다. 또한 python의 version에 따라 동작이 안되는 package가 있을 수 있다. 예를 들어서 django는 3.5에서 성능이슈가 있고, pytorch는 3.8에서 문제가 있다면, 둘다 문제가 없는 3.6이나 3.7을 사용하면 된다. 과연 문제가 없을까? 3.6에서 두 framework의 내부 package들끼리 충돌이 일어날 수 있다. 그래서 django를 위해선 python 3.9를 사용하고 pytorch를 위해선 3.8을 사용하면 된다. 그런데 여기서 문제, python은 system에 하나만 설치할 수 있지 않나? 그 문제를 해결한게 virtual environment이다.\npip(+ virtual env)와 anaconda pip와 anaconda는 package manager다. package를 system에 설치하고, 의존성 검사도 하고, 삭제도 하는 관리 프로그램이다. pip에는 virtual env, 즉 python을 버전별로 여러개 한 system에 설치하는 기능은 없다. virtualenv와 virtualwrapper등의 도움을 받아야 한다. anaconda는 conda에서 virtual env기능도 지원한다.\nanaconda는 200개의 외부 library가 설치된다. 무겁다. miniconda는 최소만 설치된다.\ncolab colab은 notebook마다 kernel이 개별적으로 있다. kernel은 python interpreter + library인 environment를 의미한다.\nanaconda 사용법 강사는 anaconda를 위주로 사용법을 설명해준다.\nvirtual environment 만들기 conda create -n nlp : nlp라는 가상환경을 만든다. -n은 name이라고 한다. conda activate nlp : nlp 가상환경을 활성화한다. conda deactivate : 현재 nlp 가상환경을 비 활성화 한다. package management conda install \u0026lt;package name\u0026gt; -c \u0026lt;설치 채널\u0026gt; : 채널은 package가 설치된 목록을 가지고 있는 repo로 봐도 된다. 유명한 channel로는 conda-forge가 있다. conda의 기본채널도 있다. 어떤 package를 설치하려고 하는데 default package에서 찾을 수 없다면, conda-forge채널에서 찾을 수 있을것이다. conda-forge에서 찾을수 없다면 거의 안 쓰이는 package라고 보면 되고, pip의 채널을 사용해야 한다. package를 설치할때는 anaconda hub 를 통해 검색하면 좋다. conda-forge사이트이다. pytorch같은 경우는 pytorch에서 직접 설치할 수도 있다. pytorch의 channel이 있기 때문이다. conda install pytorch -c pytorch default channel은 안써도 상관없고 써도 상관없다. conda install python=3.9 -c default conda list : 설치된 library를 볼 수 있다. conda list | grep numpy anaconda를 설치하고 깔아야 하는 library matplotlib : conda install로 설치하자. tqdm(progress bar): 진행사항을 progress bar로 보여준다. module과 built-in function에 대하여 .py파일은 module이다. module은 class로 봐도 된다. python에서 main module, 즉, program의 시작을 나타내는 module은 main이라는 class로 보면 된다. java에서는 public static void main()아래에서 coding을 한다. 변수도 선언하고 for-loop도 돌린다. public static void가 포함된 .java파일에는 class가 있다. java에선 하나의 파일이 하나의 class이기 때문에, class 문장으로 시작한다. 그런데 python에서는 implicit하다. 하나의 파일이 하나의 class인것도 java와 동일하다. 다만, class라고 명시적으로 쓰지 않는다. 그런데 module을 import하면 import한 모듈의 class가 만들어지고, class.변수,함수 이렇게 접근을 한다. java나 python이나 모두 file은 하나의 class이지만, java는 명시적으로 class가있지만, python은 없다고 했다. 그래서 .py를 열어보면, 바로 for-loop이 나온다거나, len()같이 함수들이 불쑥 불쑥 튀어나온다. 그런데, 그런 built-in function이란것들은 function같이 보이지만, main class혹은 module class의 method이다. len은 물론 object를 상속 받았기 때문에, object의 method이지만, python에서 function이라고 부르는 대부분은 method이다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture8-module-and-package\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture9-advanced-data-structure\/": {
        "title": "lecture9-Advanced-Data-Structure",
        "tags": [],
        "content": "Stack a = [1,10] a.append(4) a.append(20) print(a.pop()) print(a.pop()) stack은 FILO(First In First Out) python에서 stack은 list를 사용하면 된다. list에서 제공하는 append와 pop을 사용한다. list의 시작주소와 마지막 노드 주소를 가지고 있기 때문에 삽입과 삭제는 O(1)이 걸린다. Queue a = [1,0] a.insert(0,20) a.insert(0,15) print(a) print(a.pop()) Queue는 FIFO이다. python에선 list의 내장함수를 이용해서 사용할 수 있다. insert()로 0번 position에 입력하면 값들이 계속 shift된다. pop()은 마지막 position에서 값을 꺼낸다. 강사는 queue를 list를 사용하면, insert와 pop시 속도가 O(n)이 된다고 한다. python의 list는 dynamic array라고 한다. 근데 또 끝에 있는것을 pop()할때 O(n)이라고 하는데, 그러면 list 맞는거 같은데\u0026hellip; 내 생각에 list로 구현된 queue의 경우, pop()은 O(n)이 맞는듯하다. 왜냐하면 deque를 설명할 때, tail의 위치를 유지하고 있어서 pop()을 할때 O(1)이 걸린다는 얘길한다. 강사는 linked list를 사용해서 queue를 만들어야 한다고 한다. deque from collections import deque queue = deque([10,5,2]) queue.appendleft(16) #왼쪽 삽입 queue.pop() #오른쪽 삭제 queue.append(20) #오른쪽 삽입 queue.popleft() #왼쪽 삭제 print(queue) print(deque(reversed(queue))) #deque 뒤집기 O(n) deque는 linked list로 이루어진 double queue라고 한다. stack은 삽입과 삭제가 한방향에서만 일어난다. queue라는 것은, 삽입과 삭제가 서로 다른방향에서 일어난다. dequeue는 양방향에서 삽입과 삭제가 일어날 수 있다. priority queue(heapq) priority queue의 장점 priority queue는 매우 자주 사용되는 자료 구조라고 한다. queue에 입력된 data중에서 최소,최대값을 빠르게 구하고 싶다면, priority queue를 사용해야 한다고 한다. min/max함수를 써서 주어진 collection의 최소, 최대를 찾을수도 있다. 하지만, O(n)의 속도가 걸린다고 한다. 내부가 정렬되어 있다면, binary search로 O(log n)이 걸릴것이다. 그럼 삽입할때 마다, 정렬을 해줘야지 search시에 O(log n)을 유지하는데, 정렬을 하는데에 O(NlogN)이 걸리기 때문에 그닥 효율적이지 못하다고 한다. priorty queue를 사용하면, 이것을 해결한다고 하는데, 뭔말 하는지 모르겠다. priority queue는 python에서 heapq라고 한다.\nheapq 사용법 import heapq queue = [5,2,8,4] heapq.heapify(queue) #초기화, tree로 변경 O(N log N) print(queue) print(queue[0]) heapq.heappush(queue,3) print(queue) print(queue[0]) heapq.heappush(queue,6) print(queue) print(queue[0]) item = heapq.heappop(queue) print(item, queue[0]) item = heapq.heappushpop(queue,7) print(item, queue[0]) heap이란 자료구조 별도로 있다. max heap과 min heap이 있는데, max heap은 부모 노드값이 자식보다 큰 tree를 말하고, min heap은 부모 노드값이 자식보다 작은 tree를 말한다. python의 heapq는 min heap이다. 내부적으로 완전 이진 tree를 사용하고 있다. 사용하고 있는 tree와 배열간에는 다음과 같은 관계가 있다고 한다.\nheap[k] \u0026lt;= heap[2*k+1] and heap[k] \u0026lt;= heap[2* k+2] Defaultdict 개요 dictionary는 기본적으로 없는 key로 접근했을 때 key error를 발생한다.\nd = {\u0026#34;first\u0026#34;: 0} print( d[\u0026#34;second\u0026#34;]) 이것을 방지하기 위해서, key가 없을 때, default값을 반환하는 get()를 제공한다.\nd = {\u0026#34;first\u0026#34;: 0} print( d.get(\u0026#34;second\u0026#34;, \u0026#34;없어요\u0026#34;)) defaultdict()는 위에 get()가 사용하는 방식처럼 미리 default값을 dictionary에 정의한 것이다. 그래서 key가 없더라도 에러를 출력하지 않고 기본값을 출력한다.\n사용예 defaultdict가 어떨때 사용하면 좋은지에 대해서 강사는 예를 든다. 만일 우리가 어떤 text북에서 나오는 모든 글자를 counting하고 싶다고 하자. 어떻게 programming할 것인가?\ntext = \u0026#34;\u0026#34;\u0026#34;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan nisl.\u0026#34;\u0026#34;\u0026#34; characters ={} for char in text: count = characters.get(char, None) if count is None: characters[char] = 0 characters[char] += 1 print(characters) program을 작성하기 위해서, 입력은 무엇인지, 입력에 대해 어떤 처리를 해야 하고, 그 처리 결과를 어떻게 할지를 생각해야 한다. 입력은 text문자열이다. text문자열을 어떻게 처리할 것인가? text문자열을 하나씩 꺼낼것이다. text문자열은 유한개이다. 따라서 for loop을 사용할 것이다. text문자입력에서 하나씩 꺼낸 문자를 어떻게 처리 할 것인가? 그 문자를 counting해야 한다. 어떻게 counting할 것인가? dictionary를 사용해서, 해당 문자와 counting을 저장하고 싶다. 해당문자와 그 문자의 occurs를 같이 저장해야겠다는 idea를 도출하는게 중요하다. 문자와 occurs를 쌍으로 저장하려면 tuple도 있고, dictionary도 있다. tuple을 사용하려면, list같은 data structure가 또 필요하다. 그래서 dictionary를 사용하겠다. dictionary는 쌍으로된 많은 data를 저장할 수 있기 때문이다. text에서 문자 하나를 꺼내서 dictionary에 있는지 없는지를 검사한다. 만일 있다면, occurs를 증가시킨다. 없다면 dictionary의 key로 등록하고 occurs를 1로 counting한다. 그런데 위의 코드는 내 생각과 다르다. 위의 코드에선, key에 해당하는 문자가 있는지 없는지 검사하지 않는다. 무조건 key에 해당하는 값을 return하거나, 없으면 None값을 key로 return하는 dictionary의 get이란 함수를 사용한다. get이란 함수의 좋은점은 2가지가 있다. key가 없으면 에러를 내지않고 임의의값으로 key를 등록한다. key가 있는지 없는지 확인할 필요가 없다. 없으면 default 값으로 key를 등록하기 때문이다. 그리고 if문을 사용해서 none으로 등록된 key를 제대로 된 alphabet으로 하고 occurs를 등록한다. 이렇게만 해도 충분해 보인다. 하지만, 강사는 defaultdict가 이것을 훨씬 편하게 해준다고 한다.\ndefaultdic의 사용 from collections import defaultdict text = \u0026#34;\u0026#34;\u0026#34;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan nisl.\u0026#34;\u0026#34;\u0026#34; characters = defaultdict(int) # characters = defaultdict(lambda: 0) for char in text: characters[char] += 1 print(characters) defaultdict을 사용하면, 매우 간단해지는 것을 볼수 있다. 즉 text로부터 꺼낸 알파벳에 대한 key값이 모두 dictionary에 들어있다고 생각하게끔 만든다. 즉 모든 알파벳에 대한 key와 value가 이미 dictionary에 있기 때문에 해줘야 할 것은 text에서 뽑은 key를 갖는 요소에 +1만 해주면 된다. 위에서 살펴봤던 get을 사용하는 경우나, 내가 생각했던 방식보다 훨씬 간단한것을 알 수 있다.\n여기서 defaultdict를 생성할때, int를 주면 int()를 해서 모든 값이 0으로 채워진다고 한다. 그런데 특정값을 생성할 수 있는 lambda를 사용해도 된다. lambda로 0을 만들수도 있고, 특정 계산이 들어갈 수도 있다. 그리고 for-loop에서 꺼낸 알파벳을 key값으로 해서 value를 저장하는데, key가 없다면 key를 생성하는 부분은 내부적으로 구현되서 감춰져 있다. 강사는 dictionary를 사용할 일이 있을때, defaultdic을 사용하는것도 좋지만 counter를 사용하면 더 깔끔하게 코딩할 수 있고 pythonic하다고 한다.\nCounter 개요 Counter는 defaultdic과는 달리 세는데 최적화된 class라고 한다. defaultdict를 다시 한번 살펴보자.\nfrom collections import defaultdict text = \u0026#34;\u0026#34;\u0026#34;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan nisl.\u0026#34;\u0026#34;\u0026#34; characters = defaultdict(int) # characters = defaultdict(lambda: 0) for char in text: characters[char] += 1 print(characters) 이것을 counter를 사용하면 다음과 같이 된다고 한다.\nfrom collections import Counter text = \u0026#34;\u0026#34;\u0026#34;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan nisl.\u0026#34;\u0026#34;\u0026#34; characters = Counter(char for char in text) print(characters) Counter안의 표현법은 list comprehension과 비슷하다. 간단하게 counter의 기본 동작을 확인하는 code를 짜보자.\nfrom collections import Counter print(Counter([1,2,1,2,3])) Counter에 [1,2,1,2,3]이라는 list를 넣어주면, list의 item을 key값으로 하고, 해당 key의 occurs를 value로 하는 dictionary가 내부적으로 생성된것을 볼 수 있다. 즉 우리가 원래 하려고 했던 작업인 text로 부터 알파벳들이 몇번씩 occurs되는지를 Counter를 사용하면 매우 간단하게 할수 있겠다는 생각이 든다. 즉 list를 넣어주면 counting값을 갖는 dictionary를 자동으로 만들어주니까, 우리가 해야할 것은 text를 Counter에 넣어만 줘도 되는거 아닌가? 물론 text는 string이고 list가 아니라는 차이는 있다. 한번 해보자.\nfrom collections import Counter text = \u0026#34;\u0026#34;\u0026#34;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan nisl.\u0026#34;\u0026#34;\u0026#34; print(Counter(text)) 문제없이 된다. 그런데, 왜 강사는 string을 list comprehension을 사용해서 list로 만들었는지는 이해가 안간다. 다만, list comprehension을 넣을수 있다. 이것을 알려주려 했을지도 모르겠다. 또다른 예를 보여준다.\nfrom collections import Counter print(Counter([\u0026#34;test\u0026#34;,\u0026#34;test\u0026#34;, \u0026#34;text\u0026#34;])) 여기서 궁금한점, string을 사용해서 단어를 세는 program을 Counter로 작성하는것이 가능할까? 하는것이다.\ncounter에 대한 분석 counter는 dictionary from collections import Counter c = Counter({\u0026#34;korean\u0026#34;:2, \u0026#34;English\u0026#34;:3}) print(c.keys()) print(c.values()) print(c[\u0026#34;korean\u0026#34;]) print(list(c.elements())) # d = {\u0026#39;a\u0026#39;:3,\u0026#39;b\u0026#39;:2} # print(list(d.elements())) Counter는 내부적으로 dictionary를 이용한다. 따라서 dictionary로 봐도 된다. 그리고 list만 인자로 넣는것이 아닌 dictionary를 인자로 넣어도 아무 문제 없다. list의 경우 내부적으로는 list를 counting해서 dictionary를 다시 만든다. dictionary는 그대로 가져다 쓴다. 여기서 특이한 method가 있다. elements라는 method이다. 일반적인 dictionary에는 존재하지 않는다. counting은 list를 dictionary형태로 바꿀때 counting value를 사용했다. 이를 elements()로 list로 변환할 때는 counting을 했던것을 다시 바꿔준다.\ncounter는 집합 연산 지원 from collections import Counter a = Counter([1,1,2,2,2,3]) b = Counter([2,3,3,4]) print(\u0026#34;a =\u0026#34;, a) print(\u0026#34;b =\u0026#34;, b) print(\u0026#39;a+b =\u0026#39;, a+b) print(\u0026#39;a\u0026amp;b =\u0026#39;, a\u0026amp;b) print(\u0026#39;a|b =\u0026#39;, a|b) print(\u0026#39;a-b =\u0026#39;, a-b) # a = {\u0026#39;a\u0026#39;:3,\u0026#39;b\u0026#39;:5} # b = {\u0026#39;c\u0026#39;:5, \u0026#39;b\u0026#39;:2} # print(a+b) a+b\na와 b가 counter객체일때 두 객체의 합은 무엇일까? dictionary에선 +연산자를 지원하지 않는다. counter는 내부적으로 key에대한 counter를 가지고 있기 때문에, key가 같다면, counter수를 증가시켜준다.\na\u0026amp;b\na\u0026amp;b도 예측하기 어렵다. 우선 두 counter객체가 가진, key가 양 객체에 모두 존재해야 한다. value에 해당하는 occurs는 작은값을 가지게된다. 그게 공통적으로 갖게 되는 값이기 때문이다. 예를 들어, a객체에 2:1, b객체에 2:4가 있다면, a\u0026amp;b로 얻는 것은 2:1이 된다.\na|b\n이것도 key와 value를 모두 따져야한다. key의 경우, a객체와 b객체에서 한번이라도 나온것은 다 포함된다. value의 경우, 계산은 하지 않는다. 둘중 큰값을 선택한다. 예를들어서, a객체에 2:1이 있고, b객체에 2:3이 있다면 a|b로 얻는것은 2:3이다.\na - b\n이것은 a객체가 가진 item에서 b객체의 item을 빼준다. 여기서 고려해야 하는것은 a객체에도 있고, b객체에도 있는 item이다. b객체에만 있는것은 고려대상이 아니다. a객체에만 있다면, -해야할 께 없기때문에 고려대상이 아니다. 즉 공통으로 있는 item에서 계산이 일어난다. 예를 들어 a객체에 2:3이 있고, b객체에 2:1이 있다면, a-b에는 2:2가 들어가게 된다.\nNamed Tuple 개요: named tuple이 나온 배경 class Coords3D: def __init__(self, x, y, z): self._x = x self._y = y self._z = z @property def x(self): return self._x @property def y(self): return self._y @property def z(self): return self._z named tuple이란건 data만을 담기 위한 class라고 한다. 위의 예를 보면, class를 만들었다. 이 class에는 x,y,z값을 저장하고 별다른 method가 없다. 즉 하나의 instance는 하나의 3d 좌표값만을 갖는 class다. 한번 생성된 3d값은 수정은 안되고, @property를 통해서 각각의 값을 꺼내서 보거나, 사용할 수 는 있지만, 새 값을 넣는건 안된다. 아래 property를 사용하는 예다.\ncoord = Coords3D(1,2,3) print(coord.x) print(coord.y) print(coord.z) 이런 class를 만들 수도 있지, 난 대수롭지 않다고 생각한다. 그런데, 이런 간단한 구조인데 굳이 class를 만들 필요가 있냐?라는 사람들이 있다고 한다. 그사람들이 말하는 것은 data만 저장하는 값인데, 값을 꺼내기 위해서 @property를 사용한 getter함수를 모두 작성해야 하고, 같은형태의 많은 data값을 저장하는 것도 아니기 때문에 굳이 이렇게 만들어서 써야하느냐는 사람들이 있다. 그런 사람들은 3d좌표값을 나타낸다면, tuple을 사용하면 되지.라고 말한다.\ncoords3d = (10,20,30) print(coords3d[0]) print(coords3d[1]) print(coords3d[2]) 위와 같이 tuple을 사용하면, class를 사용한 것과 별차이 없다. class를 사용했을때는 x,y,z와 같이 좌표값을 인식할 수 있는 변수를 사용했기때문에 coords.x, coords.y, coords.z 처럼 가독성은 더 좋지만, 기능은 별다른 점이 없기 때문이다.\nnamed tuple의 사용 위의 tuple을 사용하면, index로 접근하기 때문에 가독성이 안좋았다. 이 단점을 없애기 위해서 named tuple이란 자료구조를 사용한다.\nfrom collections import namedtuple Coords3D = namedtuple(\u0026#34;Coords3D\u0026#34;, [\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;z\u0026#39;]) point = Coords3D(10,20,z=30) print(point.x) print(point[1]) print(*point) # point[1] += 1 error 발생 namedtuple은 이름이 암시하듯 tuple의 item에 이름 붙이기가 가능하다. 이것의 생성방식이 좀 특이한데, 다음을 보자.\nCoords3D = namedtuple(\u0026#34;Coords3D\u0026#34;, [\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;z\u0026#39;]) 첫번째 인자로 type(class) 이름이 들어간다. 그리고 두번째 인자로 item의 이름이다. type이름이 들어간다는것은 우리가 class로 coords3d라는 class를 만들었듯이, namedtuple도 내부적으로 class를 만든다는 것을 의미한다. 이렇게 만들어진 type의 instance를 만들어사 사용한다. 이것의 장점은 여러종류의 tuple을 만들고, class 이름도 마음대로 정할수 있다는 것이다. 사용법을 살펴보자.\n만들어진 Coord3D instance인 point는 name으로도 접근 가능하고 indexing으로도 가능하다. 한가지 특이한것은 point객체는 tuple이기 때문에 point라는 tuple이 가진 내용을 unpacking해서 보여줄 수 있다는 것이다.\nprint(*point) tuple은 immutable하기 때문에 값을 변경시키는 += 연산자는 에러를 발생한다.\nDataclass의 사용 개요 위에서 data만을 저장하는 경우가 있었다. 예를들면, 3d좌표값 같은 경우가 있었다. 3개의 좌표값을 갖는 data structure를 위해서, 처음에는 class를 만들었다. class를 사용하기엔 너무 거창해서, 그냥 tuple을 사용하려 했으나 가독성이 안좋아서 namedtuple을 배웠고 이를 사용할 수도 있었다. 근데 처음에 정의한 class처럼 비슷한 용도로 사용할 수 있는 dataclass라는게 있다고 한다.\n사용법 from dataclasses import dataclass @dataclass class Coords3D: x: float y: float z: float = 0 def norm(self) -\u0026gt; float: return (self.x ** 2 + self.y ** 2 + self.z **2) ** .5 point = Coords3D(10,20,z=30) print(point) print(point.norm()) Data만을 저장하기 위해서 우리가 만들었던 class를 다시 한번 보자.\nclass Coords3D: def __init__(self, x, y, z): self._x = x self._y = y self._z = z @property def x(self): return self._x @property def y(self): return self._y @property def z(self): return self._z @dataclass라는게 class에 붙게되면, 형식이 좀 다르다. 일반적인 class를 작성할때는 init()도 정의해야 했고, 값을 꺼낼수 있도록 @property라는 decorator를 구현해야 했다. 그런데, @dataclass는 이 과정을 다 없앴다. 즉 class의 내부변수 x,y,z만 정의하면 된다. 나머지 instance.x, instance.y, instance.z로 해서 값을 접근하게 해주는 @property로 함수를 정의하는것은 해주지 않아도 된다. dataclass로 만들어진 instance는 instance를 출력할 수 있는 str()가 재정의되어 있는듯하다. 그래서 print()로 출력할때 나름 이쁘게 보여진다고 한다. 그런데 그냥 객체의 요소를 보여줄 뿐 예쁘다는 생각은 들지 않았다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture9-advanced-data-structure\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/webcrawler1\/": {
        "title": "web scraping1",
        "tags": [],
        "content": "개요 Figure 1: web scraping book\n집에 돌아다니는 읽어보지 않은 책이 있다. 라이언 미첼이라는 사람이 쓴 건데, web scraping 그리고 web crawling에 관한 책이다. 한번 읽어 보고 정리하기로 한다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/webcrawler1\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture2_variable_and_operator\/": {
        "title": "lecture2_variable_and_operator",
        "tags": [],
        "content": "[lecture2] variable \u0026amp; operator 변수와 assignment 변수는 lisp에선 symbol이라고 부르고, 모든 symbol은 동일한 형태의 structure를 가졌다. symbol의 이름은 unique했다. symbol의 이름은 address였기 때문이다. 하지만, python에서 변수는 type이 가리키는 structure를 갖는다. 모두 동일한 모양이 아니다. 변수의 이름은 unique한건 마찬가지 인 듯 하다. address이기 때문이다. 변수와 assignment의 예 1 example\n(1) a = 15 (2) b = a (3) b print(b) interpreter가 이것을 어떻게 해석할까?\n(1) 과정\nlvalue인 a를 보고 symbol table에서 찾는다. 없다면 a라는 이름을 새로 만든다.\nrvalue인 15를 본다.\n=(assignment)를 실행한다. rvalue의 type이 int라는 것을 알고 int객체를 만든다.\nint객체의 value에 15를 집어넣는다.\nint객체의 name에 a를 집어넣는다.\n이렇게 해서 하나의 객체를 만들었다. (2) 과정\nlvalue인 b를 보고 symbol table에서 찾는다. 없다면 b라는 이름을 만든다.\nrvalue인 a를 보고 symbol table에서 찾아서 a를 꺼낸다. 없으면 error가 발생된다.\n=(assignment)를 실행한다. int객체를 만들고, value로는 a값을 , name이 b인 객체를 만든다.\npython interpreter가 객체의 value를 꺼낸다. 즉 eval한다.\n즉 assignment의 역할이 무엇일까?\n객체를 만드는 것이 아닌가? 즉 interpreter는 = 을 보고, rvalue와 lvalue를 보고 객체를 만들어야 한다는 걸 안다. 그러나 무조건 객체를 만드는 것은 아니다. lvalue를 보고, 해당 symbol이 symbol table에 있는지 여부를 확인한다. 없다면 객체를 만들려고 한다. 만일 있다면, immutable인지 mutable인지 확인한다. 만일 mutable이라면, 새로운 객체를 만들지 않고 update한다. immutable이라면, 새로운 객체를 만든다. 이제 rvalue 살펴본다. rvalue의 type을 확인하고 그 type에 맞는 객체를 만든다. 위의 예를 보면, a = 15에서 a가 symbol table에 없기 때문에, 객체를 생성해야 한다고 본다. 그리고 rvalue를 보고 int type임을 알수 있기 때문에 int객체를 만드는 것이다. 객체를 만든후 name과 value에 값을 assign한다. 그리고 만든 객체의 value는 rvalue인 15를 가리고 name은 lvalue인 a를 가리킨다. 변수와 assignment의 예2 example2 a = b = 2 뒤에서부터 처리한다. 즉 name이 b, value가 2인 int객체를 만든다. 그 다음 name이 2 value가 b를 가리키는 또 다른 int 객체를 만든다. literal object에 대해서 3이나 5와같은 값도 객체다 literal object이다. 예를 들어서, 아래와 같은 것이 가능하다.\n4.0.real or (4).real 4.0은 float객체가 만들어진 후 real이란 float의 method가 수행되는 것이다.\n나는 lisp의 symbol과 비슷하다는 가정아래 해석한다.\nFigure 1: lisp의 symbol1\nliteral 객체의 assignment는 새로운 객체를 생성하고 객체의 value가 literal object를 가리키는게 아니라 value의 값으로 들어가는거 같다. 예를 들면 a =3의 경우, 새로운 객체가 만들어지고 객체의 value로 3이란 객체를 가리키는게 아니라 3값이 직접 새로운 객체의 value가 되는 것 같다.\nname(변수)와 assignment의 특징 숫자로 변수명을 시작할 수 없다. 대소문자를 구별한다. assignment의 특징 assignment는 return값이 없다. 그래서 함수형 언어에서는 권장하지 않는다. 예를 들어, (a = 2) == 2 이것은 syntax error를 발생한다. a와 2를 갖는 객체를 만들지만, 그 객체를 return하지 않기 때문에 비교할 수 없다. 그런데, python에선, 객체를 return하게 할 수도 있다. 아래를 보자.\n(a := 2) == 2 이것은 어떻게 해석할 것인가? name이 a이고 value가 2인 객체를 return한다. ==은 rvalue, lvalue의 객체의 value를 비교한다.\nprimitive data types data type을 알아야 하는 이유는 한 가지다. 객체를 만들때, data type에 맞는 객체를 만들기 때문이다. 그리고 type에서 제공하는 method와 member variable을 사용할 수 있기 때문이다. numerals int,float,complex double은 없다. float가 double과 같다고 보면 된다. example float: 1.7, -5.7, 4.67e-3, 3e5 complex: 1+8j, 1.6+8j string string char type은 없다. example \u0026#39;text\u0026#39;, \u0026#34;한글\u0026#34; boolean bool example True, False None 일종의 null, example None 연산자 (operator) python이 객체 지향적 언어라고 하는데, 객체의 method를 사용하는게 아니라, 객체와 객체 사이에 operator를 넣어서 연산하는게 이상해 보일 수 있다. 그러나, operator는 method로 변환이 된다. 다음을 참조 하자. 참조:https://www.pythonmorsels.com/everything-is-an-object/#manually-calling-dunder-methods 즉, 연산자는 어떻게 보면, 모든 객체에 내장된 멤버 함수로 봐도 된다. Object 객체의 멤버 함수로 보는게 더 정확할 듯 하다. 연산자의 종류 arithematic operator\n(덧셈), - (뻴셈) , *(곱셈) , **(거듭제곱), /(몫) , //(몫,정수), %(나머지) bit operator\n~(NOT): 이게 좀 계산법이 황당한데, 우선, 2진수로 변환한다. 그리고 앞에 0을 붙인다. 양수이니까, 예를 들어, 5 =\u0026gt; 101 =\u0026gt; 0101 그리고, ~연산을 적용한다. ~연산은 1010이다. 이게 답이다. 그런데, 여기서 1을 빼주고 1의 보수를 취해서 값을 도출한다. 즉 1010에서 1을 빼서 1001이 되고, 여기서 1의 보수를 취해 0110이 나오는데, 원래 msb가 1이였기 때문에 -6값이 되는 것이다. | (OR): 2진수로 변환한 후 or연산을 하면 된다. \u0026amp; (AND): 2진수로 변환한 후 and연산을 한다. ^ (XOR): 같으면 0, 다르면 1로 계산한다. \u0026lt;\u0026lt;, \u0026gt;\u0026gt; : shift연산은 곱셈과 나눗셈이 된다. 축약 가능\nexample (1) a = a + 1 =\u0026gt; (2) a += 1 두 식은 약간 다른 의미를 갖는다고 한다. in-place하고 out-place의 개념을 설명한다. 둘다 assignment문이라서 object를 만들거라고 생각하지만, (1)은 out-place라서 새로운 객체를 만들지만, (2)는 in-place라서 기존 객체의 값을 update 시도를 먼저 하고 안될 경우 새로운 객체를 만든다고 한다. bit 연산자도 축약에 사용할 수 있다. a = 7 (1) a = a ^ 4 (2) a ^= 4 비교 연산자\nx \u0026lt; y x \u0026gt; y x \u0026lt;= y x \u0026gt;= y x == y : x,y value가 같다. x is y : x,y 주소가 같다. x != y : x, y value가 다르다. x is not y: x,y 주소가 다르다. x in X : x가 X에 포함된다. x not in X : x가 X에 포함되지 않는다. boolean operator\noperand가 boolean type일때 수행한다. bit operator는 operand가 arithematic이다. not AND OR operator priority\n기본적으로 산술연산자 \u0026gt; bit연산자 \u0026gt; 비교연산자 \u0026gt; 논리연산자의 순이다. mutable vs immutable primitive data type은 값을 변경할 수 없는 immutable이다. example1\nexample\n(1) a = 10 (2) b = a (3) a += 1 (4) a, b, a is b python interpreter는 a = 10을 본다. 우선, lvalue인 a에 대해서 symbol table에서 확인한다. 없다. 그리고 rvalue를 본다. int type이란 것을 알기에 int객체를 만들고, name과 value를 설정한다. python interpreter는 b = a를 본다. lvalue인 b가 symbol table에 있는지 확인한다. 없다. rvalue인 a를 본다. symbol table에 있다. 해당 객체의 type정보만 가지고 온다. int다. 이제 객체를 만든다. b라는 이름과 a라는 값을 갖는 객체를 만들었다. python interpreter는 a += 1을 본다. lvalue인 a를 symbol table에서 찾는다. a는 10의 값을 가지고 있는 immutable한 객체다. rvalue를 본다. a가 가진 값과 1을 더해 11이란 값을 만든다. 이제 객체를 만들어야 하는데, lvalue가 immutable하기 때문에 update할 수 없다. 새로운 객체를 만든다.a라는 새로운 객체를 만든다. 그러면 기존 a객체가 갱신된다. 여기서 확인해야 할 것은 b의 value다. b의 value는 a인것인가? 아니면, a가 가진 값인가? 지금 봤을때는 a가 가진 address인거 같다. 그래서 (3)까지 출력했을 때, a값은 새로운 객체의 11값을 가지고, b의 경우는 옛날 객체인 a의 값인 10을 갖는다. 새로운 a객체를 가르키지 않는다. 그리고 a is b는 false다. is라는 함수는 a와 b의 값을 가져오기 때문이다. example2\n(1) a = [1,2,3] (2) b = a (3) a += [4] (4) a, b, a is b python interpreter는 a = [1,2,3]을 본다. lvalue를 보고 symbol table에서 a를 찾는다. a는 없다. rvalue를 본다. [1,2,3]이다. eval할 필요가 없다. 이제 객체를 만든다, name,value를 연결한다. python interpreter는 b = a를 본다. lvalue의 b를 symbol table에서 찾는다. 없다. rvalue의 a의 type을 확인한다. list다. list객체를 만들고,이름과 value를 연결한다. 여기서 list객체를 만드는지는 잘 모르겠다. python interpreter는 a += [4]를 본다. lvalue인 a를 본다. symbol table에 있다. type을 보니 list다. 즉 mutable하다. rvalue를 본다.a +[4]를 계산하자. a의 value인 [1,2,3]의 append를 사용해서 [4]를 추가한다. [1,2,3,4]의 값이 나왔다. 이제 여기서 객체를 만드는것이 아닌 a객체의 value를 update한다. a의 값은 [1,2,3,4]이고, b도 [1,2,3,4]이다. a is b는 True가 된다. example3\na = [1,2,3,4] b = a a = a + [5] a,b, a si b In-place operator에 대해서 a +=1과 a= a+1의 차이: assignment와 operator의 차이 python에서 모든 것은 객체다. 그리고 모든 function은 어떤 객체의 method다. 그런데, 위에서 봤던 operator들은 method의 모양을 하고 있지 않다. 그럼 operator라는 것은 무엇인가? 본질은 method다. 즉, member method이다. 이것은 여기 에서 확인할 수있다. 이제 a += 1과 a = a+1에 대해 말해보자. a += 1에서 +=는 operator임을 알수 있다. member function, 즉 method라는것은 해당 객체의 값을 변경, update를 한다. 그런데 a 객체는 immutable이다. integer literal이기 때문에 값을 변경하지 못한다. 그래서 새로운 객체를 만들어낸다. 만일 a가 list와 같은 mutable한 객체라면, 그 값은 변경이 될 것이다. 그리고 a = a + 1의 경우는 assignment다. 즉, 새로운 객체를 만들어 내는 것이다.\nexamples\nexample1\na = 10 b = a a += 1 print(a) print(b) print(a is b) example2\na = 10 b = a a = a + 1 print(a) print(b) print(a is b) example2\na = [1,2,3,4] b = a a += [5] print(a) print(b) print(a is b) example2\na = [1,2,3,4] b = a a = a + [5] print(a) print(b) print(a is b) == 과 is ==는 값을 비교, is는 객체의 이름(주소)를 비교\nexample1\n아래는 False가 나와야 정답인데, 이상하게 True가 나온다. a = 13453436 b = 13453436 print (a is b) 아래는 True가 나온다. a = 13453436 b = 13453436 print (a == b) example2\n이것도 제대로된 결과가 나오지 않는다. True,True,False,True가 정답이라고 한다. print(b is \u0026rsquo;long-long-text\u0026rsquo;) 이 왜 false가 나오는지 모르겠다. a = \u0026#39;text\u0026#39; b = \u0026#39;long-long-text\u0026#39; print(a is \u0026#39;text\u0026#39;) print(a == \u0026#39;text\u0026#39;) print(b is \u0026#39;long-long-text\u0026#39;) print(b == \u0026#39;long-long-text\u0026#39;) example3\na = True print(a is True) example4\na = None print(a is None) Dynamic typing type을 명시하지 않고, assign할 때, rvalue를 보고 type이 정해진다. implicit type conversion bool -\u0026gt; int -\u0026gt; float -\u0026gt; complex bool type은 int type으로 conversion이 가능하고, int는 float로 conversion이 가능하다.\na = True a = a + 2 print(a) a = a + 1.5 print(a) python interpreter가 a = True를 보고, Boolean 객체를 만들고, 객체에 a라는 이름과 True라는 값을 맵핑한다.\npython이 a = a + 2를 본다. lvalue인 a를 symbol table에서 찾는다. 있다. rvalue를 계산한다. a의 value는 True이고, 2라는 값이 넘어온다. 이때 boolean객체의 overriding된 + method가 True와 2라는 값을 더해서 어떤일을 하는지는 정확히 모르겠다. 여튼 더하면 3이란 값이 계산되고, assign을 적용해서, int객체를 만들고 a의 이름과 3이란 값을 갖게 된다.\npython interpreter가 a = a + 1.5를 보고 위의 과정과 비슷한 과정을 거치게 된다.\nexample2 형변환이 안된다.\na = 1 a + None a + \u0026#39;text\u0026#39; explicit type conversion complex를 float로, float를 int로, int를 str로 형변환을 할수 있다. 이것은 강제 형변환을 해야 한다. example a = 12345 float(a) complex(a) str(a) bool(a) bool의 경우는 none,[],{} 등은 false값을 갖는다. 형변환의 또다른 예 print(int(75.75)) print(str(75.75)) print(bool(\u0026#39;True\u0026#39;)) 소수점 처리 방식 소수점 버림: int(75.75) 소수점 반올림: round(75.75), object의 method. 소수점 올림: math.ceil type checking type이라는 method를 사용한다. 아무래도 object의 method인거 같다. isinstance는 predicate이다. example a = 123 type(a) isinstance(a,float) ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture2_variable_and_operator\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/linear_algebra1\/": {
        "title": "linear_algebra1",
        "tags": [],
        "content": "linear algebra에 대한 생각 인과 관계(causation)와 상관관계(correlation) 어떤 변수와 다른 어떤 변수와의 연관성이 있을때 relation이 있다고 한다. 예를 들어, x가 증가하면 y도 증가한다던지 혹은 x가 증가하면 y가 감소한다. x가 감소하면 y는 증가한다. 등등. 이런 관계를 영어로는 좀 더 명확하게 표현할 수 있는것 같다. 예를 들면, describe variables in terms of one another. 여튼 이런 관계는 수학적으로 표현할 수 있다. 인문학 분야에서도 이런 관계를 표현하는데, 좀 다르다. 인간관계, 상관관계와 같이 구분해서 표현하는데, 이것은 관계를 어떻게 해석하느냐의 문제다. 수학적으로는 어떤 변수의 값이 다른 변수의 값에 영향을 미치는 relation일 뿐이다.\nrelation과 수학적 표현 relation은 집합으로 표현할 수도 있고 1차방정식, 2차방정식, function으로도 relation으로 나타낼 수도 있다. 여튼 이렇게 수학적으로 나타낸 relation은 일종의 법칙과 같다. 예를 들어, 온도가 높아지면 아이스크림 판매량이 늘어난다.를 수학적으로 y = 3x +5처럼 나타낼 수 있다. 이렇게 수식으로 정의되면, 어떤 온도를 x에 집어넣으면 얼마만큼의 아이스크림이 판매될지 예측할 수 있다. 우리가 원하는건, 방정식을 만들고, data를 집어넣어서 예측을 하는 데 있다. 그럼 어떻게 방정식을 만들 수 있을까? data가 있다면 방정식을 만들 수가 있다.\n관계, 예측, data, 방정식 어떤 feature끼리의 관계가 있다면, 그 관계를 방정식으로 만들 수 있다면, 우리는 방정식을 통하여 어떤 data도 예측할 수 있다. 방정식을 만드는 방법은 data로 만든다.\ndata로 방정식 만들기 참조:https://pydata.tistory.com/29 intended: 온도가 올라갈때 마다 아이스크림 판매량을 예측하는 기계를 만들고 싶다. 매일 온도를 측정하고, 판매량을 기록했다. 이 data를 바탕으로 온도에 따라 아이스크림 판매량을 예측하는 기계를 만들고 싶다.\n온도 -4 -3 -2 -1 0 1 2 3 4 아이스크림 판매량 -6 -4 -2 0 2 4 6 8 10 보기 좋게 세로로 변경하자.\n온도 아이스크림 판매량 -4 -6 -3 -4 -2 -2 -1 0 0 2 1 4 2 6 3 8 4 10 이 data를 통해서 온도에 따른 아이스크림 판매량을 예측하는 기계를 만드는 가장 간단한 방법은 방정식을 만드는 것이다. 예를 들면 x를 온도, y를 판매량으로 하는 1차 방정식을 만드는 것이다. x와 y사이에 어떤 관계가 있다는 확신이 들기 때문이다. 그런데 반드시 1차 방정식이여야 하나? nonlinear한 2차방정식이나, 삼각함수나, 다른 방식을 사용할 수 없는가? 물론 있다. x와 y의 관계가 2차방정식의 모양을 가질 수도 있다.우선은 가장 간단한 1차방정식으로 이러한 기계를 만들 수 있는지 확인해 보자. 1차방정식은 모두 비슷한 모양이다. y = mx +b 라는 방정식의 모양이다. 여기서 우리가 방정식을 만들기 위해서는, m과 b를 구해야 한다. 그래야 y=mx+b라는 기계를 만들고, 임의의 온도를 x에 넣었을 때 판매량을 알 수 있기 때문이다.\nm = \\(\\frac{\\Delta y}{\\Delta x}\\), b =\u0026gt; what goes with x = 0\nm을 생각해보면, x가 1씩 증가할 때 y의 증가량이다. 직관적으로 봤을때 값은 2씩 증가하는 것을 볼 수 있다. 따라서 m은 2로 할 수 있다. y = 2x +b에서 b값을 찾아 보자. b는 x가 0으로 갈때, y값이다. 따라서 방정식은 y = 2x + 2가 된다. 그런데 실제 data를 가지고 1차방정식을 만족하는 m과 b를 구할 수 있을까? 거의 없다고 본다. data의 row가 많아질수록 이렇게 딱 떨어지는 기계는 만들 수 없다.\n이것에 대한 생각은 나중에 하고, 우리는 data를 통해서 방정식에 필요한 x의 계수 m과 y의 절편 b를 찾을 수 있음을 보였다. 물론 이렇게 딱 떨어지게 구하는 경우는 거의없다. 그런데, 다른 경우를 생각해 보자. 만일 판매량에 영향을 미치는 요소가 온도만 있는게 아니라, 습도, 해가 떠있는지 유무,등등\u0026hellip; 데이터의 x에 해당하던 온도뿐 아니라, A,B,C,D,\u0026hellip;X까지 24개의 종류가 있다면, 우리는 데이터로 부터 각각의 계수 24개를 구해야 한다. 어떻게 할 것인가? 또한 첫번째 예는 운이 좋아서 구했지만, row가 엄청많다면 더 힘들 것이다. 어떻게 구해야 할지 머리속에 떠오르지 않는다.\n이 때 필요한게 linear algebra다.\nlinear algebra를 설명하기 전에, 우리가 한것을 다시 overview해보자. 우리는 data로 방정식을 만들고, 만든 방정식에 임의의 온도를 넣었을때, 판매량을 예측할 수 있는 machine을 만드는 것이다. 이것을 비유하면, 마치 음식재료와 요리를 가지고 기계를 만들고, 그 기계에 음식재료를 넣는다면, 요리를 만들수 있다는 것과 비슷하다. 다시한번 말하면, X는 음식재료, Y를 음식이라고 하면, 그 정보를 가지고 음식만드는 기계를 만들고, 다른 재료를 넣더라도 비슷한 음식이 나오게 되는 것이다. 우리가 만드는 방정식은 기계다. linear machine이라고 할 수도 있다.\n결론은 우리가 원하는 기계는 여러가지 feature와 결과의 관계로 만들어진다. data로 부터 각각의 feature의 계수를 구하는데 있어 linear algebra를 사용할 수 있다는것만 알아두자.\n왜 linear Algebra인가? Non-linear algebra는 안되는가? 위의 예에서 보면, 2개의 변수를 갖는 경우나 3개의 변수를 갖는 경우나 모두 값이 실수값 하나다.그런데 값이 실수값이 아닌, 다른형태라면, 그것은 non-linear가 될수 있다고 본다.아래에 그것과 관련한 질문을 한적이 있다.\n왜 기계는 정해져 있는가? data가 주어지면, 우리는 기계를 만들고, 만든 기계로 예측을 한다고 했다. 그런데 주어진 data로 만드는 기계의 형태는 정해져 있다. linear machine이다. Y= AX + BY + CZ의 형태다. 여튼 우리는 지금 linear한 기계만 생각한다.\n[강의 시작-1] Scalar, Vector, and Matrix Scalar: 하나의 수를 나타낸다. s \\(\\in\\mathbb{R}^1\\) : 그 수를 s라 할때, 이와같이 표시할 수 있다. \\(\\mathbb{R}\\) 이 실수를 나타내는 집합이기 때문이다. vector: ordered list of number다. x = \\(\\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ \\vdots \\\\ x_n \\end{bmatrix} \\in \\mathbb{R}^n\\) , 여기서 vector는 n차원이다. \\(\\mathbb{R}^n\\) 은 실수를 나타내는 집합R이 n번 곱해진다는 얘기인가? n은 row의 개수를 말하는 거 같다. matrix: 2차원 array다. \\(A = \\begin{bmatrix} 1 \\ 6 \\\\ 3 \\ 4 \\\\ 5 \\ 2 \\end{bmatrix} \\in \\mathbb{R}^{3x2}\\) 3x2는 row의 개수와 column의 개수를 말하는 거 같다. matrix를 vector로 생각(column vector와 row vector) column: 원기둥 vector를 column vector라고도 부른다. 왜 column이란 이름이 붙였냐 하면, matrix를 볼때, matrix의 column이 vector모양이고, matrix는 column형태의 vector로 구성되었다고 생각했다. 모양을 보면, matrix는 column에 해당하는 vector로 분해될 수 있어 보인다. 그래서, matrix에서 vertical column을 column vector라고 불렀다. row vector란건 원래 없었다. vector는 column형태이기 때문이다. 그런데 column vector를 transpose연산을 하면 row vector matrix의 성분들을 vector로 나눌 수 있기 때문에,row vector란 말이 생겼다. vector를 matrix로 생각. matrix를 vector로 보면, column vector가 합쳐진것, 혹은 row vector가 합쳐진 것으로 볼 수도 있다. vector를 matrix로 볼수도 있다. \\(x = \\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\\\ \\vdots \\\\ x_{n} \\end{bmatrix} \\in \\mathbb{R}^n = \\mathbb{R}^{n x 1}\\) 위에 처럼 vector를 n개의 row와 1개의 column인 matrix로 표시할 수도 있다. 그럼 row vector도 마찬가지로 아래와 같이 표시할 수 있다. \\(x = \\begin{bmatrix} x_{1} \\ x_{2} \\ x_{3} \\end{bmatrix} \\in \\mathbb{R}^n = \\mathbb{R}^{1 x 3}\\) 즉 1개의 row와 3개의 column을 가진 matrix로 표시할 수 있다. Transpose 연산 row vector와 transpose 원래 row vector는 없었다. vector는 column의 모양을 하고 있었기 때문이다. 그런데, column형태의 vector를 row vector형태로 사용할 일은 많았다. 그래서 Transpose라는 연산을 통해서 row vector를 만들어 사용했다. 지금도 마찬가지다. vector는 transpose해서 row vector로 사용한다. 예를 들면 다음과 같다. \\(X = \\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\\\ \\vdots \\\\ x_{n} \\end{bmatrix}^T = \\begin{bmatrix} x_{1} \\ x_{2} \\ x_{3} \\ldots \\x_{n} \\end{bmatrix} \\in \\mathbb{R}^{1 x n}\\) n x 1의 column vector를 transpose해서 1 x n의 row vector를 만든 것이다. transpose와 matrix vector를 row vector로 만들기 위해서 transpose연산을 취했지만, matrix도 transpose연산을 취할 수 있다.\n아래를 보자.\nA = \\(\\begin{bmatrix} 1 \\ 6 \\\\ 3 \\ 4 \\\\ 5 \\ 2 \\\\ \\end{bmatrix} \\in \\mathbb{R}^{3 X 2}\\)\nA = \\(\\begin{bmatrix} 1 \\ 6 \\\\ 3 \\ 4 \\\\ 5 \\ 2 \\\\ \\end{bmatrix}^{T}\\) =\u0026gt; \\(\\begin{bmatrix} 1 \\ 3 \\ 5 \\\\ 6 \\ 4 \\ 2 \\end{bmatrix}\\)\nA matrix는 2개의 column vector로 보면 된다. 첫번 째 column vector가 첫번 째 row vector로 transpose되고, 두번 째 column vector가 두번째 row vector가 된다.\nMatrix notations Square Matrix row와 column이 같은 matrix를 square matrix라고 부른다. 특별한 기호로 나타내진 않는다.\ne.g., B = \\(\\begin{bmatrix} 1 \\ 6 \\\\ 3 \\ 4 \\end{bmatrix}\\)\nRectangular Matrix row와 column이 같지 않은 matrix를 Rectangular Matrix로 부른다. 이것도 특별한 기호를 사용하지 않는다.\ne.g., A = \\(\\begin{bmatrix} 1 \\ 6 \\\\ 3 \\ 4 \\\\ 5 \\ 2 \\end{bmatrix}\\)\nTranspose연산자 기호 Transpose는 matrix 상단에 T를 표시해서 나타낸다.\ne.g., \\(A^{T}\\) = \\(\\begin{bmatrix} 1 \\ 3 \\ 5 \\\\ 6 \\ 4 \\ 2 \\end{bmatrix}\\)\ncomponent의 표시 Matrix의 하나의 원소를 지칭하는 방법, index는 1부터 시작한다. e.g., \\(\\textbf{A}_{ij}\\) , \\(\\textbf{A}_{21}\\) = 3\nmatrix에서 column vector와 row vector표시 row vector\nmatrix에서 row vector는 row를 지정하고 column을 :로 표시한다. 그리고 둘 사이 ,가 삽입된다. e.g.,\\(\\textbf{A}_{i,:}\\) \\(\\textbf{A}_{2,:} = \\begin{bmatrix} 3 \\ 4 \\end{bmatrix}\\)\ncolumn vector\nmatrix에서 column vector는 column을 지정하고 row를 :로 표시한다.그리고 둘 사이 ,가 삽입된다. e.g.,\\(\\textbf{A}_{:,j}\\) \\(\\textbf{A}_{:,2} = \\begin{bmatrix} 6 \\\\ 4 \\\\ 2 \\end{bmatrix}\\)\nsummary scalar가 무엇인지? vector가 무엇인지? matrix가 무엇인지를 배웠다. 어떤 응용에 있어서 그런 용어가 가진 역할이라던가 본질에 대한 의미라기 보다는 생김새, 모양 구조를 배웠다. 예를 들면, 숫자로 된 data가 낱개로 있을때는 scala, 어떤 구조로 organize되어 있으면, vector, matrix 용어로 부른다는 것이다. 아직까진 별다른 얘긴 없다.\n[강의 시작-2] vector/Matrix 덧셈 곱셈 위에서도 말했듯이 우리는 data로 1차원기계를 만들것이다. 수많은 음식재료가 나오기 때문에, 즉, 음식재료가 많기 때문에, matrix나 vector로 만들지 않으면 안된다. 데이터가 vector, matrix형태로 organize되어 있을때, 그것들을 가지고 어떤 처리, 계산을 할수 있어야 한다. 정확하게는 1차원기계의 계수와 절편을 계산해야 하기때문에 Matrix/vector에 대한 계산 방식을 알아야 한다. 그리고 vector는 계산에 있어서 matrix로 취급한다.\n덧셈과 뻴셈 addition 덧셈은 같은모양의 matrix끼리만 할 수 있다.\nscala 곱 그냥 scalar값을 더하거나 뺀다. 더하거나 빼도 같은 모양이 된다.\n내적(inner product, dot product) 내적을 계산하면, 앞 매트릭스의 column과 뒷 매트릭스의 row가 같아서 소멸되고, 앞의 매트릭스의 row와 뒤의 column으로 size가 정해진 매트리스가 새로 만들어진다. 예를 들어서, 100x30과 30x500의 matrix는 100 x 500의 matrix를 만들어 낸다. 내적은 matrix와 matrix를 곱해서 새로운 matrix를 만들어낸다는 것이다. 덧셈이나 scala곱은 기존의 matrix 크기를 변화시키지 않는다. 하지만, 내적은 다르다. 내적은 두개의 matrix를 기반으로 새로운 모양의 matrix로 만든다. 새로운 모양의 matrix가 기존의 matrix보다 클수도 작을수도 있다. 이럴땐 내적을 해야해!라던가 내적이 어떨땐 내적을 사용해! 뭐 이런건 나오지 않았다.\n내적은 not commutative. commutative라는 말은 교환법칙이다. AB \\(\\not=\\) BA. 강사는 3가지의 경우를 모두 예를 들어서 설명한다.\nAB는 계산이 되지만, BA가 계산이 안되는 경우 \\(A \\in \\mathbb{R}^{2X3}\\) 고 \\(B \\in \\mathbb{R}^{3X5}\\) 이면, \\(AB \\in \\mathbb{R}^{2X5}\\) 이지만, $BA$는 만들 수 없다.\nAB와 BA계산이 되지만, size가 안맞는경우 \\(A \\in \\mathbb{R}^{2X3}\\) 고 \\(B \\in \\mathbb{R}^{3X2}\\) 이면, \\(AB \\in \\mathbb{R}^{2X2}\\) 이지만, \\(BA \\in \\mathbb{R}^{3X3}\\) , 따라서, \\(AB \\neq BA\\).\nAB와 BA계산도 되고 size도 맞지만 계산이 다른 경우\neg., \\(\\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 4 \\end{bmatrix}\\) \\(\\begin{bmatrix} 5 \\ 6 \\\\ 7 \\ 8 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 19 \\ 22 \\\\ 43 \\ 50 \\end{bmatrix}\\)\n\\(\\begin{bmatrix} 5 \\ 6 \\\\ 7 \\ 8 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 4 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 23 \\ 34 \\\\ 31 \\ 46 \\end{bmatrix}\\)\n값이 다른것을 알 수 있다.\nother properties Distributive A(B+C) = AB + AC :commutative같은 경우 성립이 안되는 경우를 모두 보여주었다. 분배 법칙의 경우도 조건이 있는거 아닌가? A의 column과 B row 가 같아야 하고, A의 column과 C의 row가 같아야 만 저 식이 성립되는거 아닌가? 어째든 성립이 된다고 가정하면, 결과는 어떻게 될까? 성립이 되면,AB라는 매트릭스와 AC라는 매트릭스가 만들어지고 두 매트릭스가 size도 같다면, 하나의 매트릭스가 결과값으로 나올 것이다. 그러나 반드시 하나의 매트리스가 된다는 보장은 없다. AB + AC인 상태가 될 수있다.\nAssociative A(BC) = (AB)C Associative도 A의 column과 B의 row가 같으면 위 계산이 가능하다. 결합법칙은 괄호의 연산이 가능하다면 순차적으로 풀면된다. 내적으로 연결된 계산을 할땐 어떤순서로 해도 상관없다는 뜻이다.\nProperty of Transpose \\((AB)^{T} = B^{T}A^{T}\\) 내적의 transpose를 transpose의 내적으로 바꿀수도 있고, transpose로 된 matrix의 내적을 묶은후 transpose할 수 있다. transpose는 size의 경우 뒤바뀜이 일어나고 1st row가 1st column으로 이동한다.\n[강의시작 2-1] Linear System Linear System: 연립방정식과 그에 따른 연산을 포함한다. Linear system에선 여러개의 Linear Equation을 Matrix를 사용해서 풀수 있다.\nLinear Equation 이전에 말했듯이 우리가 Linear Algebra를 사용하는 이유는 요리재료와 음식이 주어질때, 이 정보를 가지고 Linear Equation이란 기계를 만든다고 했다. Linear Equation 기계의 형태는 대략적으로 정해져 있다. 왜냐면 Linear Algebra를 사용하기 때문이다. 우리는 위에서 음식재료가 하나일때는, 하나의 음식재료 가지고 y = ax +b라는 형태의 기계를 만든다고 했다. 그 기계를 만든다는 것은 a와 b를 구하는 것이라고 했다. 아래 표에서 보듯이 음식재료 X가 Y라는 음식이 주어지면 방정식의 계수와 절편을 푸는것이다.\nX -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 그리고 여러종류의 음식재료가 있을때는, 예를 들어 2개의 음식 재료 W,X가 있고, 만들려는 음식이 Y 일 때는,\nW -2 -1 -5 -1 0 5 3 7 1 X -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 Y = aW + k1꼴의 방정식과 Y = bX + k2이란 방정식을 둘다 만족시키는 계수(a,b)와 절편(k1,k2)을 찾아야 한다.\n음식재료가 3개일때도 보자.\nV -2 -1 -5 -1 0 5 3 7 1 W -2 -1 -5 -1 0 5 3 7 1 X -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 Y = aV +k1 라는 꼴의 기계, Y= bW +k2라는 기계, Y= cX +k3라는 기계를 모두 만족시키는 하나의 기계를 만들어야 한다. 최종기계는 어쩌면, Y = aV + k1 = b+ k2, Y = aV +bW + cX + k꼴의 기계의 a,b,c 그리고 k 절편을 구하는것일 지도 모른다.\nlinear algebra의 적용(linear system과 linear equation) linear system: set of linear equations,연립방정식을 뜻한다. 우리는 이 linear system을 풀면된다. 즉 여러개의 linear equation이 모인 linear system을 matrix, vector형태로 표시하고 이를 계산해서 각각의 linear equation의 계수와 절편을 구한다. 그러면 우리가 표를 사용해서 계수와 절편을 구하려고 equation을 만들었는데, 변수와 계수를 변경한다. 왜냐면 우리가 원하는건 계수였기 때문에 계수가 변수가 된다. 그리고 우리는 matrix형태로 data(table)을 표현할 수 있어야 한다. 그리고 절편은 없다고 생각하자. 식을 간단하게 하기 위해서이다. 우리에게 주어지는 것은 음식재료와 음식을 가지고 기계를 linear algebra 기계의 계수를 구해보자. 예를 들어 보자. 이건 강사의 예제다. 강사는 4가지 정보(data)를 바탕으로 얼마나 오래사는지를 예측하고 싶어한다. 우리는 linear machine을 만들어야 한다. 아래는 data다. 이것으로 linear machine을 만들어 보자.\nPerson_ID 1 2 3 Weight 60kg 65kg 55kg Height 5.5ft 5.0ft 6.0ft Is_smoking yes(=1) No(=0) Yes(=1) life-span 66 74 78 위 data를 가지고 linear machine(값을 예측하는 기계)을 만드는데는 process가 필요하다.\n위 data를 linear system으로 구성한다. linear system을 풀면 linear machine의 계수를 알수 있다. 계수만 알면 linear machine이 만들어 지는 것이다. linear system을 만들자. linear system은 linear equation으로 구성된다.linear equation으로 만들기 위해서 표를 transpose하자. transpose하면 matrix로 표현하기 쉽다.\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 3 55kg 6.0ft Yes(=1) 78 \\(60x_{1} + 5.5x_{2} + 1x_{3} = 66\\) \\(65x_{1} + 5.0x_{2} + 0x_{3} = 74\\) \\(55x_{1} + 6.0x_{2} + 1x_{3} = 78\\)\n이렇게 linear combination을 통해 linear system을 만들었다. 이제 matrix/vector형태로 만든다.\n\\(\\begin{bmatrix} 60 \\ 5.5 \\ 1 \\\\ 65 \\ 5.0 \\ 0 \\\\ 55 \\ 6.0 \\ 1\\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\end{bmatrix}\\) = \\(\\begin{bmatrix} 66 \\\\ 74 \\\\ 78 \\end{bmatrix}\\) 이렇게 보면 Ax = b의 형태다.\nmatrix는 대문자, vector는 소문자로 표시한다. 여기서 좀 tweak(조금 고치다;튜닝)을 하면, 아래와 같이 볼 수도 있다.\n\\(a^{T}_{1}x = 66\\) \\(a^{T}_{2}x = 74\\) \\(a^{T}_{3}x = 78\\)\n이제 여기까지하면 data를 가지고 linear system을 만들었다고 볼 수 있다.\nlinear system 풀기 prerequisite for solving linear system\nlinear system을 푼다는 것은 계수인 x vector를 구하는 것이다. 그런데 풀기위해선 행렬 계산법에 대해 몇가지 개념들을 알아야 한다. 그중 Identity matrix를 먼저 살펴보자.\nIdentity Matrix\n항등 행렬로 부른다. 항상 등식이 성립하는 matrix다. diagonal entry들이 모두 1인 square matrix다. I라고 표시하고 다음과 같이 size를 표시한다.\n\\(I_{n} \\in \\mathbb{R}^{n X n}\\)\ne.g., \\(I_{3}\\) = \\(\\begin{bmatrix} 1 \\ 0 \\ 0 \\\\ 0 \\ 1 \\ 0 \\\\ 0 \\ 0 \\ 1 \\end{bmatrix}\\)\n이 matrix의 특징은 이 matrix에 곱해지는 matrix의 결과는 자기자신이라는 것이다. 예를 들어보자.\ne.g., \\(\\begin{bmatrix} 1 \\ 0 \\ 0 \\\\ 0 \\ 1 \\ 0 \\\\ 0 \\ 0 \\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\end{bmatrix}\\) = \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\end{bmatrix}\\)\n3x3과 3x1로 3x1의 vector가 계산되지만, 그 vector가 자기자신임을 알 수 있다. vector도 matrix의 일종이다.\nInverse Matrix\nIdentity matrix를 통해서 Inverse Matrix의 개념이 생겼다고 한다. Inverse Matrix도 Identity matrix처럼 squared matrix다. 어떤 matrix가 있을 때, 그 matrix의 inverse matrix를 내적하면 자기 자신이 된다.\ninverse matrix\nsquare matrix \\(A \\in \\mathbb{R}^{n X n}\\) \\(A^{-1}A\\) = \\(AA^{-1}\\) = \\(I_{n}\\) 특이한 것은 \\(A^{-1}\\) 를 구할때, A와 I를 알고 있기 때문에, A와 I를 적당히 처리해서 구할 수 있을거라고 생각하지만, 구할 수 없다. 예를 들어 \\(AA^{-1}\\) = \\(I_{n}\\) 이니까, 양변에 \\(A^{-1}\\) 을 내적해서 구할수 있지 않을까 하고 생각하는데, 구할 수 없다. inverse matrix는 구하는 공식이 있다.\ne.g., \\(A\\) = \\(\\begin{bmatrix} a \\ b \\\\ c \\ d \\end{bmatrix}\\) 라 하자.\n\\(A^{-1}\\) = \\(\\frac{1}{ad - bc}\\) \\(\\begin{bmatrix} d \\ -b \\\\ -c \\ a \\end{bmatrix}\\)\ne.g., \\(A\\) = \\(\\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 4 \\end{bmatrix}\\) 라 하자. \\(A^{-1}\\) = \\(\\frac{1}{4 - 6}\\) \\(\\begin{bmatrix} 4 \\ -2 \\\\ -3 \\ 1 \\end{bmatrix}\\) = \\(\\begin{bmatrix} -2 \\ 1 \\\\ \\frac{3}{2} \\ - \\frac{1}{2} \\end{bmatrix}\\)\n즉, A에서 ad-bc를 계산한 후, diagonal의 component들을 바꿔주고 나머지는 -값을 해준다.\n여기서 한가지 특이한건, matrix는 transitive하지 않다고 했다. 즉 교환법칙이 성립하지 않는다. AB와 BA는 같지 않았다. 하지만, A와 A의 역행렬은 교환법칙이 성립하는 것을 볼 수 있다.\nSolving linear system\n이제 linear system을 풀기 위한 준비가 되었다. data를 가지고 우리는 linear system을 만들었다. 그 구조는 다음과 같았다.\n\\(Ax = b\\)\n\\(\\begin{bmatrix} 60 \\ 5.5 \\ 1 \\\\ 65 \\ 5.0 \\ 0 \\\\ 55 \\ 6.0 \\ 1\\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\end{bmatrix}\\) = \\(\\begin{bmatrix} 66 \\\\ 74 \\\\ 78 \\end{bmatrix}\\)\n\\(Ax = b\\) 에서 계산을 위한 matrix인 Identity와 Inverse matrix를 사용해서 푼다. 풀이 과정은 다음과 같다.\n\\(Ax = b\\) \\(A^{-1}Ax = A^{-1}b\\) \\(I_{n}x = A^{-1}b\\) \\(x = A^{-1}b\\)\n이제 적용해 보자. 우리의 linear system에서 \\(A^{-1}\\) 을 구해보자.\n\\(A^{-1}\\) = \\(\\begin{bmatrix} 0.0870 \\ 0.0087 \\ -0.0870 \\\\ -1.1304 \\ 0.0870 \\ 1.1314 \\\\ 2.0000 \\ -1.0000 \\ - 1.0000 \\end{bmatrix}\\)\n이제 \\(x = A^{-1}b\\) 을 계산하면 된다.\n\\(x = A^{-1}b\\) = \\(\\begin{bmatrix} 0.0870 \\ 0.0087 \\ -0.0870 \\\\ -1.1304 \\ 0.0870 \\ 1.1314 \\\\ 2.0000 \\ -1.0000 \\ - 1.0000 \\end{bmatrix}\\) \\(\\begin{bmatrix} 66 \\\\ 74 \\\\ 78 \\end{bmatrix}\\) = \\(\\begin{bmatrix} -0.4 \\\\ 20 \\\\ -20 \\end{bmatrix}\\)\n이렇게 하면 linear system을 풀었다.\nlinear machine\n우리는 linear system을 계산해서 linear machine의 계수를 구했다. 이제 linear machine을 완성시키자.\nlinear machine coefficients = \\(\\begin{bmatrix} -0.4 \\\\ 20 \\\\ -20 \\end{bmatrix}\\)\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 3 55kg 6.0ft Yes(=1) 78 (life-span) = -0.4 x (Weight) + 20 x (Height) -20 x (Is_smoking)\nlinear system의 한계? rectangular matrix의 inverse matrix\nlinear system을 풀기 위해서, 우리는 Identity Matrix와 Inverse matrix를 배웠고 또 활용했다. 그런데 Identity matrix와 Inverse Matrix는 모두 square matrix다. Rectangular matrix는 역행렬이 존재하지 않는다. 그래서 위의 계산방식으로 사용할 수 없다. 그러면 linear system을 풀수 없다는 얘기인가? 그렇지 않다. 그것에 대한 얘기를 할것이다. 물론 programming상에선 알아서 구해주기 때문에 걱정하지 않아도 된다.\nNon-Invertable Matrix A for Ax = b 위에서 data를 가지고 linear machine을 만들었다. linear machine을 만드는 과정에서 역행렬을 사용했다. 그런데 역행렬을 만들 수 없는 경우가 있다. 이전에도 말했듯이 rectangular matrix도 역행렬을 만들 수 없다. 그런데 square matrix도 역행렬을 만들 수 없는 경우가 존재한다. 예를 들어보자.\neg., \\(A = \\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 6 \\end{bmatrix}\\)\n위 matrix는 square matrix이다. 그러나 ad-bc가 0이다. 따라서 역행렬이 존재하지 않는다. ad -bc를 계산하지 않아도, 위 matrix의 column vector는 한개 feature의 data다. 즉 2개 feature data라고 볼 수 있는데, 이 2개의 data가 같은 data로 볼 수 있다. 첫번 째 column에 2를 곱하면, 두번 째 column과 같아진다. 이런경우 역행렬을 구할 수 없다고 볼 수 있다.\n어떤 matrix가 주어졌을때, 역행렬이 존재하는지 안 하는지를 판별하는게 ad -bc가 0인지를 계산했는데, 이것을 A의 determinant라고 한다. 보통은 다음과 같이 표시한다.\n\\(det A\\)\n그러면, 3X3 matrix에서 determinant를 구할 수 있을까? 구할 수 있다. 4X4\u0026hellip;등등.. 강사는 그림으로 알켜줬지만, 난 여기에 적진 않겠다.\n역행렬 존재의 의미. linear system에서 data행렬이 3x3의 square행렬이고, 역행렬이 존재해서 linear machine의 계수를 구할 수 있었다. 그런데, 우리가 받는 data가 3개의 feature를 갖고, 3개의 값만 있지 않다. 정방행렬 형태의 data는 일부러 만든것이고, 실제는 rectangular data일 확률이 더 높다. 또한 정방행렬의 data가 주어진다고 해도 판별식이 0인경우가 많다. 판별식이 0이면 역행렬이 존재하지 않기 때문에 위의 방식으로 해를 구할 수가 없다. inverse matrix로 해를 구할수 없다고 해서, 해가 없다라고 말한다면, 그것은 맞는 것일까? 그렇지 않다. 정방행렬에서 판별식이 0인 경우는 해가 없을수도 있지만,해가 무수히 많을 수도 있기 때문이다. 아래 예를 보자.\neg., \\(\\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 6 \\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\end{bmatrix}\\) = \\(\\begin{bmatrix} 4 \\\\ 12 \\end{bmatrix}\\)\n위 matrix는 판별식(determinant)가 존재하지 않는다. ad-bc가 0이다. 따라서 inverse matrix가 존재하지 않는다.그러면 이 linear system의 해는 없는것인가? 아니면 해가 무수히 많은 것인가? 위 matrix 곱을 풀어서 보자.\n\\(x_{1} + 2x_{2} = 4\\) \\(3x_{1} + 6x_{2} = 12\\)\n두 equation들은 동일하다. 왜냐면 3을 윗방정식에 곱했을 때 같은 동일한 직선이기 때문이다. 우리가 해라고 말하는건 위에서 풀어쓴 두 직선의 교점을 얘기한다. 두직선의 교점은 무수히 많다. 따라서 matrix곱의 해는 무수히 많다. 즉 해는 무수히 많다.\n그럼, 해가 없는 경우를 살펴보자. 위 방정식을 그대로 이용하자.\n\\(x_{1} + 2x_{2} = 4\\) \\(3x_{1} + 6x_{2} = 13\\)\n이 경우도 판별식은 0이다. 따라서 역행렬로 해를 구할수는 없다. 따라서 matrix곱을 풀어써보자. 두개를 직선으로 본다면 동일한 직선이 아니다. 따라서 해가 무수히 많지도 않다. 판별식이 0이 아니고 역행렬이 있다면, unique한 해를 가질텐데 그렇지도 못하기 때문에, 따라서 이 경우는 해가 존재하지 않는다.\n강사는 2개의 video를 참조영상으로 제공했다. mit 선형대수 강좌 18,19다. 여기1 여기2 이게 무슨 의미인가? data를 사용해서 기계를 만들려고 할려면 matrix곱을 풀어야 한다. 그런데, matrix곱형태의 계산은 어렵다는 것이다. matrix곱 해결방법으로 흔히 쓰이는 inverse matrix로 양변에 곱해서 해결할려는 시도는 한계가 있다는 것이다. 첫번째 한계는 sqaure matrix만 역행렬이 존재한다는 점이다. 두번째 한계는 sqaure matrix라고 해도, 판별식이 0이 되는 경우, 역행렬을 양변에 곱해서 해를 구하는 계산은 할수 없다는 점이다. 세번째로, matrix의 크기가 커지면, 판별식 자체 계산이 힘들다는 것이다. 설사, 위의 세가지 경우를 벗어나, square matrix이고, 역행렬이 존재하고, 그리고 계산이 가능하다 할지라도, 해가 1개만 unique하는 경우만 답을 구할 뿐이다. 우리는 해가 한개인,unique한 해를가지고, 기계를 만들 수도 있지만, 해가 여러개 되는 경우에도 기계를 만들어야 하고, 혹은 해가 없는 경우에도 기계를 만들어야 한다. 따라서 우리는 square matrix에 구애 받지 않는 rectangular matrix곱의 해를 구하는 방법과, 해가 없는경우, 해가 무수히 많은 경우의 처리를 생각해야 한다.\nRectangular matrix의 계산 data를 제공 받아서,우리는 linear machine을 만든다고 했다. 그러기 위해선 linear machine의 coefficients가 필요했다. 이것이 matrix곱에서의 x벡터(가중치 벡터)를 의미한다. x벡터를 data로 부터 구했을때, 새로운 data의 예측이 가능했다. 그런데 matrix곱형태의 해를 구하는 계산이 역행렬을 곱하는 식으로는 안된다는 점과, 해가 없을때, 해가 무수히많을때를 해결해야 한다.\n우선 해를 따져보자. Rectangular한 data가 주어질때, rectangular matrix가 가진 모양의 특징이 있다. 모양에서 해의 개수를 예측가능하다는 것이다. m: 방정식수(data수) n:feature라고 했을때, 다음과 같이 일반적으로 예측할 수 있다.\nm \u0026lt; n : 보통은 해가 무수히 많다.\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 일반적인 얘기다. 100% 이렇다라고 말할 수는 없다. 여튼 이런 경우를 under-determined system이라고 부른다고 한다.\nm \u0026gt; n : 보통은 해가 없다.\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 3 55kg 6.2ft Yes(=1) 78 4 55kg 6.4ft Yes(=0) 78 5 55kg 6.0ft Yes(=1) 78 6 55kg 5.8ft Yes(=1) 78 이 경우도 일반적인 얘기다. 보통 해가 없는경우가 많고, over-determined system이라고 부른다.\noh my god! 나는 Rectangular matrix도 역행렬을 구하는 다른 방식이 있을 줄 알았다. 그런데 그 설명은 아직 없다. 해를 구하는 계산을 설명하기에 앞서서, 해가 1개인지, 해가 무수히 많은지 아니면 존재하지 않는지에 대해서 먼저 고민해야 한다.\n해가 unique하다는 것은 기계를 1대 만들수 있고, 그 기계로 예측을 할수 있기 때문에, 제일 좋은 케이스다. 그런데 해가 없다는 것은 data를 가지고 machine을 만들지 못한다는 얘기가 된다. 두번째 해가 무수히 많다는 얘기는 우리가 구할려는 x벡터가 어떤값을 가져도 상관없다는 얘기가 된다. x벡터(가중치벡터)가 1000개 2000개 존재할 수 있다는 얘기도 된다. 1000개 2000개 무한하게 많은 기계를 만들수 있다는거다. 그런데, 주어진 data에 대한 각각의 기계의 값은 동일하나, 새로운 data에 대한 각 기계마다 예측값이 다 다를 것이다. 이게 문제다. 그러면, 해가 없는 경우, 해가 많은 경우는 어떻게 해야 하나? 해가 없는경우, 기계를 만들 수 있는가? 어떻게 기계를 만들것인가? 해가 많은 경우, 어떤 기계를 선택할 것인가? 하는 문제가 있다.\nmachine learning과 deep learning은 이런 문제를 해결하기 위한 solution을 준다.\n해가 없는 경우를 보자. 예를들어 1000개의 equation을 모두 만족하는 해가 없다고 할때, 근사화된 해를 선정한다. 근사화된 해라는 것은 예를 들어, 어떤 계수들을 가질때, 결과오차율의 합이 제일 작다면, 그것을 해로 정한다.\n해가 무수히 많은 경우는 regularization이란 기법을 사용한다. regularization은 보통 risk management라고 부른다. 많은 해 중에서, 가장 risk가 적은 해를 선택하겠다는 것이다. 예를 들면, 아래의 표를 통해서 우리는 여러개의 해를 구했다고 치자.\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 해는 가중치라고 했다. weight, height, is_smoking에 대한 가중치 벡터가 해가된다. 이 해가 여러개 있다고 치자. 어떤해는 height에 150, 다른 어떤해는 20이라는 값을 갖는다면, 150의 가중치를 갖는다는것은 결과에 지대한 영향을 준다. 혹은 키에 민감한 반응을 보여주는 machine이라고 말할 수 있다. 우리는 해가 여러개 있는 경우, 하나를 선택하는 것이다. 이것에 대한 선택은 어떤 법칙은 없다. 다만 민감도(risk)를 따져서 선택할 뿐이다.\n내가 질문한 내용. 오피스아워에서 질문했던건데요. 해결되었습니다. 제가 말도 잘못하고, 잘 모르다보니 이상한 말을 많이 하게 되네요. 여튼 문제는 해결됐습니다.아래는 제가 생각했던,질문가졌던 내용과 배경을 말해봤습니다.\n[질문배경] 저는 우리가 하는게 수치data로 방정식과 같은 수학적 formula를 만들고, 만든 방정식에 수치data를 입력해서 값을 예측하는 모델을 만든다고 생각했습니다. 마치 음식재료와 요리를 넣어서 음식만드는 기계를 만든다고요. 그래서 간단한 표(data)에서 방정식을 만들어봤습니다. 1차방정식을 아래표에서 계산 하면, 기울기는 x의 증가량과 y의 증가량을 구해서 2를 구했고, y절편은 x가 0일때니까 2를 구했습니다. 그래서 y = 2x +2로 방정식을 만들었는데요.\nX -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 만일 음식재료가 많을 경우(아래와 같은표)는 위의방식대로 만들기 어렵다. 그래서 linear algebra를 사용한다고 생각했습니다.\nW -2 -1 -5 -1 0 5 3 7 1 X -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 그런데 여기서 생각한게 음식재료가 많아봤자(A, B, C \u0026hellip;W,X) 결국에는 Aa+Bb+Cc…와 같은 linear한 방정식만 만드는것 같아요. 여기서 non-linear한 방정식을 만드는 것은 없을까? 하다가 그러면 위에처럼 1차방정식을 data로 유도하듯이 2차방정식을 어떻게 유도하는지를 알고 싶었어요. 그런데 찾아보니 https://sciencing.com/quadratic-equations-table-10001169.html 이 방식이 있더라구요. 여기선 data가 ordered pair형식으로 되어 있더라구요. 그래서 table에 있는 data가 아래와 같은 형태로 되어 있다면 non linear하다고 생각했습니다.\nX (-4,2) ( -3,4) (-2,1) (5,-1) (0,2) (1,2) (2,3) (3,3) (4,4) Y -6 -4 -2 0 2 4 6 8 10 그런데 결론적으로 제가 잘못생각했습니다. 여기서 tuple의 모양은 의미가 없고, tuple을 vector로 생각해서 vector를 넣는 tensor로 non-linear처리가 가능하다는 강사선생님이 말씀하셨는데, 즉 저기의 tuple모양은 vector로 봐도 된다고 하신것과 다름없다고 생각됩니다. 그리고 한동훈님이 말씀하신 것도 일맥상통한거 같습니다. 즉 저기의 tuple모양이던 list모양이던 vector로 치환될 수 있다. 따라서 굳이 tuple같이 따질 필요가 없다. 이말이 맞는거 같습니다.\n여기서 또 질문 어떤 data가 있고, 그 data를 사용해서 방정식을 만들고, 만든 방식으로 예측한다. 그런데 왜 1차방정식만을 생각할까? 음식재료가 있고, 요리가 있을때, 서로간의 관계를 왜 1차 방정식기계만으로 한정하냐는 말이다. 다른 기계는 없을까? 2차방정식도 그중에 하나고, 다른형태의 기계도 만들 수 있는거 아닌가?\nX -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 여기서 또 질문 우리가 해야하는건 data가 주어지면, data로부터 기계를 만드는 것이다. 기계는 1차방정식의 형태다. 1차방정식은 여러 형태가 있지만, 음식재료가 A와 같다면, 우리는 y= Av+Bw+CX+D의 기계를 만들어야 한다. 그러면 어떻게 linear algebra를 사용해서 이런 기계를 만들 수 있을까? 그리고 data가 주어질때, A가 아닌 B의 형태로 주어졌을때, 동일한 data이지만 모양만 transpose한것이라면, 만들어지는 기계는 동일한 것인가? 라는 질문을 던질 수도 있다.\nV(음식재료) -2 -1 -5 -1 0 5 3 7 1 W(음식재료) -2 -1 -5 -1 0 5 3 7 1 X(음식재료) -4 -3 -2 -1 0 1 2 3 4 Y(음식) -6 -4 -2 0 2 4 6 8 10 W(음식재료) X(음식재료) Y(음식) -2 -4 -6 -1 -3 -4 -5 -2 -2 -1 -1 0 0 0 2 5 1 4 3 2 6 7 3 8 1 4 10 ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/linear_algebra1\/"
    },
    
 }
</script>


<script src="/js/lunr.min.js" type="text/javascript" charset="utf-8"></script>


<script src="/js/lunr.stemmer.support.js" type="text/javascript" charset="utf-8"></script>


<script src="/js/lunr.ko.js" type="text/javascript" charset="utf-8"></script>


<script src="/js/search.js" type="text/javascript" charset="utf-8"></script>
</body>
</html>
