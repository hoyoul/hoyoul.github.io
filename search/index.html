<!DOCTYPE html>
<html>
  <head><title>Search</title>


<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes" />

<link rel="shortcut icon" href="./img/favicon.ico" type="image/x-icon">
<link rel="icon" href="./img/favicon.ico" type="image/x-icon">    


<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/orgmode.css">
<link rel="stylesheet" href="/css/chroma.css">
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>
  <body><header>
  <a href="/" id="logo">
    <img src="https://braindump.frege2godel.me/img/mylogo.png" alt="holy frege">
    <h3><span>H</span>oly <span>F</span>rege's <span id="note">notes</span></h3>
  </a>
  <small>G.frege를 너무 사랑하는 holy가...</small>
  <div class="vertical_dotted_line"></div>
    <label>
      <input role="switch" type="checkbox" id="switch"/>
      <span>d3 off</span>
    </label><form id="search"
	  action='https://braindump.frege2godel.me/search/' method="get">  
  <input type="text" id="search-input" name="query"
	 placeholder="" autocomplete="on">
  <input type="submit" value="search">
</form>

</header>
   
<div class="container">
      <div class="page wide">
	<ul id="results">
	  <li>
            Enter a keyword above to search this site.
	  </li>
	</ul>
      </div>
    </div><script>
 graph_objects = []; 

 
     
     graph_node_object = {
        
     "label": "[matter.js] tutorial",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/matter_js_tutorial\/",
     "id": "matter_js_tutorial",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("matter_js_tutorial",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[node] npm and node",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/node_npm_and_node\/",
     "id": "node_npm_and_node",
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["matter_js_tutorial"]
   }
 sessionStorage.setItem("node_npm_and_node",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[git] git drill1 repo and commit",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/git_git_drill1_repo_and_commit\/",
     "id": "git_git_drill1_repo_and_commit",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("git_git_drill1_repo_and_commit",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[git] git drill2 local",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/git_git_drill2_local\/",
     "id": "git_git_drill2_local",
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["git_git_drill1_repo_and_commit"]
   }
 sessionStorage.setItem("git_git_drill2_local",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[sql] programmers sql high score",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/sql_programmers_sql_high_score\/",
     "id": "sql_programmers_sql_high_score",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("sql_programmers_sql_high_score",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[git] git explained",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/git_git_explained\/",
     "id": "git_git_explained",
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["git_git_drill1_repo_and_commit","elisp_korean_lorel_ipsum"]
   }
 sessionStorage.setItem("git_git_explained",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[emacs] presentation tools",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_presentation_tools\/",
     "id": "emacs_presentation_tools",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("emacs_presentation_tools",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[emacs] tex install and usage (latex)",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_tex_install_and_usage\/",
     "id": "emacs_tex_install_and_usage",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("emacs_tex_install_and_usage",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[emacs] mu4e settings",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_mu4e_settings\/",
     "id": "emacs_mu4e_settings",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("emacs_mu4e_settings",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[test] testing!",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/test_testing\/",
     "id": "test_testing",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("test_testing",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[essay] computer working principles",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/essay_computer_working_principles\/",
     "id": "essay_computer_working_principles",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("essay_computer_working_principles",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[pl] history of programming language from calcuation to OOP",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/pl_history_of_programming_language\/",
     "id": "pl_history_of_programming_language",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["python_grammar_in_one_shot"]
   }
 sessionStorage.setItem("pl_history_of_programming_language",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[python] grammar in one shot",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/python_grammar_in_one_shot\/",
     "id": "python_grammar_in_one_shot",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("python_grammar_in_one_shot",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[algorithm] thinking about algorithms",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/algorithm_thinking_about_algorithms\/",
     "id": "algorithm_thinking_about_algorithms",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("algorithm_thinking_about_algorithms",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[leetcode] 1672 Richest Customer Wealth",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/leetcode_1672_richest_customer_wealth\/",
     "id": "leetcode_1672_richest_customer_wealth",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["leetcode_beginning"]
   }
 sessionStorage.setItem("leetcode_1672_richest_customer_wealth",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "python_summary6 function",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary6_function\/",
     "id": "python_summary6_function",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("python_summary6_function",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "python_summary7 big data and python",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary7_big_data_and_python\/",
     "id": "python_summary7_big_data_and_python",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("python_summary7_big_data_and_python",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[github] multi account github problem",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/github_multi_account_github_problem\/",
     "id": "github_multi_account_github_problem",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["website_about_my_brain_blog_and_homepage"]
   }
 sessionStorage.setItem("github_multi_account_github_problem",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[website] about my braindump blog and homepage usage",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/website_about_my_brain_blog_and_homepage\/",
     "id": "website_about_my_brain_blog_and_homepage",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("website_about_my_brain_blog_and_homepage",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[website] make main homepage",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/website_make_main_homepage\/",
     "id": "website_make_main_homepage",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["website_about_my_brain_blog_and_homepage"]
   }
 sessionStorage.setItem("website_make_main_homepage",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[emacs] org to ipython notebook",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_org_to_ipython_notebook\/",
     "id": "emacs_org_to_ipython_notebook",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("emacs_org_to_ipython_notebook",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[kaggle-courses-intro] Arithmetic and Variable",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/kaggle_courses_intro_arithmetic_and_variable\/",
     "id": "kaggle_courses_intro_arithmetic_and_variable",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("kaggle_courses_intro_arithmetic_and_variable",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[kaggle-courses-python] hello python",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/kaggle_courses_python_hello_python\/",
     "id": "kaggle_courses_python_hello_python",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("kaggle_courses_python_hello_python",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[kaggle] beginning",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/kaggle_beginning\/",
     "id": "kaggle_beginning",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("kaggle_beginning",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[leetcode] beginning",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/leetcode_beginning\/",
     "id": "leetcode_beginning",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("leetcode_beginning",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[leetcode] 1480 running sum of 1d array",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/leetcode_1480_running_sum_of_1d_array\/",
     "id": "leetcode_1480_running_sum_of_1d_array",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["leetcode_beginning"]
   }
 sessionStorage.setItem("leetcode_1480_running_sum_of_1d_array",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[linear algebra-1] linear algebra introduction",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/linear_algebra_1_linear_algebra_introduction\/",
     "id": "linear_algebra_1_linear_algebra_introduction",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("linear_algebra_1_linear_algebra_introduction",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[linear algebra-2] linear independence",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/linear_algebra_2_linear_independence\/",
     "id": "linear_algebra_2_linear_independence",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("linear_algebra_2_linear_independence",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "python_summary3 about class",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary3_about_class\/",
     "id": "python_summary3_about_class",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("python_summary3_about_class",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "python_summary5 loop",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary5_loop\/",
     "id": "python_summary5_loop",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("python_summary5_loop",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "python_summary0-About Python",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary0_about_python\/",
     "id": "python_summary0_about_python",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("python_summary0_about_python",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "sop idea1",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/sop_idea1\/",
     "id": "sop_idea1",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("sop_idea1",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[emacs] org-babel -python",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_org_babel_python\/",
     "id": "emacs_org_babel_python",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("emacs_org_babel_python",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[emacs] python lsp setting",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_python_lsp_setting\/",
     "id": "emacs_python_lsp_setting",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["python_summary0_about_python"]
   }
 sessionStorage.setItem("emacs_python_lsp_setting",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "python_summary2-assignment and variables",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary2_assignment_and_variables\/",
     "id": "python_summary2_assignment_and_variables",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["python_summary0_about_python","python_summary1"]
   }
 sessionStorage.setItem("python_summary2_assignment_and_variables",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[emacs] anaconda settings",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_anaconda_settings\/",
     "id": "emacs_anaconda_settings",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["python_summary0_about_python"]
   }
 sessionStorage.setItem("emacs_anaconda_settings",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "hugo korean encoding problem",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/hugo_korean_encoding_problem\/",
     "id": "hugo_korean_encoding_problem",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("hugo_korean_encoding_problem",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "python_summary1-import and module",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary1\/",
     "id": "python_summary1",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("python_summary1",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "test_page1",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/test_page1\/",
     "id": "test_page1",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("test_page1",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[emacs] jupyter notebook settings",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_jupyter_noteboo_settings\/",
     "id": "emacs_jupyter_noteboo_settings",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["emacs_org_to_ipython_notebook","python_summary0_about_python"]
   }
 sessionStorage.setItem("emacs_jupyter_noteboo_settings",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "daily영어(1)-don\u0027t pet my puppy",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/english1\/",
     "id": "english1",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("english1",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "folding test1",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/folding_test\/",
     "id": "folding_test",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["folding_test2"]
   }
 sessionStorage.setItem("folding_test",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "folding test2",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/folding_test2\/",
     "id": "folding_test2",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["folding_test"]
   }
 sessionStorage.setItem("folding_test2",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture10-String",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture10-string\/",
     "id": "lecture10-String",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture10-String",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture11-IO",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture11-io\/",
     "id": "lecture11-IO",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture11-IO",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture12-setting-exception-logging",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture12-setting-exception-logging\/",
     "id": "lecture12-setting-exception-logging",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture12-setting-exception-logging",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture13-web",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture13-web\/",
     "id": "lecture13-web",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture13-web",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture3 data structures",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture3_data-structure\/",
     "id": "lecture3_data-structure",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture3_data-structure",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture4_condition-and-loop",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture4_condition-and-loop\/",
     "id": "lecture4_condition-and-loop",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture4_condition-and-loop",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture5_function",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture5_function\/",
     "id": "lecture5_function",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture5_function",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture6-pythonic programming",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture6-pythonic-programming\/",
     "id": "lecture6-Pythonic-Programming",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture6-Pythonic-Programming",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture7_Object-Oriented-Programming",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture7_object-oriented-programming\/",
     "id": "lecture7_Object-Oriented-Programming",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture7_Object-Oriented-Programming",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture8-module-and-package",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture8-module-and-package\/",
     "id": "lecture8-module-and-package",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture8-module-and-package",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture9-Advanced-Data-Structure",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture9-advanced-data-structure\/",
     "id": "lecture9-Advanced-Data-Structure",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture9-Advanced-Data-Structure",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "web scraping1",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/webcrawler1\/",
     "id": "webcrawler1",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("webcrawler1",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "lecture2_variable_and_operator",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture2_variable_and_operator\/",
     "id": "lecture2_variable_and_operator",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("lecture2_variable_and_operator",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "linear_algebra1",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/linear_algebra1\/",
     "id": "linear_algebra1",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("linear_algebra1",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[elisp] korean lorem ipsum",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/elisp_korean_lorel_ipsum\/",
     "id": "elisp_korean_lorel_ipsum",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("elisp_korean_lorel_ipsum",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[python] grammar in one shot - standard library (Text)",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/python_grammar_in_one_shot_standard_library_text\/",
     "id": "python_grammar_in_one_shot_standard_library_text",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("python_grammar_in_one_shot_standard_library_text",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "[website] making portfolio page",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/website_making_portfolio_page\/",
     "id": "website_making_portfolio_page",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("website_making_portfolio_page",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "Example of org to ipynb",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/example\/",
     "id": "example",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
              
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": ["emacs_org_to_ipython_notebook"]
   }
 sessionStorage.setItem("example",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "python_summary4_data structures",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary4_data_structures\/",
     "id": "python_summary4_data_structures",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("python_summary4_data_structures",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 
     
     graph_node_object = {
        
     "label": "python_summary8 string",
     "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary8_string\/",
     "id": "python_summary8_string",
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
         
     
     "backlinks": []
   }
 sessionStorage.setItem("python_summary8_string",JSON.stringify(graph_node_object)); 
 graph_objects.push(graph_node_object);
 

 
 function getNode(filename){
   var storedObject = JSON.parse(sessionStorage.getItem(filename));
   alert("label: " + storedObject.node_label);
   alert("url: " + storedObject.node_url);
   alert("backlinks: " + storedObject.backlinks);   
 }
 
 function getLinks(){
   links = []
   for (i = 0; i< graph_objects.length; i++)
   {
     let link_object;
     gno = graph_objects[i];
     blinks = gno.backlinks;
     for(j=0;j< blinks.length;j++){
       link_object = { source:gno.id, target:blinks[j]}
       links.push(link_object);
     }
   }
   return links;
 }

</script>
<script src="/js/URI.js" type="text/javascript"></script>
<script src="/js/page.js" type="text/javascript"></script>

<script src="https://d3js.org/d3.v7.min.js"></script>

<script>
window.store = {
      
    "https:\/\/braindump.frege2godel.me\/posts\/matter_js_tutorial\/": {
        "title": "[matter.js] tutorial",
        "tags": [],
        "content": "Getting started matter.js는 물리엔진이다. 물리엔진을 가지고 노는것은 즐겁다. js파일을 실행하기 위해선 node가 필요하다. node의 기초적인 사용법은 따로 link를 걸겠다. 여기 에 가면 옛날에 적은 것들이 있다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/matter_js_tutorial\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/node_npm_and_node\/": {
        "title": "[node] npm and node",
        "tags": [],
        "content": "node node는 javascript interpreter로 봐도 된다. python 파일을 실행시키기 위해서 python interpreter가 있듯이 또 ruby를 실행시키기 위해서 ruby가 있는것과 비슷하다. 위 3가지 언어는 비슷하다.\nnpm npm은 package관리자다. ruby에 gem이 있듯이, python에 pip가 있듯이 package를 설치하는 것은 동일하다. 하지만 package를 위한 project의 구조와 package의 의존성을 관리하는 방식, package를 배포하는 방식도 다르다. 여기서는 단순히 몇가지 명령어를 알아보자.\nnpm init -y project를 위해서 폴더를 만들고, 폴더안에서 package init을 하면 package.json이 만들어진다. 이것이 현재 project가 의존하는 package를 나타내고 배포가 되었을때도 참조하는 package를 설치할 수 있게 해준다. package.json에는 entry point라고 해서 시작점에 해당하는 js를 기술하게 한다.\nnpm install 가장 많이 사용되는 명령어라고 할 수 있다. package를 설치하는 명령어다. project에서 npm install이라고 하면, package.json에 의존성 package를 모두 node_modules라는 폴더에 설치한다. npm install [package명]은 특정한 package를 설치하고 package.json에 기록한다. pip install과 같은거라고 보면 된다. pip install로 package를 설치한다고 해서 requirement.txt에 기술이 되지 않는데, 어떻게 보면 npm이 project의 제작과 배포에 더 편리하다고 볼 수 있다.\nnpm install [package명] -g system에 package를 설치한다.\nnpm install \u0026ndash;save [package명] package.json에 기록된다. \u0026ndash;save는 최신버전에서는 default이기 때문에 npm install package와 같다. 이렇게 기록되면 나중에 배포해서 npm install할때 한큐에 설치할 수 있다.\nnpm install \u0026ndash;save-dev [package명] 이것은 현재 설치는 하지만, 개발할때만 사용한다.\nnpm uninstall [package명] package를 uninstall한다.\nnpm run package.json에 보면 다음과 같이 script가 정의되어 있다.\nscript를 실행하는 명령어가 npm run이다. 여기에는 test라는 이름으로 script가 되어 있기 때문에 다음과 같이 실행한다.\nnpm run test 에디터를 열고 다음을 추가해도 된다. 에디터를 사용하지 않는 방법도 있다.\n\u0026#34;start\u0026#34;: \u0026#34;node index.js\u0026#34; 위와 같이 추가하고,\nnpm run start 하면 된다.\nnvm node도 python처럼 버전을 많이 탄다. 그래서 가상환경을 사용해야 한다. ruby에서 rvm이나 rbenv를 사용했던것과 동일하다. python의 pyvenv나 conda env와도 같다. 사용법은 단순하다.\nbrew install nvm brew로 nvm을 설치한다. 그리고\nmkdir ~/.nvm 을 만들고 .zshrc에 다음을 추가한다.\nexport NVM_DIR=\u0026#34;$HOME/.nvm\u0026#34; [ -s \u0026#34;/usr/local/opt/nvm/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;/usr/local/opt/nvm/nvm.sh\u0026#34; # This loads nvm [ -s \u0026#34;/usr/local/opt/nvm/etc/bash_completion.d/nvm\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;/usr/local/opt/nvm/etc/bash_completion.d/nvm\u0026#34; # This loads nvm bash_completion 이것은 brew install nvm을 실행하면 설치하라고 나온다.\nnvm version nvm의 version을 확인한다.\nnvm list 현재 설치된 node version들을 확인한다.\nnvm use 사용할 node를 선택한다.\nnvm install 8.0 node를 설치한다.\nnode로 만들어진 project를 가져오면 해야할 것 가장 먼저 해야 할 것은 사용되는 node의 version에 맞춰 가상환경을 만드는 것이다. 그 다음, project에서 npm install로 package.json에서 기술된 의존성 package를 모두 설치한다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/node_npm_and_node\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/git_git_drill1_repo_and_commit\/": {
        "title": "[git] git drill1 repo and commit",
        "tags": [],
        "content": "Git Explained 이전에 작성했던 git관련 문서가 있다. 재작성할 필요를 느꼈다. 옛날 문서 가 있지만,다시정리한다.\ngit drill repo and commit (현재문서) git drill local git drill remote git drill internals Git Introduction Git은 Version Control System이다. 또한 Git은 version history라고 부른다. Git에서 commit이라는 자료구조는 version이라고 한다. history는 linked list로 구현한다. 따라서, linked list를 안다면 혹은 구현할 수 있다면, Git을 이해하는 건 쉽다. linked list를 기반으로 Git을 크게 4단계로 나누어서 설명할 것이다. 1단계는 git을 사용하기 위한 설치과정 및 commit이라는 version, 그리고 linked list소개, 2단계는 local system에서 Git의 사용, 3단계는 remote system에서 Git의 사용, 4단계는 work flow다. 부록으로 Git 내부 명령어를 설명할 수도 있다. 1단계는 어디가도 있는 내용이라서 그냥 가볍게 읽고 넘어가면 된다.\nGit Drill-1단계(part 1: repo란 무엇이고, repo 준비) 누군가가 repository가 무엇이냐고 묻는다면? 어떻게 대답할 수 있을까? repo는 container다. repo라는 자신만의 file-system을 가지고 있고, 자신만의 file system의 변경사항들을 commit이란 형태로 저장한다. part1에서는 이런 repo의 생성을 다룬다. 새롭게 만들거나 이전에 있는것을 가져온다. 그런 것을 가능하게 하는 명령어, init과 clone을 배운다. repo가 만들어지면, 이 저장소에는 commit들이 저장된다. commit들에게 반드시 포함되어야 하는 정보가 있다. commit을 만든 사람과, email과 같은 정보인데, 이것은 hash라는 고유의 id를 만드는데도 관여한다. git configure라는 환경설정을 통해 이런 값들을 setting할 수 있다. 이렇게 하면 commit만 만들면 된다. 이것은 part2에서 하게된다.\n- git 설치 : system에 git program설치 (1) git init : .git(repository)을 만든다. (2) git clone : .git(repository) 폴더를 server에서 가져온다. (3) git configure : git을 설정한다. commit에 자신의 정보를 넣기위해서 필요. (4) git ignore: git에서 처리하지 않을 파일을 기록 git 설치(brew) brew install git git을 system에 설치, 간단히 brew로 설치\ngit init, git clone git init git clone URL git init으로 현재 폴더안에.git(repository)이란 폴더를 만든다. 처음에는 commit도 없고, branch도 없다. git clone URL에서 다른곳에 있는 .git폴더를 가져오는 것이다. git clone은 remote와 관련이 있기 때문에 3단계에서도 설명을 할 것이다.\ngit configure git config --global user.name \u0026#34;[name]\u0026#34; git config --global user.email \u0026#34;[name]\u0026#34; 이제 저장할 공간도 확보했기 때문에 저장 하면 된다. 그런데, 좀 해주어야 할게 있다. 저장은 commit이란 형태로 저장되는데, 여기에는 어떤 사용자가 저장했는지, 언제 했는지 같은 meta data가 들어간다. 그 meta data를 설정해야 한다. 사용자 이름,email주소를 적어주면 된다.\ngit ignore 편집기에서 .gitignore이라는 파일을 열고 다음과 같은 내용을 쓴다.\n*.log .gitigonre파일에서 특정 파일을 commit에 포함시키지 않는다. commit을 지금 몰라도 나중에는 알게 된다. 배제할 파일 목록은 다음을 참고하면 된다. https://gitignore.io/ Git drill - 1단계 (part2-commit 만들기) Part1에서 git을 사용해서 commit을 할 수 있는 준비가 되었다고 했다. commit은 git에서 다루는 가장 기본적인 단위다. commit은 동사로도 쓰이고 명사로도 쓰인다. commit은 독립적으로 존재하지 않고, 단방향 linked list 형태로 연결되어 있다. commit은 git의 가장 fundamental한 요소다. part2에선 commit을 만들고, 이것이 어떻게 linked list로 연결되는가?에 대해서 알아본다.\nCommit part1에서 repo를 생성하거나 가져왔다. repo에는 commit들의 linked list형태로 저장된다고 했다. 그러면 commit은 무엇이냐?라고 물을 수 있다. 뭐라고 말할 것인가? commit은 변경사항이다. repo가 가진 sub file system의 변경사항을 압축한게 commit이다. 난 이렇게 밖에 답할 수 없을 듯 하다.\ncommit 만들기 위한 조건. git은 저장시스템(repository)에 commit을 linked list형태로 저장한다고 했다. commit은 변경사항을 저장한 것이라고 했다. 변경사항? 어떤 변경사항인가? repo가 가진 working directory의 변경사항을 뜻한다. repo가 유지하는 working directory에서 변경된 파일이 있거나 추가된 파일이 있다면 그것이 변경사항이고 그것이 commit의 형태로 저장되는 것이다.\ngit은 변경사항을 항상 check해야 한다. monitoring하고 있어야 한다. 그래야 변경사항을 commit으로 저장할 수 있으니까 말이다. working directory에서의 변경사항의 기준은 이전 commit이다. 처음 repo를 작성하면 이전 commit은 없기 때문에 새로 생성되는 모든 파일은 변경사항이 된다. git은 이 모든 것을 check하고 있다.\n[git status] git이 이전 commit과 현재의 working directory의 차이를 monitoring하고 있다고 했다. 정말 git이 monitoring하는지 알수 있는 git 명령어가 제공된다. git status라는 명령어다.\ngit status Figure 1: git status\ngit은 이전 commit과 현재의 working directory의 차이만 monitoring하고 있는지 알았는데, git status를 보니, 다양한 일을 하는 것 같다. 우선 그림에서 첫번째 주황색 박스를 보면, origin/main과 현재 main이 up to date되었다는 정보를 가르쳐준다. 이 정보는 remote commit과 local에 있는 이전 commit의 비교를 의미한다. 두번째 box에는 git이 monitoring한 변경파일들이 보인다. 그런데 staged되지 않은 변경파일이라고 한다. 그러면 stage된 변경파일은 무엇인가? 이전 commit과 비교해서 변경된 파일들은 선택이 가능하다. 무조건 변경되면 다음 commit에 포함되는게 아니다. commit에 저장되는 파일들은 변경된 파일들 중에 선택된 파일들이라는 것이다. 선택되었다는 것은 stage 에 올라갔다 라고도 표현한다. 마지막 box는 untracked file이라고 한다. untracked 라는게 무엇인지 알아야 한다. git은 현재의 working directory와 이전 commit과 비교해서 변경된 파일들(changes)를 계속 monitoring한다고 했다. 그런데 만일 새로운 파일이 추가되었다면 그것은 changes에 해당할까? 변경된 파일에 해당하냐? 답은 아니다. 이전 commit에 없는 새로운 파일이기 때문에 변경된게 아니라 새로운 파일이다. 기존에 없던 새로운 파일. 그래서 그런 파일들을 untracked file 이란 용어를 쓴다. changes 를 이전 commit에서 변경된 파일들이라고 했듯이, untracked 는 이전 commit에 없는 새로운 file을 의미한다. untracked 파일들도 다음 commit을 만들때 선택될 수 있다. 마치 changes가 선택되서 stage에 올라가듯 untracked file들도 선택되어 stage에 올라갈 수 있다.\n[git add] - 변경파일(changes),새파일(untracked)들은 선택되어 staged될 수 있다. 모든 changes들이 commit이 되는게 아니라, changes들 중 선택할 수 있다. git에선 git add라는 명령어를 제공한다. git add로 우린 원하는 changes(변경된 파일)을 선택해서 stage에 올릴 수 있다.\ngit add test.txt 그런데, changes라는게 이전 commit과 지금의 working directory에서 변경되거나 새롭게 추가된 파일들인데, sub file system에서 엄청나게 많은 file들이 변경되거나 추가될 수 있다. 하나 하나 선택하는 건 힘들수 있다. 왜냐면, 프로그램을 하나 짜더라도 너무나 많은 파일이 사용되고, 협업을 하게 되면 파일의 수가 많아지는건 너무나 당연하다. 그래서 보통은 git add . 로 전체를 올린다.\ngit add . [git commit] stage에 간택된 changes만 commit. 이렇게 stage에 올린 후에 git commit -m \u0026ldquo;message\u0026quot;를 입력하면 commit이란 형태로 repository에 저장된다.\ngit commit -m \u0026#34;message\u0026#34; [git commit] branch와 HEAD의 역할 앞으로 나오게 될 말이기도 하지만, 최초의 commit이 만들어지면, 그 때 master(main)라는 branch와 Head가 만들어진다. master는 commit을 가리키고, Head는 master를 가리킨다. 물론, HEAD나 branch는 모두 commit을 가리킬 수 있는 일종의 pointer or tag라고 말할 수 있다. 하지만 HEAD는 보통 commit을 직접 가리키지 않는다. Head는 branch를 가리킨다. 왜 branch를 가리키는지 설명하기에 앞서서, branch에 대한 설명이 필요할 듯하다. branch는 commit을 가리키는데, 그 commit이 그냥 commit이 아니다. 입구 같은 commit이다. 모든 commit들이 linked list로 연결되는데, 어떤 commit뒤에 새로운 commit을 붙여야 하는지 모른다. 무조건 마지막 commit뒤에 새로운 commit을 붙이는 건만은 아니다. 그래서 branch는 새로운 commit이 붙여질 위치를 나타낸다. commit이 붙여지면, 붙여진 commit으로 branch는 이동한다. 이제 아까 설명하다 멈춘 HEAD에 대해서 말해보자. branch는 새로운 commit이 붙여질 입구다. 그런데 branch가 하나만 있는게 아니다. 그 입구라는게 10개가 될 수 있다. 10개 중에 어떤 branch를 선택하냐? 그것을 정해주는게 바로 HEAD다. HEAD가 branch를 선택하는 역할을 한다. 선택된 branch에 새로운 commit은 붙여진다.\ngit add ./* git commit -m \u0026#34;message\u0026#34; 그림으로 보면 다음과 같다.\nFigure 2: commit\n[git switch,git checkout] \u0026lsquo;HEAD detached\u0026rsquo; 용어 HEAD detached라는 용어가 있다. HEAD는 branch를 가리킨다고 한다. 만일 HEAD가 branch가 아닌 commit을 가리키면 Head Detached라고 부른다. HEAD를 이동하는 명령어는 git switch과 git checkout이 있다.\n[git commit] 결과 [git log],[git status] git commit을 했을때 순차적인 동작은 다음과 같다. commit이 만들어지고, HEAD가 가리키는 branch는 새로운 commit으로 이동된다. branch가 이동되면 HEAD도 같이 이동된다. 이것을 확인하는 것은 git log라는 명령어이다. git log는 만들어진 commit과 HEAD와 Branch를 보여준다.\ngit log Figure 3: git log\nstage에 올린것을 commit으로 만들었기 때문에 staged(cached)라고 불리는 영역은 깨끗해진다.\nFigure 4: clean git status\nstage가 깨끗해진다는 것은 이렇게 이해해도 된다. 새롭게 만들어진 commit에 있는 working directory는 현재 working directory와 동일하기 때문에 changes가 없는건 당연하다. 라고 이해할 수 있다.\n[git rm] stage에서 내리는법(unstage) (use \u0026#34;git rm --cached \u0026lt;file\u0026gt;...\u0026#34; to unstage) stage를 다른 말로 cached라고 부르기도 한다. git rm으로 stage에 올린것을 지우면 된다.\n[git reset] commit취소 그리고 이동 commit을 만들었는데, 잘못 만들었다. 취소하고 싶다. 이것은 좀 복잡한 내부처리 과정을 거친다. 취소라는 단어보단, 어떻게 보면 Head와 branch이동인데, 그냥 취소라고 하자. 두 가지 경우가 있다. 하나는 만든 commit이 최초의 commit인 경우와, 두번째는 만든 commit이 최초 commit이 아닌 경우다.\n최초 commit인 경우. commit을 삭제하면 이전의 상태로 가야 한다. 이전 상태는 아무것도 없는 상태, 그러면 HEAD와 Branch가 없어야 한다. 그리고 수정된 파일이나, 새롭게 만든 파일들은 그대로 working directory에 있어야 하고, git status를 했을때 변경사항으로 보여져야 한다.\n가장 쉬운 방법은 repo를 지우는 것이다. rm -rf .git으로 지워도 작성된 파일은 그대로 working directory에 남아있기 때문에 수정해서 새 commit을 만들면 된다.\nrm -rf .git 다른 방법도 있다. HEAD를 삭제하는 것이다. HEAD를 없애면 HEAD가 가리키는 branch도 없어진다. 이렇게 하는 git 명령어가 존재한다.\ngit update-ref -d HEAD 이렇게 하면 현재의 HEAD를 날려버린다. 그러면 commit이 가졌던 변경사항들이 index에 있게 된다. 이것은 repo를 지웠을 때와 차이가 있다. repo를 지우면 잘못만든 commit이 가지고 있던 file들은 그대로 현 폴더에 있는 상태지만, HEAD만 지우면, 변경사항들은 index(stage)에 올려져 있다.\n[git reset] 최초의 commit이 아닌 경우 commit을 취소하면 HEAD와 branch가 이전의 commit으로 이동하고 취소된 commit이 가지고 있던 변경사항들이 stage에 있는것을 원할 것이다. 이 때 사용하는 명령이 reset이다. reset은 HEAD와 Branch를 함께 움직이는 명령어다. git switch와 checkout은 HEAD만 이동한다. 그래서 git switch나 checkout은 branch를 인자로 받아서 HEAD를 branch로 이동한다면, reset의 경우는 HEAD와 branch를 같이 이동하는 명령어다.\n다시 요약하면, reset은 HEAD와 Branch를 함께 이동 시키는 명령어다. 이런 git reset은 3가지 경우가 있다. 이동하려는 commit과 현재 commit의 변경사항들 을 어떻게 처리할까에 따라서 3가지 경우가 있는 것이다.\n\u0026ndash;soft:\ngit reset --soft cd23ed20deb 가장 일반적인 경우다. 원하는 commit으로 HEAD와 branch를 이동 시키고, 현재 commit과 이동할 commit간의 변경사항들을 모두 stage영역 에 올려놓는 것이다.\n\u0026ndash;mixed(default):\n이동하려는 commit과 현재 commit의 차이를 그대로 변경사항영역 에 놔둔다. 변경 사항들을 지우지 않는다. soft에서는 모두 stage에 올려놨다면, mixed는 그대로 변경사항으로 남아 있는 것이다.\n\u0026ndash;hard\ngit reset --hard cd23ed20deb hard라는 단어에서 느끼듯이 이것은 현재 commit과 해당 commit간의 모든 변경 사항들은 무시한다. stage에 올려놓거나 변경사항을 유지하지 않는다. 즉 두 commit간의 차이점을 반영하지 않는다. git status를 했을때, 변경사항이나 stage영역이 깨끗한 것을 확인할 수 있다. 해당 commit을 commit했을 때, 당시 시점으로 이동하는것이다. commit한 당시 시점이기 때문에 git status를 했을 때 아무것도 안보이는 것은 당연한 일이다. \u0026ndash;hard는 모든 변경했던 파일 정보가 사라지기 때문에 사용에 신중함이 필요하다.\n상대 참조에 관해(HEAD^와 HEAD~n 그리고 commit hash) git checkout,switch,reset은 HEAD와 branch를 특정 commit으로 이동하는 명령어이다. 특정 commit을 가리킬 때는 git log를 통해서 hash값을 알아야 이동 할 수 있다. hash값을 사용해서 처리하는것은 절대주소를 참조하는 것과 같이 불편하다. 그래서 상대 참조하는 방식이 있다.\ngit switch main^ git switch main~3 git reset HEAD^ git reset HEAD~3 위와 같이 해서 commit이 가진 hash값을 직접 입력하지 않고 commit을 참조할 수 있다. Head와 branch 어떤걸로 해도 상관없다.\nsummary git repo와 commit에 대해서 대충 다뤄봤다. commit에서 좀 설명해야 할 게 있는데, commit의 구조다. commit은 변경사항만 저장하는데, working directory구조는 유지하면서 변경사항을 저장한다. 변경된 파일들을 나열해서 저장하는게 아니라, working diretory의 구조인 tree와 blob이라는 file형태로 저장한다. 그래서 commit을 보면 아래와 같이 tree와 blob을 볼 수 있다.\nFigure 5: git commit과정\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/git_git_drill1_repo_and_commit\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/git_git_drill2_local\/": {
        "title": "[git] git drill2 local",
        "tags": [],
        "content": "git drill(2단계 -local) git drill 1단계에서 repo와 commit을 만드는것을 해봤다. 이제 local에서 branch와 merge같은 작업이 어떻게 이루어지는지 살펴봐야 한다. 그리고 local에서 주로 사용하는 git 명령어들도 살펴볼 것이다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/git_git_drill2_local\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/sql_programmers_sql_high_score\/": {
        "title": "[sql] programmers sql high score",
        "tags": [],
        "content": "introduction 여기에 쓰는것은 누군가가 나에게 sql좀 알려줘 하면 설명해주는 일종의 pattern이다. 그냥 머리속의 생각이라서 대충 이정도는 머리속에 있고 나머지는 검색해서 현업에서 일했다. 즉 아주 기초중의 기초라는 것이다. 하지만, 머리속에 떠오르는 이런 생각이 없으면 개발이 힘들어진다. 누구나 알고 있겠지만, sql은 set theory에 기반한다. 그리고 logic에 대한 개념도 들어가 있다. 이 두 개념에 익숙하다면 그 개념으로 이해해도 된다. 여튼 내가 알고 있는 개념과 Programmers 문제를 풀면서 설명이 필요한것을 적기로 한다. 여기에서 dbms에 관한 sql은 생략한다. 예를 들면 table을 만든다거나, use db로 db를 사용한다거나 이런것들은 생략한다. from where group by having SOL만 다뤄보기로 한다. 그리고 반드시 알아야 하는 집계함수들과 가장 중요한 join만 정리한다. 왜냐면 내가 아는것은 이것밖에 없다. 나머지는 필요에 따라서 검색할 뿐이다.\n기본 select문 select라는 건 말그대로 선택한다는 것이다. 무엇을 선택하는가? table의 column을 선택한다. table로부터 column을 선택해서 table을 만드는것이다. 일종의 함수다. 정의역도 table, 공역도 table. select문에는 실행 순서가 있다. 보통은 이렇게 외운다.\nfrom(join) where group by having SOL[select(distint),order by, limit] 좀 유치하긴 해도, 이게 기본 실행 순서이고 각각의 keyword는 모든 select문의 기초이기 때문이다.\nfrom 이제 정의역에 해당하는 table을 기술해보자. 정의역 table을 기술하는 것은 from이다. 왠지 적절한 단어같다. 정의역 table로 부터 원하는 column을 가져와서 table을 만드는 것은 다음과 같다.\nselect a,b from Atable 이것은 이렇게 해석한다. db에 있는 Atable을 가져온다. 그리고 a,b column data를 꺼낸다. 이렇게 해석하는 이유는 from이 가장먼저 실행되기 때문이다. 의외로 이것을 모르는 사람이 많이 있어서 적는다.\nwhere table에서 a,b컬럼을 가져온다는 것은 data를 포함한 column을 다 가져온다는 것이다. 여기서 특정 조건의 row data만을 가져올 수 있다. 예를 들어보자.\nselect district from local where district=\u0026#34;busan\u0026#34; where절의 형태를 보자. 선택된 column district의 row를 제한하기위해서 busan과 같다는 조건을 걸었다. 선택된 column이 일종의 변수와 같은 역할을 한다. 이것도 local이라는 table을 db에서 꺼낸다. 그 다음 district가 busan인것만 추린 table에서 district column만 선택해서 꺼낸 table을 return한다. 순서는 다음과 같다. from =\u0026gt; where =\u0026gt; select.\ngroup by group by는 특정 column의 row data를 group별로 묶는다. 왜 묶을까? 보통은 집계함수(mma cs)를 사용하려고 묶는다. row를 group으로 묶는다는것을 생각해봐라. 예를 들어 sex라는 column을 group으로 묶으면 어떻게 될까? male 아니면 female이다. 두개밖에 없다. 만일 region이라는 지역으로 group by를 하면 지역별로 하나씩만 나오게 된다. 즉 row data를 summary한 느낌이다. 대표값만을 뽑은 느낌이다. 이렇게 하는 이유는 개개의 row data를 사용하지 않고, mma cs라는 집계함수를 사용하기 위함이다. 이것을 명령어의 동작으로 이해하기 보단, mma cs라는 집계함수를 사용하기 위해선 group by를 사용해야 한다는 관점에서 바라봐야 한다. sex라는 항목을 본다면, 남자는 몇명인가? 키가 180이상인 여자는 몇명인가? 남자의 평균 몸무게는? 가장 몸무게가 많이 나가는 남자는? 이런 질문에 답을 하기 위해선 group by를 사용하는 것이다. 그럼 이제 group by를 어떻게 사용하는지 확인해 보자.\nFigure 1: table\n위와 같은 table이 있을때, 다음과 같은 명령을 내린다면 어떻게 될까?\nSELECT Country FROM Customers group by Country Customers라는 table을 db에서 가져온다. group by country는 Coutry라는 필드의 data를 대상으로 grouping한다. Country다. Country라는 column의 data를 grouping하면 대표값만 남는다. 이상태에서 Country라는 Field를 선택하면\nselect name select distinct distinct는 중복을 피하는 keyword다. select절에 포함된다. select절을 수행할 때 실행되는데, 굉장히 많이 쓰이는 편이다. 예를 들면,\nselect distinct people_id from Atable where city=\u0026#39;인천\u0026#39; 이런 식으로 사용된다. 이것이 의미하는 것은 Atable을 db에서 가져온다. city가 인천인 table을 만든다. 이런 table에서 peple_ID가 중복되지 않은 column을 꺼내서 return한다. select distinct가 하나의 절이다.\n집계함수 mma cs로 외우자. min,max,average 그리고 count, sum이다. 가장 많이 쓰이는 집계함수다.\norder by limit 요약 이것이 기본적인 select문의 구조다.\njoin 하나의 table에서 column을 선택해서 table을 만드는게 아니라, 2개의 table에서 column을 뽑아내서 만들 수는 없나? 그럴려면 2개의 table을 기술해야 한다. 예를 들어서,\nselect a,b from Atable, Btable 위와 같은 형태로 기술할 수 있다. 근데 a와 b는 Atable의 column인가? 아니면 Btable의 column인가? a,b라는 column은 Atable에도 Btable에도 있을 수 있다. 따라서 이런 표기법은 문제가 있다. 다음 표기법은 어떤가?\nselect Atable.a,Btable.b from Atable, Btable 일견 그럴싸하다. a라는 column은 Atable에서 선택한다는 명확한 의미전달이 가능하기 때문이다. 그럼 다음과 같은 상황을 살펴보자.\nselect SeoulElementarySchoolTeachers.a, BusanPeopleTable.b from SeoulElementarySchoolTeachers, BusanPeopleTable 뭔가 불편하지 않은가? 그렇다. table 이름이 길면 불편하다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/sql_programmers_sql_high_score\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/git_git_explained\/": {
        "title": "[git] git explained",
        "tags": [],
        "content": "Git Explained Git Introduction Git은 Version Control System이다. 또한 Git은 version history라고 부른다. Git에서 commit이라는 자료구조는 version이라고 한다. history는 linked list로 구현한다. 따라서, linked list를 안다면 혹은 구현할 수 있다면, Git을 이해하는 건 쉽다. linked list를 기반으로 Git을 크게 4단계로 나누어서 설명할 것이다. 1단계는 git을 사용하기 위한 설치과정 및 commit이라는 version, 그리고 linked list소개, 2단계는 local system에서 Git의 사용, 3단계는 remote system에서 Git의 사용, 4단계는 work flow다. 부록으로 Git 내부 명령어를 설명할 수도 있다. 1단계는 어디가도 있는 내용이라서 그냥 가볍게 읽고 넘어가면 된다.\nGit Drill-1단계(part 1: repo란 무엇이고, repo 준비) 누군가가 repository가 무엇이냐고 묻는다면? 어떻게 대답할 수 있을까? repo는 container다. repo라는 자신만의 file-system을 가지고 있고, 자신만의 file system의 변경사항들을 commit이란 형태로 저장한다. part1에서는 이런 repo의 생성을 다룬다. 새롭게 만들거나 이전에 있는것을 가져온다. 그런 것을 가능하게 하는 명령어, init과 clone을 배운다. repo가 만들어지면, 이 저장소에는 commit들이 저장된다. commit들에게 반드시 포함되어야 하는 정보가 있다. commit을 만든 사람과, email과 같은 정보인데, 이것은 hash라는 고유의 id를 만드는데도 관여한다. git configure라는 환경설정을 통해 이런 값들을 setting할 수 있다. 이렇게 하면 commit만 만들면 된다. 이것은 part2에서 하게된다.\n- git 설치 : system에 git program설치 (1) git init : .git(repository)을 만든다. (2) git clone : .git(repository) 폴더를 server에서 가져온다. (3) git configure : git을 설정한다. commit에 자신의 정보를 넣기위해서 필요. (4) git ignore: git에서 처리하지 않을 파일을 기록 git 설치(brew) brew install git git을 system에 설치, 간단히 brew로 설치\ngit init, git clone git init git clone URL git init으로 현재 폴더안에.git(repository)이란 폴더를 만든다. 처음에는 commit도 없고, branch도 없다. git clone URL에서 다른곳에 있는 .git폴더를 가져오는 것이다. git clone은 remote와 관련이 있기 때문에 3단계에서도 설명을 할 것이다.\ngit configure git config --global user.name \u0026#34;[name]\u0026#34; git config --global user.email \u0026#34;[name]\u0026#34; 이제 저장할 공간도 확보했기 때문에 저장 하면 된다. 그런데, 좀 해주어야 할게 있다. 저장은 commit이란 형태로 저장되는데, 여기에는 어떤 사용자가 저장했는지, 언제 했는지 같은 meta data가 들어간다. 그 meta data를 설정해야 한다. 사용자 이름,email주소를 적어주면 된다.\ngit ignore 편집기에서 .gitignore이라는 파일을 열고 다음과 같은 내용을 쓴다.\n*.log .gitigonre파일에서 특정 파일을 commit에 포함시키지 않는다. commit을 지금 몰라도 나중에는 알게 된다. 배제할 파일 목록은 다음을 참고하면 된다. https://gitignore.io/ Git drill - 1단계 (part2-commit 만들기) Part1에서 git을 사용해서 commit을 할 수 있는 준비가 되었다고 했다. commit은 git에서 다루는 가장 기본적인 단위다. commit은 동사로도 쓰이고 명사로도 쓰인다. commit은 독립적으로 존재하지 않고, 단방향 linked list 형태로 연결되어 있다. commit은 git의 가장 fundamental한 요소다. part2에선 commit을 만들고, 이것이 어떻게 linked list로 연결되는가?에 대해서 알아본다.\nCommit part1에서 repo를 생성하거나 가져왔다. repo에는 commit들의 linked list형태로 저장된다고 했다. 그러면 commit은 무엇이냐?라고 물을 수 있다. 뭐라고 말할 것인가? commit은 변경사항이다. repo가 가진 sub file system의 변경사항을 압축한게 commit이다. 난 이렇게 밖에 답할 수 없을 듯 하다.\ncommit 만들기 위한 조건. git은 저장시스템(repository)에 commit을 linked list형태로 저장한다고 했다. commit은 변경사항을 저장한 것이라고 했다. 변경사항? 어떤 변경사항인가? repo가 가진 working directory의 변경사항을 뜻한다. repo가 유지하는 working directory에서 변경된 파일이 있거나 추가된 파일이 있다면 그것이 변경사항이고 그것이 commit의 형태로 저장되는 것이다.\ngit은 변경사항을 항상 check해야 한다. monitoring하고 있어야 한다. 그래야 변경사항을 commit으로 저장할 수 있으니까 말이다. working directory에서의 변경사항의 기준은 이전 commit이다. 처음 repo를 작성하면 이전 commit은 없기 때문에 새로 생성되는 모든 파일은 변경사항이 된다. git은 이 모든 것을 check하고 있다.\n[git status] git이 이전 commit과 현재의 working directory의 차이를 monitoring하고 있다고 했다. 정말 git이 monitoring하는지 알수 있는 git 명령어가 제공된다. git status라는 명령어다.\ngit status Figure 1: git status\ngit은 이전 commit과 현재의 working directory의 차이만 monitoring하고 있는지 알았는데, git status를 보니, 다양한 일을 하는 것 같다. 우선 그림에서 첫번째 주황색 박스를 보면, origin/main과 현재 main이 up to date되었다는 정보를 가르쳐준다. 이 정보는 remote commit과 local에 있는 이전 commit의 비교를 의미한다. 두번째 box에는 git이 monitoring한 변경파일들이 보인다. 그런데 staged되지 않은 변경파일이라고 한다. 그러면 stage된 변경파일은 무엇인가? 이전 commit과 비교해서 변경된 파일들은 선택이 가능하다. 무조건 변경되면 다음 commit에 포함되는게 아니다. commit에 저장되는 파일들은 변경된 파일들 중에 선택된 파일들이라는 것이다. 선택되었다는 것은 stage 에 올라갔다 라고도 표현한다. 마지막 box는 untracked file이라고 한다. untracked 라는게 무엇인지 알아야 한다. git은 현재의 working directory와 이전 commit과 비교해서 변경된 파일들(changes)를 계속 monitoring한다고 했다. 그런데 만일 새로운 파일이 추가되었다면 그것은 changes에 해당할까? 변경된 파일에 해당하냐? 답은 아니다. 이전 commit에 없는 새로운 파일이기 때문에 변경된게 아니라 새로운 파일이다. 기존에 없던 새로운 파일. 그래서 그런 파일들을 untracked file 이란 용어를 쓴다. changes 를 이전 commit에서 변경된 파일들이라고 했듯이, untracked 는 이전 commit에 없는 새로운 file을 의미한다. untracked 파일들도 다음 commit을 만들때 선택될 수 있다. 마치 changes가 선택되서 stage에 올라가듯 untracked file들도 선택되어 stage에 올라갈 수 있다.\n[git add] - 변경파일(changes),새파일(untracked)들은 선택되어 staged될 수 있다. 모든 changes들이 commit이 되는게 아니라, changes들 중 선택할 수 있다. git에선 git add라는 명령어를 제공한다. git add로 우린 원하는 changes(변경된 파일)을 선택해서 stage에 올릴 수 있다.\ngit add test.txt 그런데, changes라는게 이전 commit과 지금의 working directory에서 변경되거나 새롭게 추가된 파일들인데, sub file system에서 엄청나게 많은 file들이 변경되거나 추가될 수 있다. 하나 하나 선택하는 건 힘들수 있다. 왜냐면, 프로그램을 하나 짜더라도 너무나 많은 파일이 사용되고, 협업을 하게 되면 파일의 수가 많아지는건 너무나 당연하다. 그래서 보통은 git add . 로 전체를 올린다.\ngit add . [git commit] stage에 간택된 changes만 commit. 이렇게 stage에 올린 후에 git commit -m \u0026ldquo;message\u0026quot;를 입력하면 commit이란 형태로 repository에 저장된다.\ngit commit -m \u0026#34;message\u0026#34; [git commit] branch와 HEAD의 역할 앞으로 나오게 될 말이기도 하지만, 최초의 commit이 만들어지면, 그 때 master(main)라는 branch와 Head가 만들어진다. master는 commit을 가리키고, Head는 master를 가리킨다. 물론, HEAD나 branch는 모두 commit을 가리킬 수 있는 일종의 pointer or tag라고 말할 수 있다. 하지만 HEAD는 보통 commit을 직접 가리키지 않는다. Head는 branch를 가리킨다. 왜 branch를 가리키는지 설명하기에 앞서서, branch에 대한 설명이 필요할 듯하다. branch는 commit을 가리키는데, 그 commit이 그냥 commit이 아니다. 입구 같은 commit이다. 모든 commit들이 linked list로 연결되는데, 어떤 commit뒤에 새로운 commit을 붙여야 하는지 모른다. 무조건 마지막 commit뒤에 새로운 commit을 붙이는 건만은 아니다. 그래서 branch는 새로운 commit이 붙여질 위치를 나타낸다. commit이 붙여지면, 붙여진 commit으로 branch는 이동한다. 이제 아까 설명하다 멈춘 HEAD에 대해서 말해보자. branch는 새로운 commit이 붙여질 입구다. 그런데 branch가 하나만 있는게 아니다. 그 입구라는게 10개가 될 수 있다. 10개 중에 어떤 branch를 선택하냐? 그것을 정해주는게 바로 HEAD다. HEAD가 branch를 선택하는 역할을 한다. 선택된 branch에 새로운 commit은 붙여진다.\ngit add ./* git commit -m \u0026#34;message\u0026#34; 그림으로 보면 다음과 같다.\nFigure 2: commit\n[git switch,git checkout] \u0026lsquo;HEAD detached\u0026rsquo; 용어 HEAD detached라는 용어가 있다. HEAD는 branch를 가리킨다고 한다. 만일 HEAD가 branch가 아닌 commit을 가리키면 Head Detached라고 부른다. HEAD를 이동하는 명령어는 git switch과 git checkout이 있다.\n[git commit] 결과 [git log],[git status] git commit을 했을때 순차적인 동작은 다음과 같다. commit이 만들어지고, HEAD가 가리키는 branch는 새로운 commit으로 이동된다. branch가 이동되면 HEAD도 같이 이동된다. 이것을 확인하는 것은 git log라는 명령어이다. git log는 만들어진 commit과 HEAD와 Branch를 보여준다.\ngit log Figure 3: git log\nstage에 올린것을 commit으로 만들었기 때문에 staged(cached)라고 불리는 영역은 깨끗해진다.\nFigure 4: clean git status\nstage가 깨끗해진다는 것은 이렇게 이해해도 된다. 새롭게 만들어진 commit에 있는 working directory는 현재 working directory와 동일하기 때문에 changes가 없는건 당연하다. 라고 이해할 수 있다.\n[git rm] stage에서 내리는법(unstage) (use \u0026#34;git rm --cached \u0026lt;file\u0026gt;...\u0026#34; to unstage) stage를 다른 말로 cached라고 부르기도 한다. git rm으로 stage에 올린것을 지우면 된다.\n[git reset] commit취소 그리고 이동 commit을 만들었는데, 잘못 만들었다. 취소하고 싶다. 이것은 좀 복잡한 내부처리 과정을 거친다. 취소라는 단어보단, 어떻게 보면 Head와 branch이동인데, 그냥 취소라고 하자. 두 가지 경우가 있다. 하나는 만든 commit이 최초의 commit인 경우와, 두번째는 만든 commit이 최초 commit이 아닌 경우다.\n최초 commit인 경우. commit을 삭제하면 이전의 상태로 가야 한다. 이전 상태는 아무것도 없는 상태, 그러면 HEAD와 Branch가 없어야 한다. 그리고 수정된 파일이나, 새롭게 만든 파일들은 그대로 working directory에 있어야 하고, git status를 했을때 변경사항으로 보여져야 한다.\n가장 쉬운 방법은 repo를 지우는 것이다. rm -rf .git으로 지워도 작성된 파일은 그대로 working directory에 남아있기 때문에 수정해서 새 commit을 만들면 된다.\nrm -rf .git 다른 방법도 있다. HEAD를 삭제하는 것이다. HEAD를 없애면 HEAD가 가리키는 branch도 없어진다. 이렇게 하는 git 명령어가 존재한다.\ngit update-ref -d HEAD 이렇게 하면 현재의 HEAD를 날려버린다. 그러면 commit이 가졌던 변경사항들이 index에 있게 된다. 이것은 repo를 지웠을 때와 차이가 있다. repo를 지우면 잘못만든 commit이 가지고 있던 file들은 그대로 현 폴더에 있는 상태지만, HEAD만 지우면, 변경사항들은 index(stage)에 올려져 있다.\n[git reset] 최초의 commit이 아닌 경우 commit을 취소하면 HEAD와 branch가 이전의 commit으로 이동하고 취소된 commit이 가지고 있던 변경사항들이 stage에 있는것을 원할 것이다. 이 때 사용하는 명령이 reset이다. reset은 HEAD와 Branch를 함께 움직이는 명령어다. git switch와 checkout은 HEAD만 이동한다. 그래서 git switch나 checkout은 branch를 인자로 받아서 HEAD를 branch로 이동한다면, reset의 경우는 HEAD와 branch를 같이 이동하는 명령어다.\n다시 요약하면, reset은 HEAD와 Branch를 함께 이동 시키는 명령어다. 이런 git reset은 3가지 경우가 있다. 이동하려는 commit과 현재 commit의 변경사항들 을 어떻게 처리할까에 따라서 3가지 경우가 있는 것이다.\n\u0026ndash;soft:\ngit reset --soft cd23ed20deb 가장 일반적인 경우다. 원하는 commit으로 HEAD와 branch를 이동 시키고, 현재 commit과 이동할 commit간의 변경사항들을 모두 stage영역 에 올려놓는 것이다.\n\u0026ndash;mixed(default):\n이동하려는 commit과 현재 commit의 차이를 그대로 변경사항영역 에 놔둔다. 변경 사항들을 지우지 않는다. soft에서는 모두 stage에 올려놨다면, mixed는 그대로 변경사항으로 남아 있는 것이다.\n\u0026ndash;hard\ngit reset --hard cd23ed20deb hard라는 단어에서 느끼듯이 이것은 현재 commit과 해당 commit간의 모든 변경 사항들은 무시한다. stage에 올려놓거나 변경사항을 유지하지 않는다. 즉 두 commit간의 차이점을 반영하지 않는다. git status를 했을때, 변경사항이나 stage영역이 깨끗한 것을 확인할 수 있다. 해당 commit을 commit했을 때, 당시 시점으로 이동하는것이다. commit한 당시 시점이기 때문에 git status를 했을 때 아무것도 안보이는 것은 당연한 일이다. \u0026ndash;hard는 모든 변경했던 파일 정보가 사라지기 때문에 사용에 신중함이 필요하다.\n상대 참조에 관해(HEAD^와 HEAD~n 그리고 commit hash) git checkout,switch,reset은 HEAD와 branch를 특정 commit으로 이동하는 명령어이다. 특정 commit을 가리킬 때는 git log를 통해서 hash값을 알아야 이동 할 수 있다. hash값을 사용해서 처리하는것은 절대주소를 참조하는 것과 같이 불편하다. 그래서 상대 참조하는 방식이 있다.\ngit switch main^ git switch main~3 git reset HEAD^ git reset HEAD~3 위와 같이 해서 commit이 가진 hash값을 직접 입력하지 않고 commit을 참조할 수 있다. Head와 branch 어떤걸로 해도 상관없다.\nsummary git repo와 commit에 대해서 대충 다뤄봤다. commit에서 좀 설명해야 할 게 있는데, commit의 구조다. commit은 변경사항만 저장하는데, working directory구조는 유지하면서 변경사항을 저장한다. 변경된 파일들을 나열해서 저장하는게 아니라, working diretory의 구조인 tree와 blob이라는 file형태로 저장한다. 그래서 commit을 보면 아래와 같이 tree와 blob을 볼 수 있다.\nFigure 5: git commit과정\ngit drill(2단계 -local) git drill 1단계에서 repo와 commit을 만드는것을 해봤다. 이제 local에서 branch와 merge같은 작업이 어떻게 이루어지는지 살펴봐야 한다. 그리고 local에서 주로 사용하는 git 명령어들도 살펴볼 것이다.\ngit drill3 말하는 점 조직이란게 이런것이다. 새로운 조직원은 말단 조직원을 통해서만 들어올 수 있고, 그 윗선은 알수가 없다.\n또 다른 예로, 노래테이프도 linked list로 볼 수 있다.\narray나 linked list나 원하는 자료를 찾을려면, 하나하나 다 살펴봐야 하는건 동일하다. 다만, array는 data가 없어도 살펴본다. 또한 array에서는 중간의 data를 살펴보는데, 어려음이 없다. 그런데 linked list는 중간의 data를 알려면, 이전의 data를 거치지 않고는 알 수 없다. 노래테이프도 그렇다. 생각을 해보자. 보물찾기를 해서 보물을 찾았는데, 보물에 다른 곳으로 가라고 적혀 있다면, 그곳에서 또 다른곳으로 가라고 적혀있는 것처럼, 원하는 것을 찾기위해선, 계속 찾아가야 하는 것이다.\n#+end_note\nLinked list 설명 git은 단방향 list를 사용한다. list는 처음에 Head만 있다. HEAD를 통해서 data를 담고 있는 Node가 연결된다. 이 과정을 그림으로 남긴다.\nFigure 6: linked list\nlinked list는 자료구조다. 자료구조는 data를 추가하거나, 중간에 삽입하거나, 삭제하거나, 갱신하는 여러 동작을 수행할 수 있어야 한다. 그것이 data structure를 사용하는 이유이고, 목적이기 때문이다. Linked list의 그런 조작에서 HEAD의 복사본이 사용된다. HEAD는 항상 data가 들어가는 입구역할을 하고, 중간에 노드를 삭제하거나, 삽입,갱신, 이 모든것은 *HEAD의 복제본*을 사용한다.\n변형 linked list 위에서 보면 linked list가 단방향을 가리키는 것을 볼 수 있다. Node의 삽입은 HEAD를 통해서만, 삽입되고, 마치 line과 같이 보인다. 만일 우리가 여기에 HEAD를 추가한다면 어떻게 될까?\nFigure 7: new head list\nHEAD를 추가하면 문제가 생긴다. Node를 삽입할 때, 어떤 HEAD를 사용해야 하는가? 이런 문제가 생긴다. 이런 문제를 해결하기 위해서 변수 하나를 더 추가한다. 어떤 HEAD를 선택할 지를 결정하는 변수다.\nFigure 8: new head\n최종 결과는 다음과 같은 모습이 된다.\nFigure 9: summary1\nFigure 10: summary2\nFigure 11: summary3\n변형 Linked list의 고찰 우선 array란 자료구조는 고정된 size를 갖기 때문에 자료를 저장할 구조로는 적합하지 않다. 어느 정도의 data가 그 공간에 삽입될지 예측할 수 없기 때문에 computer science에서는 linked list가 자료를 저장하는 아주 기본적인 구조다. 만일 무언가 자료를 넣어야 한다면 대부분 linked list를 생각해봐야 한다. linked list를 변형한 구조를 보여줬는데, 그 구조를 간단히 요약하면 다음과 같다. 기존의 linked list에 head만 붙이면 여러개의 list가 만들어짐을 볼 수 있었다. 그리고 Head라는게 Node삽입의 입구와 같기 때문에, 어떤 list에 삽입할 것인지는 HEAD를 정해줘야 한다. 그 HEAD를 정해주는 또다른 HEAD가 필요하다. 이 변형된 구조가 git이 가진 data structure다.\ngit data structure vs 변형 linked list 변형된 linked list를 git은 사용한다. 그런데 약간 차이가 있다. linked list라는 data structure는 기본적으로 자료를 저장하고, 찾고, 찾은 data를 수정하거나, 삭제, 추가에 대한 연산이 존재한다. 왜냐? 그럴려고 data structure를 사용하기 때문이다. 그런데 git에서는 그런 operation을 명확하게 지원하지 않는다. 지원하지 않는 이유는 한번 만들어진 Node를 수정이나 삭제 추가를 하게 되면 문제가 생기기 때문이다.\n우선 git을 만든 목적을 생각해 보자. 우리는 git을 단순히 data를 저장하기 위한 목적으로 linked list를 사용한게 아니다. git의 목적중 하나는 협업이다. 각각의 사용자들이 있고, 각각의 사용자들은 변형된 linked list에서 하나의 line을 갖게 된다. 각각의 line에서 무수한 수정이 발생되면, 동기화의 문제가 생긴다. Head에서 새로운 data를 추가하는 것은 문제가 되지 않지만, 어떤 line의 중간의 data(Node)를 내가 삭제했다. 그런데 삭제되기전에 Node를 받은 사람이 그것을 수정해서 다시 서버에 올렸다고 하자. 나는 그 Node를 삭제한후 서버에 접속하지 않고 그것과 관련된 기능을 모두 삭제했는데, 다시 접속하니 이상한 파일들이 엉켜있다면? 문제가 되지 않을까? 그 git을 사용하는 사람이 1-2명이 아닌 100명,200명이 사용한다면?\ngit에서 history는 중요하다. 그것들이 여러사람에게 공유되고 동기화의 문제로 history의 중간 버전을 수정하는것은 상당히 위험한 행동이다.\ngit의 용어 git은 변형 linked list를 사용한다고 했다. linked list에서 사용하는 term과 git에서 사용하는 term이 다르기 때문에 정리한다.\nFigure 12: git term\ncommit을 만들면 이것을 list에 삽입을 해야 하는데, list에서 삽입은 HEAD가 Node를 가리키는 방식이다. Git에서 HEAD는 branch를 선택하는 용어로 쓰인다. 그리고 Branch가 list에서 HEAD에 대응되는 용어다. 즉 branch가 새로운 commit을 가리키면서 삽입이 되기 때문에 Branch는 항상 최신(recently new) commit을 가리키고 있다고 보면 된다.\ngit drill4 흔한 질문 흔한 질문중에 하나는 git에서 history는 유지한 채, commit을 변경할 수 있느냐?는 것이다. 결론을 얘기한다면 원론적으로 불가능하다. 첫번째로 commit의 내용을 바꾼다는 것은 commit자체가 바뀐다는 것을 의미한다. commit은 content addressable하다. content의 내용을 sha1으로 바꿔 그것을 파일명,commit이름으로 쓴다. 만일 내용이 바뀌면 기존 commit과 다른 새로운 commit이 만들어지는 것인데, 그러면 history가 깨진다. 왜냐 새로운 commit을 만드는 것은 branch가 있어야 함을 의미하기 때문이다. 말이 좀 복잡해 지는데, linked list를 사용하는 git에서 새로운 commit을 만들면 branch가 그 commit을 가리키는 식으로 삽입이 된다. 즉 새로운 데이터를 삽입하는건 branch가 있는 곳에서 삽입이 된다는 것이다. 중간에 있는 commit을 수정한다는 것은(content addressable한 commit의 특성상) 새로운 commit을 만든다는 것인데, 이렇게 하기위해선, 우선 branch가 그 commit으로 이동해야 한다. 그리고 수정된 commit(실은 새로 생성된 commit)을 연결하는 순간 history는 깨진다. 왜냐 단방향 linked list라서 이전 commit으로 되돌아 갈수가 없게 된다. 참고로 branch를 특정 commmit으로 옮기는 명령어는 reset이란 명령어이다.\n다시 정리하면,\n수정할 commit으로 접근할려면 branch를 움직여야 한다. branch는 reset으로 움직인다. 물론 이전에 head가 해당 branch에 있다는 전제가 있다. head가 그 branch에 없다면, branch를 이동할 수가 없기 때문이다. 여튼 head와 branch가 묶여 있고, reset으로 해당 commit으로 이동했다고 하자.\ncommit을 수정한다. commit을 수정한다는 것은 새로운 commit이 만들어진다는 뜻이다. 왜냐? content addressable한 특징때문에, content의 내용이 달라지면 새로운 commit이 되기 때문이다. 현재 branch가 그 commit을 가리키고 있는데, 새로운 commit이 만들어지면, head와 branch는 새로운 commit을 가리키게 된다. 그리고 원래 branch가 있던 commit은 가리키는 branch가 없기 때문에 잃어버리는 history가 된다.\ngit commit git commit은 linked list에 commit을 삽입한다. linked list의 HEAD는 branch라고 하는데, default branch는 master란 이름을 가지고 있다. 그리고 git은 변형 linked list를 사용하기 때문에 HEAD라는 branch를 선택하는 변수가 있다.\nFigure 13: git commit\ngit commit \u0026ndash;amend git commit \u0026ndash;amend는 commit을 갱신하거나 삭제하는 효과를 준다. commit을 하고보니, 어떤 파일을 추가시키는 거 깜박했거나, 수정하는것을 깜빡했을때, 우리는 이전 commit지우고, 새로운 commit을 연결하면 되겠네! 할 것이다. 비슷하다. 그런데 이전 잘못 올린 commit은 그대로 둔다. 대신 제대로 반영한 commit의 parent를 잘못만든 commit이 아닌, 그 부모에 연결 시키는 방식을 사용한다. 왜 지우지 않나요? 어차피 linked list구조에서 head나 branch가 지워야 할 commit을 parent로 연결하지 않으면, 그 commit을 접근할 방법이 없다. linked list는 array와 달라서 link가 없으면 접근할 방법이 없다. 그래서 그냥 놨두면, git garbage collector가 branch가 접근할 수 없는 commit을 삭제한다.\nFigure 14: git commit \u0026ndash;amend\ngit branch git은 변형 linked list를 사용한다. linked list를 처음 만들면 head밖에 없다. 이 상태에서 data가 계속 삽입되는데, linked list는 head로 부터 만들어진다고 보면 된다. 즉 head가 10개 있으면, 10개의 linked list가 있다고 보면 된다. head를 git에선 branch라고 부른다. git branch를 3개 만들면 3개의 line(linked list)가 만들어지는 것을 아래 그림에 표시했다.\nFigure 15: git branch\ngit remote 원격에 있는 git은 URL을 갖는다. 그 URL에 이름을 붙일 수 있다. 이 때 쓰는 명령어가 git remote이다.\ngit remote add pb git://github.com/paulbone/ticgit.git git clone을 하게 되면 원격 URL은 origin이란 이름을 갖게 된다.\ngit clone git clone은 server에 있는 git repository를 local로 가져온다. local에서 작업할 수 있는 branch가 하나 만들어지는데, commit을 담을 수 있는 주머니가 만들어진다고 보면된다. 그리고 server에 있는 주머니의 주둥이(입구)는 origin/master란 이름을 갖는 입구인데, 움직이지 않는다. server와 local의 동기화를 위해 사용되는 bookmark라고 보면된다. origin은 위에서 말했듯이 원격 git의 URL의 이름이기도 하다. git remote add로 별도의 이름을 짓지 않았기 때문에 origin이란 default이름을 갖게 된다. 원래 remote server의 git안에는 수많은 branch가 있을 수 있다. 하지만 clone을 하면 default로 git의 URL주소는 origin이라는 name을 갖고 master branch만 tracking branch가 된다. 나머지 branch는 참조가 없기 때문에 local에선 사용할 수 없다. origin/master 브랜치만 tracking되기 때문에 clone하면 local master branch가 만들어지고 push,pull 모두 remote git server의 master branch에 특별한 기술없이 사용될 수 있는것이다. 예를들어 server에 testing이란 branch만 있다고 하자. 그러면, git clone하면, local에는 origin/testing이라는 branch와 testing이란 branch가 생기게 된다.\nFigure 16: git clone\ngit checkout [head 이동명령어] git checkout은 Head를 이동한다. 그리고 그 Head가 가리키는 commit의 working directory를 복원한다. git checkout은 commit을 하느냐 혹은 branch를 하느냐에 따라서 그 의도가 다르다.\n1.git checkout commit 2.git checkout branch git checkout commit: 이것의 의도는, 해당 commit의 내용을 확인하기 위해서다. Head가 해당 commit으로 이동하면서, 그 commit의 working directory를 복원하기 때문에 실제 그당시, 그 commit의 source를 볼수가 있다. 그런데, 여기서 수정은 할 수 없다. 왜냐? 수정을 하고 commit을 하면, 수정된 commit은 수정되기 이전의 commit을 가리킬 수는 있다. 하지만, 해당 linked list의 branch에선 이 새로운 commit으로 이동할 수가 없다. link가 없기 때문이다. 그러면, 이렇게 수정한 commit은 접근할수 없는 미아 commit이 되고 나중에 git garbage colloector에 의해 사라지게 된다. 그렇다면, 수정을 한 후 저장만 하고, commit을 안하면 그냥 갱신된 내용의 commit을 유지하지 않을까? 이것도 안된다.왜냐하면, commit의 내용이 수정되었다는 것은 content addressable한 commit의 특성상 새로운 commit이 되어 야만 한다. 그래서 수정을 하고 저장을 했다 하더라도 git은 동작을 전혀 할수가 없다. 왜냐, git status에 보면, commit에 변경사항이 생겼는데, 이를 처리하지 않아서 아무것도 할 수 없다고 말한다. 그러면 선택은 2가지다. 새로운 commit을 만들거나, unstage하는 경우다. 새로운 commit을 만드는 것은 방금전에 설명한 이유로 안되고, 2번째는 unstage하는 것이기 때문에 commit이 수정되기 전의 상태로 되돌려진다. 즉 수정이 아예 안된다.\nFigure 17: git checkout commit\ngit checkout branch: 이것의 의도는 해당 branch가 가리키는 commit으로 working directory가 복원되고, 수정도 할 수 있고, 새로운 commit을 만드는 것도 가능하다. content-addressable하기 때문에 수정이나, 새로운 commit을 만드는 거나 동일한 일이다. 이전에 설명했듯이, linked list는 하나의 주머니로 봐도 되고, 또한 주머니의 입구는 branch로 비유할수도 있다고했다. 여러 주머니가 있을 경우, 특정 주머니를 선택해야 하는데, 좀 더 정확히는 특정주머니의 입구를 선택해야 한다. 왜냐면, 그래야 commit을 담을 수 있기 때문이다. git checkout은 특정주머니의 입구를 선택하는것이다. 그림으로 보고, 설명한다면, Head를 branch로 움직이는 명령어를 git checkout으로 말할 수 있다. Head를 branch로 움직이는건 일반적이고, 정상적인 동작이다. 특정 commit으로 이동도 가능하지만, 그러나 그런 이동은 위에서 말한바대로 source를 보기위한 목적이다. 수정은 추천되지 않고 바람직하지 않다. 왜냐? history가 깨질 위험이 있기 때문이다. history가 깨진다는 것은 여러 사용자가 공유하는 git이 동기화하는데 문제가 생길 수 있다. 그래서 git에선 commit으로 head를 이동해서 수정하는 것을 허용 하지 않는다.\nFigure 18: git checkout\ngit log git log는 head를 기준으로 최초 commit까지의 모든 commit들을 보여준다. 그런데 Head의 원래 역할은 branch를 선택하는게 주 역할이기 때문에, 그 기준으로 살펴보겠다. 즉 branch로 부터 최초 commit까지 모든 commits(history)를 본다고 생각하자. git에서 branch는 linked list라는 주머니의 입구다. 그 입구로 넣어진 commit들은 차곡 차곡 안쪽부터 넣어진다. 그리고 각각의 commit은 연결 되어 있다. 제일 처음 넣어진 commit은 연결이 없다. 그 다음 commit은 처음 넣어진 commit을 가리키고 있다. 주머니안으로 넣어진 commit은 이렇게 단방향 link로 되어 있다. 반대 방향으로 link는 없다. git log는 해당 branch, 즉 주머니의 입구에서 주머니 안쪽의 commit들을 보는 것이다.\nFigure 19: git log\n위 그림에서 2개의 주머니가 보인다. 하나는 Testing이란 입구를 가진 주머니, 또 다른 하나는 master란 주머니가 있다. Testing이란 주머니에서 git log를 하면, E - B - A를 볼 수 있다. Master란 주머니에서 git log를 하면 D-C-B-A를 볼 수 있다. 이렇게 볼 수 있는건 parent란 link가 commit사이를 연결하고 있기 때문이다. 이것은 단방향이기 때문에 branch에서 주머니의 마지막 commit까지 보이는거지, 반대로 주머니끝에 있는 commit에서 branch방향으론 볼 수 없다.\ngit reset [branch 이동] git reset은 branch를 이동하는 명령어다. branch를 움직이기 위해선, 우선 branch가 선택되어야 하기 때문에 HEAD가 branch를 가리키고 있을 것이다. 이 상태에서 git reset commit 하면, 해당 commit으로 branch가 이동하게 된다. 이 이동은 좀 위험한게 있다. 해당 commit으로 이동하면 branch가 있던 commit으로 되돌아갈 방법이 없다. link가 없기 때문이다. history가 깨지는 문제가 있다.\nFigure 20: git reset\ngit merge git merge는 2개의 linked list를 합치는 것을 의미한다. 다르게 표현한다면, 2개의 branch를 합한다고 말해도 된다. 또는 2개의 line을 일치시킨다라고 말할 수 있다. branch를 이동하는 명령어의 일종이기도 하다. 이렇게 merge를 하면, 동일한 하나의 linked list가 만들어진다. 그런데, 2개의 linked list가 하나의 linked list를 가리킨다는건 비효율적이기 때문에 필요없는 branch는 보통 지운다. 근데 왜 merge를 하는가? 왜 linked list를 합쳐서 하나로 만드는가? 여기에 대한 대답은 git workflow에서 설명이 되겠지만, 간단히 설명하자면, 하나의 제품을 만들기 위해서라고 말할 수 있다. 여러사람이 각각의 소스를 가지고 있는데, 그것을 하나로 모아서 build를 해야 실행파일이 만들어진다. 멀리떨어져 있는 개발자들끼리 어느날 한날 한시에 모여서 노트북에 있는 소스를 하나의 컴퓨터에 모아서 copy \u0026amp; paste해서 하나의 프로그램으로 합치고 실행하고 bug고치고 그렇게 하지 않는다. 이건 아주 옛날 방식이다. 2명이서 게임을 개발하는데, 한명은 client, 다른 한명은 server를 작성한다고 하자. client와 server를 합쳐야 프로그램이 실행이 된다. 두개의 source code를 합쳐야 한다. 이때 merge를 사용한다. 자세한 내용은 git workflow서 설명하기로 하자.\nmaster: git merge testing(branch명) : master branch가 이동한다. testing branch가 이동하는게 아니다. 2가지 경우가 있다. 이것을 2 way merge(fast-forward), 3 way merge가 있다.\n2 way merge\n2-way merge는 2개의 linked list가 동일한 line을 갖는 경우를 말한다. 아래 그림을 보면, master의 위에 testing이란 branch가 같은 line에 있다. upstream에 testing이 있다고 표현하기도 하지만, 이 경우, 두개의 linked list는 동일한 분기를 하고 있고, 서로 다른 분기를 갖지 않기 때문에, 합친다는 건, 그냥 간단히 master가 testing의 위치로 가던가, 아니면 testing이 master의 위치로 가면 된다. master를 testing위치로 가게 하려면, master로 우선 선택해야 한다. git checkout master를 사용한다. 그다음 git merge testing을 실행하면, master를 testing으로 이동 시킨다. 반대로, testing을 master위치로 이동 시키려면, git checkout testing으로 head를 testing으로 이동한 후, git merge master라고 하면, testing branch가 master로 이동한다.\n2 way merge는 conflict가 발생하지 않는다. 2개의 branch중 1개의 branch를 선택하는것이기 때문이다. 더 긴 line을 갖는 linked list가 작은 line으로 merge된다면 commit을 잃을 순 있어도 conflict는 없다.\nFigure 21: git merge(fast forward)\n3 way merge\n3 way merge가 더 일반적인 경우고 conflict가 일어날 확률이 있는 merge다. 아래에서 충돌이 일어나는 경우를 설명한다. 충돌이 일어나지 않는 경우는 merge commit이 자동으로 만들어지고, 충돌이 일어나면 수동으로 merge commit을 만드는 차이가 있다.\n여기서 b.txt란 파일이 양쪽 linked list에 둘다 있다. 그럼 반드시 충돌이 일어나게 되어있다. 왜냐 어떤 linked list에 있는 b.txt를 선택할지 모르기 때문이다. 아니면, 두개의 contents를 무리하게 하나의 파일로 만들 수도 있겠지만, git은 그렇게 하지 않는다.\nFigure 23: 3way merge 2\n위 그림 보면, b.txt가 양쪽 linked list에 있기 때문에, stop된다. conflict를 수정하기 전에는 merge가 되지 않는다. 수동으로 수정하고 commit을 만들어야 한다. 여기서는 하나의 b.txt만 충돌하지만, 10개의 파일이 충돌이 났다면, 일일이 수정을 해야 한다. b.txt를 편집기로 열면, git이 이미, 충돌 부분을 표시해 놨다. 사용자는 source를 수정한다. 그리고 내용이 바뀌었기 때문에 commit을 만든다. 그러면, master branch가 선택된 상태에서 commit을 만들기 때문에 master branch는 새 commit을 가리키게 된다. 이 commit이 merge commit이다. 이 과정이 끝난 후의 git은 다음과 같이 merge되어 있다.\nFigure 24: 3 way merge 3\nsummary\n2way merge는 그냥 branch이동에 불과하다. 3way는 합칠려는 line이 다르기 때문에, conflict문제가 발생하고 이를 처리해야 하는 어려움이 있다. 그런데 git이 conflict에 대해 해주는 것은 어떤것이 충돌이 났는지 표시만 해줄뿐이다. 이것이 어떤 의미냐면, 파일이 수정되었기 때문에, 새로운 commit을 만들어야 한다는 것을 내포한다. content addressable하기 때문에 기존의 content의 변화가 생겼기 때문에, commit을 어쩔수 없게 만들게 한다. 여튼 git은 conflict에 대해, 하는건..이거 하나다. 실질적으로 사용자가 source를 수정하고 반영해서 git add하고 git commit해서 새로운 commit을 만드는것이다. 이것을 merge commit이라고 한다. merge commit은 수동으로 사용자가 만드는 commit이라는 것을 명심하자. git이 만들어주는게 아니다. 그런데 충돌이 없다면? 자동으로 git이 merge commit을 만든다.\ngit rebase rebase는 base를 옮긴다. A와 B의 base가 C라고 하자. 만일 A가 base를 C가 아닌 B로한다면, A는 우선 B를 가리키고, A와 C사이에 있던 commit들은 갱신되어서 추가된다. 왜냐 base가 바뀌었기 때문에 history를 나타내는 commits도 바껴진 base에 맞추어 내용이 변경되기 때문에 새로운 commit들이 만들어지는 것이다.\nrebase란 말은 base를 다시 정한다는 말이다. base라는 것은 common ancestor를 의미한다. common ancestor가 있다는 얘기는 우서 linked list가 2개 이상이라는 의미이다. 그러면 branch도 2개 이상임을 알 수 있다. 이런 조건에서 rebase명령은 사용될 수 있다. 그런데, 왜 base를 재 지정하는가? diverge된 2개의 linked list는 서로 다른 방향을 향하고 있다. 언젠가는 2개의 linked list를 합쳐야 하는데, 방향이 다르기 때문에 충돌이 일어날 가능성이 매우높다. 그것을 방지하게 하려면 방향이 같게 만들면 된다. base를 다른 branch로 정해주면, 동일한 방향을 갖는 line이 만들어지고 이것은 충돌을 예방할 수 있다.\nFigure 25: git rebase 1\n제일 먼저 master branch를 base로 할려는 branch로 이동 시킨다.\nFigure 26: git rebase 2\n그 다음 master와 base사이에 있는 commit들은 위에서 정한 새로운 base와 diff를 통해서 새로운 commit들이 만들어진다. Head가 master에 있기때문에 만들어진 commit들은 master가 가리키게 된다.\nFigure 27: git rebase 3\ndiff로 비교했던 commit 두개는 B라는 commit을 가리키고는 있지만, branch가 아래로 내려갔기 때문에 garbage collector에 의해서 사라진다.\nFigure 28: git rebase4\nsummary\nrebase는 반드시 특정 branch를 base로 하지 않고 특정 commit을 base로 할 수도 있다.\nFigure 29: rebase summary\n위 그림에서 testing은 base를 X라는 node로 바꾸고 싶다. 그러면 rebase를 명령하기 위해서 git checkout testing으로 testing branch를 선택하고 git rebase X라는 명령을 수행한다. 그러면 아래처럼, branch가 new base로 이동한다.\nFigure 30: rebase summary 2\nA라는 commit과 new base라는 commit이 diff과정을 통해서 new commit이 만들어진다. branch가 있는 가운데 new commit이 만들어졌기 때문에 testing branch가 new commit을 가리키게 된다. A라는 commit은 branch에서 보이지 않는 commit이기 때문에\ngit push git은 단방향 linked list를 사용한다.그리고 linked list의 Node는 content addressable한 특성이 있다고 했다. content addressable하다는 것은, 파일이름이 같아도 내용이 다르면, 서로 다른 Node(commit)가 된다. content가 다르기 때문이다. 그래서 git에서 사용하는 linked list는 일반적인 data structure의 linked list와는 동작이 다르다. 일반적인 단방향 linked list는 중간 Node를 수정하는게 가능하지만, git은 content addresable한 data를 취급하기 때문에 수정이나 변경은 새로운 Node를 만드는 것이 되어버린다. 그래서 일반적인 data structure의 갱신처럼 동작을 하려면, 삽입을 해야 하는 식으로 흉내를 낼 수 있다. 그런데 새로운 Node를 추가하는 것은 linked list에서는 head에서만 가능하다. 이것을 보장해야 한다. 이게 git의 기본적인 특성이다. git push를 설명하는데, 왜 이런 기본적인 내용을 설명하냐면, git push에서 이런 기본적인 내용을 바탕으로 동작을 이해해야 하기 때문이다.\ngit의 push,pull,fetch와 같은 명령어는 local에서 사용하는게 아닌 원격지에 있는 git을 사용하는 것이기 때문에 git이 remote에서 어떻게 동작하는지 알아볼 필요가 있다. 원격의 git이 있다고 가정하자. 우리가 원격의 git을 가져오는 방식은 2가지가 있다.\n1. git clone URL 2. git remote add name URL 1번의 경우는, URL을 다른이름으로 기술하지 않는한, origin이라는 이름을 갖는다. 그리고 remote branch는 origin/master가 된다. remote git의 URL을 다른 이름으로 mapping하지 않고, branch도 다른이름으로 mapping하지 않으면, default name이 origin과 master이다.\n2번의 경우는, git url이 가리키는 git에 이름을 부여하는 것이다. 이 경우 실제 remote git commits을 가져올려면 git fetch같은 명령어를 써야 한다.\n둘다, origin/master라는 server의 특정 branch를 가리키는 branch가 생기는데, 이 branch는 움직일수 없다. 마치 bookmark처럼 움직일수가 없다. branch를 움직이는 경우는, git commit으로 새로운 commit을 만들거나, git reset으로 특정 commit으로 이동하거나, git rebase로 이동 시킬수 있는데, 이 모든게 안된다는 것이다. 가장 중요한건 아무래도 그 branch를 우리가 commit을 저장하는 linked list로 사용할 수 없다고 이해하는게 가장 편하다.\njohn과 호열이 git clone해서 특정 server에 있는 git을 local로 가져왔다고 가정하자.\nFigure 31: git push 1\nclone을 하면 server의 linked list를 가져오게 된다. origin/master라는 server의 branch가 보여진다. 그리고 master라는 또다른 local linked list가 자동적으로 만들어진다. origin/master는 server와 동기화 될때 갱신되고, local master는 우리가 작업하는 branch라고 보면 된다. 간단한 예로, John이 새로운 commit을 만들어서 server에 반영했다고 하자.\nFigure 32: git push 2\n별 문제가 없다. 이제 호열이 B라는 commit을 만들고 push해보자.\nFigure 33: git push 3\n에러가 난다. 호열은 push를 할 수 없다. 호열이 origin/master라는 server의 linked list의 head에 commit을 붙일려고 하지만, 할수없다. 왜냐면,음\u0026hellip;호열은 origin/master branch는 Node를 삽입할 수 있는 linked list란 주머니의 입구라고 생각해서 push했는데, john이 이미 push를 해서, head가 이동했다. 호열이 생각한 server의 master는 이동을 했기 때문에 삽입이 불가능해진것이다. linked list의 삽입은 branch, 즉 head에서만 가능한데, head가 옛날 head였던 것이다. 위에서 말했듯이 linked list는 head가 아닌 다른곳에서의 삽입은 불가능하다. 여튼 이런 일은 매우 빈번하게 발생한다. 10명의 개발자, 100명의 개발자가 일을 한다면,서버에 계속해서 commit을 올리고, 이 commit이 삽입된 순간, server의 branch는 이동을 한다. local에서 참조하는 server의 branch는 옛날 데이터 삽입구다. 그래서 commit을 올릴수가 없게 된것이다. 그래서 항상 push하기 전에 server의 git을 pulling or fetch해서 입구를 확인한다음에 push를 해야 하는 것이다.\ngit pull git reflog git tag git tag는 branch가 아니다. tag는 release를 나타내는 표지판 같은 역할을 할 뿐이다. 두가지 종류의 tag가 있는데, 그리 중요하지 않다.\ngit drill5 git repository 여기서는 repository가 한개만 쓰이는 (1인개발자가 사용하는 그런) minor한 경우를 다루지 않는다. 2개이상의 repository가 사용되는(즉, 협업을 하는) major한 경우를 다루고자 한다. 그럴려면, git repository에 대해서 좀 생각을 해봐야 한다. git repository란 일반적으로 commit이 저장되는 공간을 뜻한다. 물론, commit, tree,blob과 같은 object도 있고, branch,head,tag와 같은 reference도 그 repository에 저장이 된다. 그런 구조 말고, 좀더 본질적으로 말해보자. repository는 자료구조다. commit이라는 data를 저장한다. commit은 단방향 linked list로 저장이 된다. 이것은 마치 지렁이게임의 지렁이와 같다. 먹이를 입으로 먹으며 한없이 길어지는 지렁이\u0026hellip; 이런 지렁이들이 git repository에는 10개, 100개, 10000개가 있을 수 있다. 그런데 그 지렁이들의 공통점이 있다. 그들의 꼬리는 모두 하나의 commit을 공유한다는 것이다. 즉, 태초의 commit으로부터 branch라는 입이 생겨서 계속해서 commit을 먹어서 길어지긴 하지만, 모두 1번째 commit을 갖는다. 그것이 git repository의 본질이다. 그림으로 그려보자.\nFigure 34: basic linked list\nFigure 35: basic linked list2\nFigure 36: basic linked list3\nrepository의 본질을 얘기하면서 최초 commit은 모든 repository내의 branch가 가지고 있다는 것을 강조했다. 왜냐면 우리가 사용할 remote repository, local repository는 모두 하나의 뿌리로부터 파생된 branch를 갖는다. 단 한개의 뿌리를 갖는 tree처럼\u0026hellip; 그렇기 때문에, 우리가 git remote add origin1 url, git remote add origin2 url \u0026hellip; 이런식으로 여러 remote에 있는 repository를 내 local repository를 가져온다고 해도, 실제는 해당 remote repository는 같은 뿌리를 갖는다. 물론 내 local repository조차도 그렇다.\n예를 들어서, 삼성전자의 repository가 있고, LG전자의 repository가 있다고 하자. 내가 local repostiory에서 그 2개의 repository를 가져올 수 없다. 하나는 clone하고 다른 하나는 fetch를 해도 안된다. warning이 발생한다. 그 이유로 최초 commit이 다르다. common commit이 없다. 만일 최초 commit이 같다면, 우리는 하나의 .git폴더에서 관리할 수 있게 된다. 그런데, 이 2개의 repository는 서로의 .git폴더를 가지고 있고, 서로 다른 2개의 working directory를 가져야한다. 그런데 우리의 local repository는 단1개의 working directory와 단 1개의 repository다. 그 repository에서 삼성전자는 clone했고, Lg전자는 fetch로 가져올려고 해도 서로다른 repository이기 때문에 1개의 local repository에 담을 수가 없는 것이다. 반면에 commit이 같다면, 우리는 10개의 repository,100개의 repository가 있다해도, 1개의 repository에 담을 수 있다. 물론 branch의 수는 늘어날 것이다. 이것을 그림으로 표시해 보겠다.\nFigure 37: repo 1\nFigure 38: repo2\n위에 처럼 뿌리가 같기 때문에 하나의 local repository에서 관리가 가능한 것이다. 뿌리가 같지 않으면 다른 repository를 현재 작업중인 local repository에 가져오질 못한다. 또 다른 예로, 자신이 local repository에서 자신만의 project를 개발하고 있는데, github에서 어떤 비슷한 project를 발견해서 이를 git clone이나, git fetch로 가져와서 내 repository에서 작업하고 싶다. 가능할까? 당연히 안된다는 것이다.\ngit 원격저장소와 관련한 용어들 1. Upstream, Downstream git 사용, 특히 remote repostiory와 관련해서 알아야 할 용어가 있다. 이런 용어를 알아야만, git push, git pull과 같은 동작을 이해 할 수 있기 때문이다. 혼자 개발 하지 않고, 여러사람이 협업을 한다면, 여러사람이 공동으로 사용하는 repository가 필요하다. 자신의 repository가 아닌 repository를 remote repository라고 부른다. 협업시 local repository는 remote repository부터 자신이 가지고 있는 commit이나 branch를 내려받기 때문에, stream에 비유해서 remote stream을 upstream이라고 하고, local repository를 downstream으로 사용하기도 한다.\nFigure 39: stream\n2. remote branch,tracking branch,local branch 위 3가지 용어는 협업시 local repostiory에 있는 branch의 종류다. remote repository를 사용해서 협업하는 경우, local에서 git clone이나, git remote add name URL을 한 후, git fetch를 해서 remote repository을 가져와야 한다. 이것을 가져오면, 위에 말한 3개의 branch를 볼 수 있다. 그래서 git clone을 해서 가져오는 경우와, git fetch를 가져오는 경우를 설명하면서, 이 용어를 설명하겠다.\ngit clone의 경우\ngit clone을 하면 remote repository의 모든 요소를 다운받는다. 하지만, git branch라는 명령을 내리면, master라는 branch만 보인다.\nFigure 40: real clone\ngit fetch의 경우\ngit fetch를 하면 remote repository의 모든 요소를 다운받는다. 하지만 git branch라는 명령을 내리면 아무것도 보이지 않는다.\nFigure 41: real fetch\n설명\n위 그림에서 오른쪽에 보면, origin/master, origin/issue33가 보인다. 이것을 remote branch라고 부른다. remote란 단어가 좀 혼란스럽게 만든다. remote branch라고 하면 server에 있는 branch를 생각한다. 물론 그것을 가리키는 것도 맞고, local repository에 있는, origin/master, origin/issue33같은 branch도 remote branch가 맞기 때문이다. 실제 local repository의 remote branch(origin/master)를 진짜 원격지 branch로 보고(생각하고) 작업을 한다.왜냐면, origin/master라는 것은 실제 server와 동기화된 branch이기 때문이다. 그래서 인터넷이 연결 안되어 있는 상태에서도 git을 사용할 수 있다고 하는 것이다. 왜냐면 어차피 인터넷을 연결하고 있어서도 실시간 동기화를 하는게 아니기 때문이다. git fetch나 git pull로 동기화를 하기전까지는 local의 remote branch를 보고 작업을 하기 때문에 인터넷이 연결되지 않은 상태로, 원래 작업을 하는 것이다. git pull과 git fetch를 하기전까진 어차피 offline작업일뿐이다.\ntracking branch\n위에서 git clone과 git fetch의 가장 큰 차이점은 tracking branch이다. git clone은 tracking branch를 만들어주지만, git fetch는 tracking branch를 만들지 않고 server에 있는 linked list를 그냥 가져오기만 한다. 즉 remote branch만 있다. 그럼 tracking branch가 무엇인지 설명해야 하는데, 이게 좀 길 수 있다. 간단히 얘기하면 git push와 pull은 tracking branch를 필요로 한다는 것이다.\nremote branch는 local에선 보이지 않는다. git branch해도 안보인다. 또한 checkout해서 새로운 commit을 만들수도 없다. 그래서 remote branch는 단순히 서버와의 동기화를 위해 bookmarking역할만 하는 branch이다. 다시 한번 더 설명하면, remote branch는 git branch 명령어로 보이지 않는다. 물론, git branch -a 나 git branch -r을 사용하면, 볼수 있다. 오 그래? 그러면 git checkout origin/master명령어를 실행해서, 그 branch로 HEAD를 이동한 후에 commit을 만들면 되는거 아냐? 그러면 remote branch에 commit을 추가했으니 동기화하면 되는거 아니냐구? 안된다. 우선 bookmark branch는 commit을 만든다고 bookmark branch가 새로운 commit을 가리키지 않는다는 것이다. bookmark branch가 이동하는 경우는 오직 한가지, 서버와 push,pull,fetch등으로 동기화할 때만 움직인다. 그러면 새로운 commit을 만든다고 해도, Head만 그 commit을 가리킬 뿐이다. branch에서 떨어져나간 HEAD가 commit을 가리켜봤자, 그 commit은 server에 push될 수 없다. push라는 동작은 우선 local에서 동작된다. local에 있는 remote branch의 위치를 현재 tracking branch의 위치로 이동 시킨다. 그런다음 remote branch(origin/master)를 진짜 server의 master branch에 넣는 과정이 필요한데, 우선 Head가 가리키는 branch자체가 없다. 그래서 remote branch는 이동할 수도 없다. branch가 있다하더라도 tracking branch여야 하는데, 단지 새로운 commit만 만들어서 이를 push하는건 될수가 없다는 것이다. push를 할려면, branch가 필요하고, 해당 branch가 특정 remote branch의 tracking branch일때만 push가 된다.\n그런데, 우리가 remote repostitory를 local에 clone이나, fetch 즉, 복사하는 이유는 협업을 하기 위한거였다. server로부터 branch와 commit을 다운로드해서 history를 볼려는 게 아니라, server에 내가 만든 commit을 추가하는 협업을 원한건데, remote branch에 checkout해서 commit을 만들어도 안된다니 그러면 어떻게 하라는 건가? 그래서 tracking branch가 필요한 것이다. 우리가 다운받은 remote branch라는 것들은 commit 삽입이 안되기 때문에 remote branch와 동일한 이름을 갖는 local branch를 만들고, 이것이 tracking branch라고 git에게 알려주기만 하면 우리는 push로 local에서 만든 commit을 server에 전송할 수 있는 것이다. 즉 tracking branch가 필요한것은 commit을 upstream에\n올리기 위해서 필요한거다.\n요약하면, tracking branch는 local branch이다. server에 있는 remote branch에 commit을 올리기 위해 만들어진 local branch이다. 원격 server의 branch나 commit들을 git fetch나 git pull을 사용해서 가져오는 것은 별 문제 없으나, server에 local의 commit을 올릴려면 tracking branch가 있어야 한다. 다운받은 server의 branch들은 모두 bookmark branch라서 commit이 추가 될 수도 없기 때문에 tracking branch에 commit을 추가하고 올린다.\nFigure 42: branch term\n이제 좀 더 자세하게, git push, git fetch, git pull을 살펴볼 것이다.\ngit clone 위에서도 설명했지만, server에 있는 git repository를 온전히 local로 가져오는 명령어는 git clone과 git fetch가 있다. 그런데 온전히 모든것을 local로 가져오더라도, local에서 remote branch에 commit을 추가할려면, tracking branch가 필요하다. local에서 remote branch들은 sync를 위한 bookmark branch이기 때문에 commit이 추가가 안된다. git clone은 git fetch와 달리 tracking branch를 하나 만들어준다. 어떤 remote branch의 tracking branch인것도 중요한데, 보통은 Head가 가르키는 branch이다. 원격 서버의 master branch를 tracking하는 branch를 처음부터 default로 만들어주게 된다. 그래서 tracking branch의 이름은 master 이다. 다시 말하면 server의 HEAD가 가리키는 branch는 보통 master를 가리킨다. 이런 server의 repository를 clone하면 server의 master branch에 commit을 push할 수 있는 동일한 이름의 tracking branch를 local에 만드는데 그게 master라는 branch이다. server에 수많은 remote branch가 있을 수 있다. 그리고 그 branch를 git clone이나 git fetch는 모두 local repository에 복사하기 때문에 해당 branch로 checkout해서 어떤 내용인지 볼 수는 있다. 하지만, 수정은 불가하다. 예를 들어서, 내가 origin/master에 checkout했다고 하자. 그리고 복원되 working directory의 특정 파일에 수정을 한다. 그러면 stage에 올라가고 난 commit을 한다. 정상적인 branch라면 이렇게 만들어진 새로운 commit을 가리켜야 하는데, bookmark commit인 origin/master는 새로운 commit을 가리키지 않는다. 왜냐하면, orign/master는 bookmark branch이기 때문이다. bookmark branch는 오직 server와 동기화를 위한 branch라서 동기화할 때만 움직이고, 새로운 commit을 가리키지 않는다. 그래서 track branch라는 local branch가 필요한것이다. 100개의 remote branch를 다운받았어도, push로 commit을 반영하려면, tracking branch없이는 안된다.\nFigure 43: git clone\ngit fetch git fetch는 remote repository를 그대로 가지고 온다. 하지만, tracking branch를 만들지도 않는다. git fetch를 하면, local에 있는 bookmark branch를 갱신한다. 즉 동기화만 할 뿐이다.\nFigure 44: git fetch\ngit pull git pull과 git push의 동작은 역순이다. 그리고 둘다 tracking branch의 merge작업을 동반한다. git fetch는 단순히 remote repository와의 동기화만 할 뿐이다. 그런점에서 차이가 있다. git pull과 git push는 tracking branch가 있다는 가정을 한다. tracking branch가 없다면, push와 pull은 사용할 수 없다. local branch를 만들어서 push,pull을 하는 건 의미가 없다.\ngit pull 과정은 다음과 같다.\n1. 동기화(sync) 2. merge(tracking branch merges remote branch) =\u0026gt; tracking branch가 remote branch로 이동한다. git push는 git pull과 반대 과정이다. git pull 과정을 그림으로 그려보겠다.\nFigure 45: git pull\ngit push git push는 git pull동작의 반대다. git push 과정은 다음과 같다.\n1. merge(remote branch merges tracking branch) =\u0026gt; remote branch가 tracking branch로 이동한다. 2. 동기화(sync) git push 과정을 그림으로 그리면 다음과 같다.\nFigure 46: git push\ngit drill6 git을 왜 사용하는가? 요즘은 프로그램을 혼자 만들지 않는다. 협업을 한다. 협업을 하게 되면 각각의 개발자가 만든 source를 반드시 하나로 만드는, 합치는 과정이 필요하다. 그래야 프로그램이 동작하기 때문이다. 아주 오래전엔, 아마도 각각의 개발자가 각자의 source를 가지고 와서 서로 머리를 맞대고 하나의 source를 만드는 과정을 거쳤을 것이다. 그런데, git을 사용하면 이렇게 개발하지 않는다. 개발자는 세계 어느나라에 어느곳에 있던, 아무런 상관이 없다. 각각의 source가 git에만 있으면 되는 것이다. 각각의 source를 merge를 통해서 release하고, major, minor로 release하는 개발과정을 갖게 되는 것이다. 실제 git을 가지고 어떤 식으로 작업하는지 알기위해선 workflow을 알아야 한다. git workflow는 git이 실제 현장에서 어떻게 사용되는지를 보여준다.\ngit fork 협업을 위해서 fork를 사용할 수 있다. fork는 일반적으로 다른 사람이 만든 repo에 contribute하기 위해서 많이 사용한다. github에서 사용하는 명령어인데 협업을 할때도 fork를 사용한다.\n[step1] leader가 repo를 만든다. leader가 repo를 만들고 project code를 만들고, 코드를 upload한다.\n[step2] 팀원들이 fork한다. 이렇게 하면 github에 있는 repo와 똑같다고 보면 된다. clone해서 수정하고 반영할 수 있다. 수정하고 github에 push한다.\n[step3] pull request한다. pull request는 팀원들이 가지고 있는 repo의 commit은 leader의 repo와 다르다. 왜냐면 코드를 수정하고 반영했기 때문이다. 그렇기 때문에 Pull request를 보낸다.\n[step4] code review를 하고 merge leader는 받은 요청에 대해서 code review를하고 merge여부를 결정한다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/git_git_explained\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/emacs_presentation_tools\/": {
        "title": "[emacs] presentation tools",
        "tags": [],
        "content": "org에서 다른 문서로의 변환 org에서 다른문서로 변환하는데 3가지 방식이 있다.\n[첫번째방식] emacs 설정방식 emacs.org에서 설정하는 방식이 있다. 예를 들면, 아래와 같이 설정한다.\n(add-to-list \u0026#39;org-export-latex-classes \u0026#39;(\u0026#34;letter\u0026#34; \u0026#34;\\\\documentclass[11pt]{letter}\\n \\\\usepackage[utf8]{inputenc}\\n \\\\usepackage[T1]{fontenc}\\n \\\\usepackage{color}\u0026#34; (\u0026#34;\\\\section{%s}\u0026#34; . \u0026#34;\\\\section*{%s}\u0026#34;) (\u0026#34;\\\\subsection{%s}\u0026#34; . \u0026#34;\\\\subsection*{%s}\u0026#34;) (\u0026#34;\\\\subsubsection{%s}\u0026#34; . \u0026#34;\\\\subsubsection*{%s}\u0026#34;) (\u0026#34;\\\\paragraph{%s}\u0026#34; . \u0026#34;\\\\paragraph*{%s}\u0026#34;) (\u0026#34;\\\\subparagraph{%s}\u0026#34; . \u0026#34;\\\\subparagraph*{%s}\u0026#34;))) [두번째 방식] org문서 head에 작성한다. - recommend org문서의 상단에 다음과 같은것을 기술한다. 보통 yasnippet에 저장해놓고 불러다 쓴다.\n#+TITLE: #+AUTHOR: Holy frege #+DESCRIPTION: Org-HTML export made simple. #+KEYWORDS: org-mode, export, html, theme, style, css, js, bigblow #+LANGUAGE: en #+OPTIONS: H:4 toc:t num:2 #+MACRO: color @@html:\u0026lt;font color=\u0026gt;\u0026lt;/font\u0026gt;@@ #+PROPERTY: header-args :padline no #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup #+LATEX_HEADER: \\usepackage{kotex} #+latex_header: \\hypersetup{colorlinks=true} [세번째 방식] export menu에서 설정 export dispatch메뉴에서 template을 저장하고 삽입할 수 있다. 하지만, 어떻게 하는지도 모르고 불편할 듯 해서 나는 사용하지 않는다.\nFigure 1: dispatch\n요약 세가지 방식중 어떤것을 해도 상관없다. 추천하는건 두번째 방식이다.\nReveal로의 변환 org reveal 설치법 설치 org 문서를 reveal로 볼려면 C-c C-e R R로 export해서 보면 된다. C-c C-e 했을 때 Reveal 메뉴가 안보이면 설치가 안된것이다. ox-reveal.el과 reveal.js가 있어야 한다. 자세한 설치과정은 다음사이트를 확인하자. https://github.com/yjwen/org-reveal https://github.com/hexmode/ox-reveal reveal.js cdn (두번째 방법) 두 번째 방법이 있다. reveal.js를 시스템에 다운받는경우와 org mode에서 cdn을 사용하는 경우가 있다. 나는 cdn을 사용하기로 한다. org 문서 상단에 다음을 추가한다. snippet을 추가하자.\n#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js #+REVEAL_REVEAL_JS_VERSION: 4 ox-reveal.el 설치(첫번째 방법) 위의 ox-reveal에서 git을 clone한 후 ox-reveal.el을 .emacs의 lisp폴더에 넣는다. lisp폴더는 내가 만든 폴더인데, emacs를 실행할때 load할수 있게 이미 다음과 같이 setting을 했다.\n(add-to-list \u0026rsquo;load-path \u0026ldquo;Users/holy.emacs.d/lisp/\u0026rdquo;)\nlisp폴더에 넣은후에 require로 load하면 된다.\n(require \u0026lsquo;ox-reveal)\norg reveal 설정 template 일반적인 template은 다음과 같다. snippet에 저장되어 있어서 C-c s로 사용하면 된다.\n#+AUTHOR: hoyoul park #+EMAIL: holy_frege@fastmail.com #+OPTIONS: toc:nil d:nil ^:nil num:nil #+REVEAL_INIT_OPTIONS: transition: \u0026#39;linear\u0026#39; #+REVEAL_THEME: moon #+REVEAL_TITLE_SLIDE: \u0026lt;h2\u0026gt;%t \u0026lt;br\u0026gt; \u0026lt;h4\u0026gt;%a(%e) #+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js #+REVEAL_REVEAL_JS_VERSION: 4 #+REVEAL_EXTRA_CSS: ./modifications.css options #+OPTIONS: toc:nil d:nil ^:nil num:nil toc는 index다. table of contents의 약자다. d:nil은 org-roam의 경우 properties가 출력되는데, 즉 drawer를 보여줄지 말지를 결정한다. ^:nil로 한것은 _가 org export시에 subscript로 변환되는데 이것을 문자 그대로 사용하겠다는 뜻이다. num: nil은 각slide tile앞에 숫자가 numbering되는데, 그것을 막아준다.\ntheme theme는 여러가지가 있다. 보통은 moon을 추천한다. black,white,league,beige,sky,night,serif,simple,solarized,blood,moon\n#+REVEAL_THEME: moon ATTR #+ATTR_REVEAL: :frag (appear) html수정 #+REVEAL_HTML: \u0026lt;div class=\u0026#34;column\u0026#34; style=\u0026#34;float:left; width: 50%\u0026#34;\u0026gt; title수정 #+REVEAL_TITLE_SLIDE: \u0026lt;h2\u0026gt;%t \u0026lt;br\u0026gt; \u0026lt;h4\u0026gt;%a(%e) transition 시각적 효과 수정은 여러 option이 있다. 보통은 linear를 추천한다.\n#+REVEAL_INIT_OPTIONS: transition: \u0026#39;cube\u0026#39; default|cube|page|concave|zoom|linear|fade|none.\norg reveal 사용법 chrome browser에서 presentation시 전체화면 f를 누르면 된다.\nvideo 추가 @@html:\u0026lt;video controls width=\u0026#34;500\u0026#34; height=\u0026#34;300\u0026#34; src=\u0026#34;./misc/daeun.m4v\u0026#34;\u0026gt;\u0026lt;/video\u0026gt;@@ org reveal 해킹 reveal의 구조 \u0026lt;div class=\u0026#34;reveal\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slides\u0026#34;\u0026gt; \u0026lt;section\u0026gt;Horizontal Slide\u0026lt;/section\u0026gt; \u0026lt;section\u0026gt; \u0026lt;section\u0026gt;Vertical Slide 1\u0026lt;/section\u0026gt; \u0026lt;section\u0026gt;Vertical Slide 2\u0026lt;/section\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; slides라는 class아래에 section이 있는데, 우리가 흔히 말하는 슬라이드는 reveal에선 slides아래에 있는 section을 의미한다. section안에 또 다른 section이 있을 수 있는데, vertical 슬라이드가 만들어진다. vertical 슬라이드 안에 level2의 section이 별도의 슬라이드로 들어가는 형태가 된다. 즉 level1의 section은 하나의 슬라이드가 되고, level2의 section은 vertical 슬라이드가 된다. 이것을 기준으로 css를 customize할 수 있다. org mode에서의 mapping관계를 사용해서 설정할 수 있다\nfont size 위에서 설명한 reveal구조를 해킹해서 css를 적용할 수 있다. font크기를 조정하는 이유는 한글때문에 그렇다. 한글의 경우, 영문하고 다르기 때문이다.\n#+REVEAL_EXTRA_CSS: ./modifications.css font size를 조정하는 css는 다음과 같다.\n/* slide 제목 크기 */ .reveal h2 { font-size: 1.5em; /* color: #4CAF50; */ } /* vertical slide 제목 크기 */ .reveal h3 { font-size: 1.2em; /* color: #008CBA; */ } /* title slide 제목 크기 */ #sec-title-slide h2 { font-size: 1.5em; color: #FFF484; } section p { font-size: 0.7em; line-height: 2; } section li { font-size: 0.7em; line-height: 1.85; } section pre { font-size: 0.5em; color: #FFF484; } org-tree org-readtheorg readtheorg 는 아래와 같이 org에 header를 추가하는 방식으로 한다.\n#+TITLE: #+AUTHOR: Holy frege #+DESCRIPTION: Org-HTML export made simple. #+KEYWORDS: org-mode, export, html, theme, style, css, js, bigblow #+LANGUAGE: en #+OPTIONS: H:4 toc:t num:2 #+MACRO: color @@html:\u0026lt;font color=\u0026gt;\u0026lt;/font\u0026gt;@@ #+PROPERTY: header-args :padline no #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup #+LATEX_HEADER: \\usepackage{kotex} #+latex_header: \\hypersetup{colorlinks=true} org-beamer 전통적인 tex presentation 방식이다. 이걸 사용하기 위해선 system에 beamer가 설치되어 있어야 한다.\n사용법과 설치는 다음 과 다음 을 참조한다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_presentation_tools\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/emacs_tex_install_and_usage\/": {
        "title": "[emacs] tex install and usage (latex)",
        "tags": [],
        "content": "Local에서의 설치 [Local-step1] macTex 설치 mac에서는 tex배포판으로 macTex를 다은 받아 설치한다. 여기 에서 다운 받는다. mac-tex는 live-tex라는 배포판이 있는데, 거기에 mac관련 요소를 추가해서 만든 배포판이다.\n[Local-step2] tex-live update Launchpad에 TeX Live Utility가 있을 것이다. 실행한 후에 패키지 업데이트 다 해준다.\nFigure 1: texlive-update\n[Local-step3] 사설 repo등록(CTAN and KTUG) tlmgr은 brew와 같은 package manager다. brew처럼 저장소에서 package를 가져와서 설치한다. CTAN이 저장소에 해당한다. 영어로된 package는 ctan을 사용하면 되지만, 한글관련해서는 KTUG를 repository로 등록해서 한글폰트같은것을 down받아 사용할려면, KTUG도 등록해서 사용해야 한다. 여기 를 참조했다.\nmain repo 변경 sudo tlmgr option repository https://mirror.kakao.com/CTAN/systems/texlive/tlnet/ main repo를 kakao서버로 해서 등록했는데, pinning에서 version문제가 있었다. 그래서 아래와 같이 다른 repo로 변경하니 다른 에러가 났다.\nsudo tlmgr option repository http://mirror.ctan.org/systems/texlive/tlnet 그래서 다시 처음의 kakao repo를 다시실행하니 제대로 되었다. 만일 처음 실행한다면,\n사설 repo(한국)등록 sudo tlmgr repository add https://mirror.ischo.org/KTUG/texlive/tlnet ktug pinning추가 sudo tlmgr pinning add ktug \u0026#34;*\u0026#34; pinning은 ktug라는 사설저장소에서 어떤 package를 tlmgr로 관리할것인지를 정할 수 있게하는 명령어 이다. 여기서 *는 전부 등록해서 관리하겠다는 뜻이다. 그런데 다음과 같은 에러가 난다.\nFigure 2: pinning error\n이것은 main repo설치와 관련된 문제다. main repo를 제대로 설치하면 문제없이 지나간다.\n[Local-step4] 한글 폰트 다운로드 \u0026amp; 등록 step3에서 KTUG라는 사설 repo를 등록한것은 한글 폰트를 다운받기 위함이다.\nsudo tlmgr install nanumttf hcr-lvt [Local-step5] TexLIVE update 이제 전체 package를 update하자.\nsudo tlmgr update --all --self [Local-step6] XELATEX를 위한 font 설정 여기 에 보면 Mactex를 설치하기의 xelatex설정 부분이 있다. 이것을 따라한다.\n참고로 tex는 크게 tex계열과 latex계열이 있다. 두개는 모두 사용법도 다르고 구조도 다르다. 나는 tex문서를 만들고 pdf로 만들려는 목적이기 때문에 XETEX가 아닌 XELATEX를 설치한다. XELATEX가 latex계열이기 때문이다.\n위의 링크에서 Xelatex의 설정이라고 해서 xelatex에 대한 설정인줄 알았는데, 그게 아니라, mac os의 폰트 관리와 Mactex의 폰트관리가 서로 달라서 호환이 안되는 문제가 있다. 이문제를 해결하는 방법을 써놓았다. 아무래도 xelatex를 사용하는데 있어서 한글로 인한 문제가 많이 있어서 그런듯하다.\nmactex에서 system font찾기. sudo vi /usr/local/texlive/2023/texmf.cnf 파일을 열고 다음을 추가한다.\nOSFONTDIR = {~/Library/Fonts//;/Library/Fonts//;/System/Library/Fonts//} 보다시피 os의 font가 설치된 directory를 나열한다. mac의 os는 3개의 directory에 저장되어 있기 때문에, mactex가 해당 font-directory에서 font를 찾을 수 있는 경로를 추가해주는 것이다.\nsystem에서 mactex font찾기. 이제 반대로 mac에서도 mactex에 설치된 font를 가져올 수 있어야 한다. 사용자의 ~/Library/Fonts 아래에 TeX Live의 트루타입과 오픈타입 폴더를 링크해두는 방법이 있다.\n# cd ~/Library/Fonts ln -s /Library/TeX/Root/texmf-dist/fonts/truetype ~/Library/Fonts/ ln -s /Library/TeX/Root/texmf-dist/fonts/opentype ~/Library/Fonts/ 요약 이렇게 하면, local에서 설치가 끝났다. 그러면 어디서든지 tex파일을 만들고 shell에서 pdflatex를 하면 pdf파일을 만들 수 있다.\n\\documentclass{oblivoir}, \\begin{document} \\section{헬로우} 안녕하세요, Hello World. \\end{document} 예를 들어서, emacs에서 위와 같이 hello.tex를 만들고, C-c C-c를 누르면 pdf메뉴가 보인다.\nFigure 3: tex1\n근데 pdf파일을 보면 한글이 나오지 않는다. 왜냐면 기본적으로, mactex던 live-tex같은 배포폰은 영문만 지원한다. 위에서 KTUG라는 repo를 등록하고 update했다. 한글폰트도 설치했었다. 한글을 출력할수 있는 package를 깔았다는 얘기다. 다만 사용할 줄을 모르는 것이다. oblivoir라는 한글나오는 documentclass가 있다. 다음과 같이 하면 한글이 나오게 된다.\n\\documentclass{oblivoir}, \\begin{document} \\section{헬로우} 안녕하세요, Hello World. \\end{document} 한글을 나오게 하는 다른 방법으로 kotex라는 package를 설치하는 방법도 있다. 아래와 같이 하면 된다.\n\\usepackage{kotex} \\begin{document} \\section{헬로우} 안녕하세요, Hello World. \\end{document} 잠깐 한글에 대한 설명을 해야겠다. tex에서 글을 쓰는 방식은 template을 이용해서 문서를 작성한다. 가장 유명한 문서 template은 article이다. 그리고 좀 더 modern한 memoir같은 문서 template이 나오게 된다. 이 template은 모두 영어를 기본으로 한다. 한글이 안 써진다. 위처럼 한글이 pdf로 출력이 되질 않는다. 그런데 ktug라는 곳에서 kotex라는 package를 만들어서, article과 memoir같은 영어권에서만 사용하던 documentclass를 한글에서 사용할 수 있게 했다. 즉, documentclass를 article로 하고 usepackage{kotex}로 하면 한글을 쓸수 있게 했다. 그런데 한글이 조금 부자연스러워서 memoir에 한글을 잘나오게 하는 documentclass를 아예 만들었다. 이게 oblivoir다. 즉 kotex라는 package가 없어도, documentclass{oblivoir}를 하면 한글을 사용할 수 있다.\nmemoir는 book, report, article 같은 클래스의 일종입니다. 이것들 모두 외국 사람들이 만들었으니 저절로 한글 타이포그래피를 지원하지는 않죠. 예를 들자면, chapter를 \u0026ldquo;제 1 장\u0026quot;과 같은 형식으로 만들어주지는 않죠. memoir + kotex:\n한글을 쓸 수 있게 해줍니다. 폰트 설정을 하지 않아도 디폴트로 은글꼴을 쓰게 해줍니다. (함초롬으로 바꿀까 하는 얘기도 있었는데 바뀌었는지 모르겠습니다) 한글을 쓸 수 있게 한다는 것은 단지 글자들을 식자하는 데 불과한 것이 아닙니다. 자간 조정, 줄바꿈 등 여러 부분에서 한글 타이포그래피를 구현할 수 있게 해줍니다. 그러나 이것은 여전히 chapter 이름이나 contents 이름을 한글로 바꿔주지는 않습니다.\noblivoir = memoir + kotex + alpha\noblivoir는 위에서 말씀드린 것들 뿐만 아니라 다른 여러 가지 기능을 제공합니다. 한글 관련 클래스 옵션도 많이 제공하고요. 이것은 실인즉 여러 가지 한글 타이포그래피를 보완하는 하위 패키지들을 포함합니다.\n저는 이런저런 이유로 memoir + memhangul-x를 씁니다. 이 각각의 경우는 조금씩 다른 결과물을 내놓는데, 이렇게 정리할 수 있겠습니다.\n영문 문서에서 한글을 이따금 써야 할 경우 memoir + kotex\n한글 낱글자 한두 개 정도만 식자해야 하는 경우라면 kotex을 쓰지 않고 fontspec으로 한글 폰트를 쓸 수 있게 하는 것만으로도 충분합니다. fontspec 없이 xetex 폰트 명령을 이용해도 됩니다.\n오로지 한글 문서를 만들 경우 oblivoir 밖에 없습니다.\n오로지 영문 문서를 만들 경우 memoir (물론 book, report, article, koma 등 다른 클래스를 써도 되지요)\n영문 문서를 한글로 번역하는 경우, 또는 그 반대인 경우 이게 제가 memoir + memhangul-x를 쓰는 이유입니다. 쉽게 보자면 memoir나 oblivoir 둘 중 하나만 쓰면 될 것 같은데 왜 kotex를 따로 만들었느냐? (역사적으로 보면 뒤바뀐 표현이지만) book, report, article, 또는 amsmath 시리즈 클래스 등 많은 클래스들이 있는데, 그것들이 모두 oblivoir처럼 한글화(?)되어 있지 않습니다. 그러면 memoir는 한글화할 만큼 유별난 놈이냐? 그렇습니다. memoir는 다른 클래스와 비교할 수 없을 만큼 (koma 시리즈 클래스도 좋다고 하는데) 초강력 울트라 하이퍼 수퍼 만능 클래스입니다. memoir 클래스는 수식과 그래픽을 제외하면 사용자가 필요로할 법한 모든 것들을 제공합니다. memoir 설명서를 정독해 볼 만한 가치가 여기에 있습니다.\n[emacs] org 설정. emacs를 단순히 tex문서를 작성하고 pdf로 뽑아내는데 사용하지 않는다. 주로 emacs는 org문서를 작성하고 이를 pdf로 나타내는데 사용한다.\norg문서에서 한글을 사용하려면, org의 header에 다음과 같은걸 추가하는 방법이 있고, emacs.org설정파일에 설정할 수 있다.\n#+LATEX_COMPILER: xelatex #+LATEX_CLASS: article #+LATEX_CLASS_OPTIONS: [12pt] #+latex_header: \\usepackage[a4paper,top=1cm,bottom=1cm,left=1cm,right=1cm]{geometry} #+latex_header: \\usepackage{fontspec} , #+latex_header: \\setmainfont{NanumGothic} #+latex_header: \\setmainfont{Arial} #+latex_header: \\usepackage{kotex} # 줄 간격이 좁아서 늘림 #+LATEX_HEADER: \\linespread{1.4} # 페이지 마진을 줄임 #+LATEX_HEADER: \\usepackage[scale=0.8]{geometry} ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_tex_install_and_usage\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/emacs_mu4e_settings\/": {
        "title": "[emacs] mu4e settings",
        "tags": [],
        "content": "개요 emacs에서 email을 읽으려고 한다. 언뜻 생각하면, gmail, fastmail같은 email server에 접속해서 mail을 가져와서 보여주면 되는거 아닌가? 그렇게 생각할 수 있다. 근데 내부적으로는 복잡하다. emacs가 email client 같은 역할을 하지 않기때문이다. 즉, emacs는 외부에 있는 email server에 직접 연결하지 않는다. 이런 behind scene을 알아야 설정과 설치가 가능하다. 우선 emacs에서 mail server에 접속해서 mail을 보여주는 것처럼 하는 package는 mu4e다. 그리고 내부동작을 간단히 설명하면 local computer에 daemon을 하나 만든다. 이 daemon은 mbsync, offline imap과 같은게 있다. 이 daemon이 gmail이나 fastmail과 통신을 해서 자체적으로 email보관함에 넣어두는 역할을 한다. 그래서 emacs의 mu4e가 내부 daemon에 저장된 mail을 꺼내서 보여주는 형태다.\nFigure 1: overview mu4e\n우리는 mbsync라는 daemon을 사용할 것이다. mbsync는 gmail과 같은 email server와 통신을 해서 email을 가져오거나 보낸다. 둘사이에 통신방법을 정해야 하는데, 그 과정이 step1에 있다.\n[step 1] remote email server setting gmail settings 먼저 mail server를 setting한다. gmail과 mbsync와 imap을 사용해서 email을 다운받을 것이다. setting 방법은 다음과 같이 gmail에서 설정한다.\n[gmail settings]\nFigure 2: gmail settings\nFigure 3: gmail settings2\nfastmail settings fastmail에서는 imap을 enable하지 않아도 된다.\n[step 2] Client Daemon (mbsync) setting mbysync가 하는 일은 인증작업과 mail을 저장할 저장소를 만드는 것이다.\nmbsync 설치 mbsync를 local에 설치한다. mac에서 mbsync는 isync다.\nbrew install isync 인증 작업1 (openssl) openssl 설치 mbsync가 gmail이나 fastmail과 같은 email에 연결하기 위해선 인증 작업을 해야 한다. openssl을 설치하고 opessl로 인증서를 가져온다.\nbrew install openssl brew link openssl --force openssl로 인증서 가져오기 gmail\nopenssl s_client -connect imap.gmail.com:993 -showcerts 위 명령을 내리면, 3개의 fingerprint가 출력되는 데(즉, begin_certificate, end_certificate로 끝난다.), 이것이 모두 인증서다. 이것을 복사해서 저장해야 한다. 저장 위치를 난 Users/fregeholy.maildir/certs 여기에 했다. 파일 이름은 순서대로, gmail.crt, google.crt, Equifax.crt로 저장 한다. 이것을 .mbsyncrc라는 설정파일에 다음과 같이 기술한다.\nCertificateFile /Users/hoyoul/.maildir/certs/gmail.crt CertificateFile /Users/hoyoul/.maildir/certs/google.crt CertificateFile /Users/hoyoul/.maildir/certs/Equifax.crt \u0026lt;2023-07-23 Sun\u0026gt; 수정 사항\n이전에는 위의 certificatefile을 .mbsyncrc에 기술했으나, 제대로 되지 않았다.\n그래서 위 파일은 저장만 하고, .mbsyncrc에는 다음과 같이 기술 했다.\n[이전 방식]\nSSLType IMAPS\nCertificateFile Users/holy.maildir/certs/gmail.crt\nCertificateFile Users/holy.maildir/certs/google.crt\nCertificateFile Users/holy.maildir/certs/Equifax.crt\n[변경된 방법]\nSSLType IMAPS\nSSLVersions TLSv1.2\nCertificateFile /usr/local/etc/openssl@3/cert.pem\nfastmail\nopenssl s_client -connect imap.fastmail.com:993 -showcerts fastmail은 2개의 certs가 있다.\nCertificateFile /Users/hoyoul/.maildir/certs/fm.crt CertificateFile /Users/hoyoul/.maildir/certs/fastmail.crt \u0026lt;2023-07-23 Sun\u0026gt; 수정 사항\nfastmail도 위의 gmail처럼 certificate file을 만들어 저장만 하고 .mbsyncrc는 아래처럼 변경했다.\n[이전 방법]\nSSLType IMAPS\nCertificateFile Users/holy.maildir/certs/fm.crt\nCertificateFile Users/holy.maildir/certs/fastmail.crt\n[변경된 방법]\nSSLType IMAPS\nSSLVersions TLSv1.2\nCertificateFile /usr/local/etc/openssl@3/cert.pem\n인증작업2 (app password) app password .mbsynce를 설정하기에 앞서서, 인증관련 처리를 하나 더 해줘야 한다. 여기서는 gmail에서 mail을 가져오거나, 보내야 하는데, app-password를 발급받아야 한다.\napp password 발급 방법 gmail\nFigure 4: app pw\n이전 위치에서 좀 변경되었다.\nFigure 5: app pw2\n=\u0026gt; iznmiohdszmezubo 여기서 발급받은 key는 뒤에 설정할 .mbsyncrc에 pass에 넣어준다.\nfastmail\nFigure 6: app pw for fastmail\n=\u0026gt; eadu273mnpjmpt74\n.mbsyncrc 저장소 설정 ~/.mbsyncrc라는 mbsync 설정파일을 만든다. 아래 내용을 복사해서 사용한다. #------------------------------------------------------ # 2개의 imap을 사용한다. 각각의 이름을 Imap account라고 한다. # (1) gmail =\u0026gt; gmailcon # (2) fastmail =\u0026gt; fastmailcon #------------------------------------------------------ IMAPAccount gmailcon Host imap.gmail.com Port 993 User hoyoul.park@gmail.com Pass gsrupwxkyiepvjwh AuthMechs LOGIN #SSLType IMAPS #CertificateFile /Users/holy/.maildir/certs/gmail.crt #CertificateFile /Users/holy/.maildir/certs/google.crt #CertificateFile /Users/holy/.maildir/certs/Equifax.crt SSLType IMAPS SSLVersions TLSv1.2 CertificateFile /usr/local/etc/openssl@3/cert.pem #------------------------------------------------------ # gmail의 store를 정의한다. store는 group of mailbox이며, # 원격에 있는 gmail store와 다운받은 local의 store가 있다. #------------------------------------------------------ IMAPStore gmail-store Account gmailcon MaildirStore local-store Path ~/.maildir/Gmail/ Inbox ~/.maildir/Gmail/Inbox SubFolders Verbatim # ----------------------------------------------------------- #[gmail channel] channel은 동기화를 담당한다. channel을 만들면 # master와 slave의 동기화를 하겠다는 뜻이다. master와 slave는 gmail과 # local의 store를 말한다. patterns의 *는 모든 mail box를 # 뜻한다. local에서 mailbox를 만들어도 gmail에 동일하게 mailbox가 # 만들어지고, gmail에서 mailbox를 만들어도 local에 생긴다. 그런데, # maildirstore에 보면 inbox라는 mailbox가 기술된것을 볼 수 있다. # inbox는 default mailbox로 gmail server에 있다. master와 slave에 # 있는 모든(*) mailboxes를 동기화 한다. 양쪽에 없는 mailbox가 있다면 # 만든다. #------------------------------------------------------ #All mail Channel my-channel Far :gmail-store: Near :local-store: Patterns * Create Both Sync Pull SyncState * #------------------------------------------------------ # [fastmail 설정] #------------------------------------------------------ IMAPAccount fastmailcon Host imap.fastmail.com Port 993 User holy_frege@fastmail.com Pass eadu273mnpjmpt74 AuthMechs LOGIN #SSLType IMAPS #CertificateFile /Users/holy/.maildir/certs/fm.crt #CertificateFile /Users/holy/.maildir/certs/fastmail.crt SSLType IMAPS SSLVersions TLSv1.2 CertificateFile /usr/local/etc/openssl@3/cert.pem IMAPStore fastmail-remote Account fastmailcon MaildirStore fastmail-local Path ~/.maildir/Fastmail/ Inbox ~/.maildir/Fastmail/INBOX/ Trash ~/.maildir/Fastmail/Trash/ SubFolders Verbatim Channel fastmail Far :fastmail-remote: Near :fastmail-local: Patterns * Expunge None CopyArrivalDate yes Sync All Create Both SyncState * .maildir/Gmail과 .maildir/Fastmail 폴더가 없다면 생성한다.\n.mbsyncrc test 실제 email server에서 local로 메일을 가져오는지 test한다.\nmbsync -a 기본 개념 용어들 store\nstores: mailbox들을 group화한게 store가 있다. store는 remote와 local이 있다. remote와 마찬가지로 local에도 mapping되는 store가 있다.\nFigure 7: remote store\nchannel\nchannel: remote와 local의 mailbox들은 서로 대응되어 연결되어 있다. 이것을 channel이라고 한다.\nmailbox\nmailbox: store에는 mailbox들이 있다.\nFigure 8: mail box\n참고 http://manpages.ubuntu.com/manpages/xenial/man1/mbsync.1.html https://manpages.debian.org/testing/isync/mbsync.1.en.html group: channel을 묶은것을 의미한다. maildir stores: store는 mailbox의 collection을 의미한다. maildir은 local을 의미한다. IMAP stores: IMAP을 사용하는 server의 mailbox collection을 의미한다. gmail에 있는 모든 mailbox들을 나타낸다고 봐도 된다. [step 3] mu (mbsync addon) 설치 mu설치 mu는 mbsync addon으로 생각하면 된다. mbsync에서 설치한 maildir에 있는 mail들을 indexing해서 빠른 검색을 가능하게 해준다. 또한 emacs(mu4e)에서 사용할 수 있는 mu4e interface를 제공한다. mu를 설치하자.\nbrew install mu mu를 설치하면 사용할 수 있는 emacs lisp파일을 제공한다. 다음 경로에 mu4e를설정시에 사용된다.\n/usr/local/share/emacs/site-lisp/mu/mu4e mu 초기화 mu init으로 db를 만든다. mbsync로 email server로 부터 다운받은 mail저장소를 mu에게 알려주면 db에 저장한다.\nmu init --maildir=.maildir Figure 9: mu init\nmu testing mu index하면 db를 indexing을 한다.\nmu index mu find google 결과는 다음과 같다.\nFigure 10: mu find\n[step3] mu4e 설정 mu를 설치했기 때문에, db가 만들어졌고 indexing을 할 수 있다. 이제 mu4e를 emacs에 설치해서 mu에 있는 db를 가져와서 보여주면 된다.\nmu4e 설정 mu4e는 다음과 같이 설정하면 된다.\n#(add-to-list \u0026#39;load-path \u0026#34;/usr/local/Cellar/mu/1.10.5/share/emacs/site-lisp/mu/mu4e/\u0026#34;) (add-to-list \u0026#39;load-path \u0026#34;/usr/local/share/emacs/site-lisp/mu/mu4e/\u0026#34;) (require \u0026#39;mu4e) (require \u0026#39;smtpmail) (setq mu4e-maildir (expand-file-name \u0026#34;~/.maildir\u0026#34;)) (setq mail-user-agent \u0026#39;mu4e-user-agent) (setq mu4e-drafts-folder \u0026#34;/[Gmail].Drafts\u0026#34;) (setq mu4e-sent-folder \u0026#34;/[Gmail].Sent Mail\u0026#34;) (setq mu4e-trash-folder \u0026#34;/[Gmail].Trash\u0026#34;) ;; smtp mail setting; these are the same that `gnus\u0026#39; uses. (setq message-send-mail-function \u0026#39;smtpmail-send-it smtpmail-default-smtp-server \u0026#34;smtp.gmail.com\u0026#34; smtpmail-smtp-server \u0026#34;smtp.gmail.com\u0026#34; smtpmail-local-domain \u0026#34;gmail.com\u0026#34;) mu4e 기본 사용법 기본 사용법은 아래를 참고한다.\nFigure 11: 기본 사용법\nkey binding은 다음과 같다.\nFigure 12: key binding\nFigure 13: keybinding2\nmu4e 사용법 (update) C-c C-u: 언제 어디서나 update할 수 있다.\nmu4e 사용법 (편지 쓰기) M-x mu4e로 들어간다.\n편지 쓰기 (C를 누른다) ;; 언제 어디서든 Capital C를 누르면 된다.\nattachment( C-c C-a를 누른다. )\n작성을 완료한다. ( C-c C-c )\ncc 추가\nC-c C-f C-c (cc field가 만들어진다.)\nbcc 추가\nC-c C-f C-b (bcc field가 만들어진다.)\nmu4e 사용법 (답장 편지) 편지 읽기 R(reply)를 누른다. 작성을 완료한다.(C-c C-c) mu4e 사용법 (org mode에서 편지쓰기) mu4e-org를 사용한다. (require \u0026#39;mu4e-org) ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_mu4e_settings\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/test_testing\/": {
        "title": "[test] testing!",
        "tags": [],
        "content": "this is test this is test!\nhead level test (level1) main.css에 정의 되어 있다. level3 까지만 css 설정함. .page \u0026gt; .content 에서 수정하면 됨, head level1은 .page\u0026gt; .content h2로 정의됨. level2는 .page\u0026gt;.contents h3 등등\nhead level test (level2) Nullam eu ante vel est convallis dignissim.\nhead level test (level3) Phasellus lacus.\nhead level test (level4)\nFusce commodo.\nunderline orgmode.css에 정의되어 있다. test\n= test = test\npriority C-c ,\npriority1 priority2 todo C-c C-t\nTODO todo DONE todo2 verse this is verse\nnote this is note\nsource this is emacs lisp source tip this is tip\nwarning this is warning\nimportant this is important\nattention this is attention\nexample this is example table 온도 -4 -3 -2 -1 0 1 2 3 4 아이스크림 판매량 -6 -4 -2 0 2 4 6 8 10 보기 좋게 세로로 변경하자.\n온도 아이스크림 판매량 -4 -6 -3 -4 -2 -2 -1 0 0 2 1 4 2 6 3 8 4 10 ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/test_testing\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/essay_computer_working_principles\/": {
        "title": "[essay] computer working principles",
        "tags": [],
        "content": "computer의 구조 자동 제어 구조의 시작 (memory) 컴퓨터는 전기를 사용하는 system이다. system은 전기를 사용하는 device들로 이루어진 집합이다. 컴퓨터를 설명하기 앞서서 간단한 전기적 device인 motor를 예를 들어 설명하려고 한다. 모터에 배터리를 연결하자. 배터리로 전원을 공급하면, 모터는 회전한다. 언제까지? 배터리에 전원이 닳을때까지 돈다. 여기에 모터와 배터리 사이에 스위치를 연결하면 사람이 스위치를 통해서 모터를 껏다 켰다 할수 있다. 즉 제어가 가능해진다. 이런 제어를 사람의 손으로 수동적으로 하지 않고 자동화 할 수 있을까? 즉, 껏다 켯다 껏다 껏다 껏다를 손으로 일일이 스위치를 눌러서 하는게 아니라, 껏다 켯다 껏다라는 정보들을 어딘가에 기록하고 그 기록된 값이 motor에 전달되서 자동으로 할 수 있냐는 말이다. 모터가 3d printer의 부품이라고 할때, 사람의 손으로 스위치를 눌러서 motor를 이동시키고, 스위치를 눌러서 motor를 동작시키고 다시 스위치를 눌러서 motor를 중단하고 이동시키는 복잡한 작업을 계속할 수는 없다. 스위치는 mechanical한 부품이지만, 전기적인 관점에선 on/off 신호에 불과하다. 설명이 길었지만, 껏다 켯다 라는 정보를 전달하는 물리적 장치인 switch를 전기적 소자로 구현한 flip flop이란게 있다. flip flop은 on/off값을 가지지만, 0 or 1의 값을 가지고 있는 fswitch라고 생각하면 된다. flip flop은 하나의 switch를 나타내지만, 묶어서 memory란 형태로 만들면, 수백개 수천개 수만개의 스위치를 가질 수 있다. 이 말은, 이 수많은 스위치들이 수 많은 device와 연결되어서 수 많은 device를 자동제어할 수 있다는 것을 의미한다. 또한 메모리의 주소를 control(반복)해서 전기 신호를 반복해서 motor에게 전달할 수도 있다는 것을 의미한다. 즉 제어하는 모든 것들을 메모리에 올릴수 있기 때문에, program이라는 개념이 나오게 된다. 그런데 궁금한 것이 motor를 제어하는 제어코드는 motor가 아닌 memory에 있었다. memory에서 motor로 그 신호를 전달해서 동작했는데, 그렇다면 memory를 제어하는 것도 다른 memory에 있는 것인가? 하는 것이다. memory를 제어하는 code들은 어디에 있는가? memory를 제어하는 code들은 memory에 있는 것이 사실이다. memory를 동작시키는 코드가 메모리에 있다는 것은 memory가 자신의 출력을 입력으로 사용한다는 것인가? 그렇지 않다. 여기서 cpu라는게 나온다. memory는 자신을 제어하는 code들을 memory에 가지고 있지만, 그 code를, 전기신호를 입력받아야 한다. 스스로 하지 못한다. 다른 누군가가 입력으로 전달해야 한다. 그게 cpu다. cpu는 memory로부터 제어코드를 가져와서 memory를 control한다. 그럼 cpu를 제어하는 코드는 어디에 있는가? memory에 있다. cpu는 자신을 control하는 제어코드를 memory에 넣고 자신의 제어코드를 메모리로부터 입력받아서 실행한다. 이것을 보면 memory는 일종의 hub처럼 느껴진다. 연결된 device의 작동코드를 모두 가지고 있는 일종의 hub다. memory는 아래와 같이 binary code로 되어 있다.\nFigure 1: binary code\n메모리에는 있는 수많은 bit는 각각의 switch다. 각 switch들은 연결된 device들의 동작 코드를 가지고 있다. 예를 들어서 motor가 연결되어 있고, speaker, monitor, hdd, fdd, usb 수많은 device가 연결되어 있다면 memory의 어떤 영역은 speaker영역, 어떤 영역은 monitor영역, 어떤 영역은 hdd영역 이렇게 나누어져 있어야 한다. 그리고 각각의 영역에서 bit sequence는 각 device마다 다르다. 예를 들어서 motor를 turn on하는 switch가 3개라고 하면 3bit로 표시되고, monitor에서 turn on하는 switch는 5개라서 5bit로 표시할 수도 있다.\nswitch라고 하면 flip-flop이라는 전기적 소자를 생각해도 되고, 손으로 누르는 switch를 생각해도 된다. 그러면 모든 device의 동작을 switch로 제어하다가 memory의 bit로 제어한다고 하면, memory에는 제어하는 switch만 있을까? 그렇지 않다. 예를 들어서 speaker를 보자. speaker에서 제어하는 code를 언뜻 생각하면, 껏다 켯다, 볼륨도 크게 작게하는 제어도 있지만, speaker가 재생하는 음악에 대한 data도 있다. 음악에 대한 데이터는 speaker를 제어하는 switch 정보를 가지고 있는 binary가 아니다. 따라서 컴퓨터의 메모리에는 2가지 영역으로 구분했다. device를 제어하는 code들의 영역과 data의 영역으로 나누어져 있다. 그러면, 이런 생각을 할 수 있다. 난 memory에 어떤 제어코드가 있던, 어떤 data가 있던간에 모두 binary로 되어 있단 말이지. 난 복잡한거 모르겠고, memory에 임의로 내맘대로 bit로 된 data를 입력하고 싶어. 가능한가? 그리고 나는 궁금해. 컴퓨터는 내가 입력한 memory에 따라서 동작할까?\n내앞에 컴퓨터가 있다. 컴퓨터는 memory에 제어코드와 data코드를 넣어주면 그것에 따라 자동으로 동작한다고 했는데, 그렇다면, 내 앞에 있는 컴퓨터에서 바로 입력하고 싶어! 어떻게 해야하지? 떠오르지 않는다. 키보드를 사용하면 되지 않나? 그런데 키보드를 연결하고 gui로된 os에서 키보드를 친다고 메모리에 입력이 되지 않는거 같다. 동작원리를 알고 있고 컴퓨터도 바로 앞에 있는데, 메모리에 binary code를 입력하는 방법을 모른다? 답답하네. 그렇다면 개념을 알아서 뭐하냐? 메모리에 binary데이터를 입력하려면, 현재 컴퓨터에서는 os를 알아야 한다.\narduino같은 컴퓨터는 좀 더 원시적이다. arduino는 다른 컴퓨터와 연결해서 메모리에 데이터를 쓸 수 있다. arduino의 memory가 다른 컴퓨터의 메모리에 연결되는 것이다. 전기신호를 받아서 써진다. 이렇게 해서 메모리에 code를 쓸수 있다.\n두번째 질문을 살펴보자. arduino의 메모리나 지금 사용하는 컴퓨터의 메모리를 임의의 binary로 마구 마구 입력했을때 컴퓨터가 동작할 것인가? 우선 code와 data영역의 memory는 다르다는 것을 알아야 한다. code영역을 보자. 모터를 제어하는 것은 껏다 켯다하는 정보 밖에 없다. 그래서 아무런 의미없이 binary 코드를 입력해놔도 모터는 그에 따라서 동작할 것이다. speaker를 보자. speaker는 좀 복잡하다. 껏다 켯다만 있는게 아니다. 데이터 영역에서 음악을 가져와서 입력으로 줘야 하고 볼륨도 컷다 작았다 할 수 있어야 한다. 데이터 영역에서 음악을 가져오는것도 위치를 정확히 지정해서 얼마만큼 가져올지도 정해줘야 한다. 이런 동작은 speaker가 켜져 있을 때만 동작한다는 조건도 있다. 따라서 메모리에 모터와 스피커가 연결되어 있을때, 메모리에 아무데이터가 넣어져 있다고 해도 컴퓨터는 동작할 수 없다. 왜냐면 메모리에 있는 전기 신호를 어떤 device에 주어야 할지도 모르기 때문이다. motor만 메모리에 물려 있을 때는 memory에 써져있는 데이터는 0,1만 있기 때문에 모터는 memory전기신호에 맞추어 동작할 것이다. 하지만, speaker도 연결되어 있다면 어떤 device 사용할지 선택부터 해야 한다. speaker를 선택했다 할지라도 speaker는 동작하지 않을 것이다. 왜냐면 speaker를 제어하는 코드는 구조를 갖고 있기 때문이다. speaker를 키고, 데이터를 가져오고, 볼륨 조절을 하는것은 순서가 정해져 있다. 순서에 맞는 제어코드를 실행할 때만 동작하기 때문이다. motor처럼 아주 단순한 전기소자가 아닌경우 제어하는 코드들은 수많은 스위치를 사용해서 제어하고, 스위치 제어에도 순서가 있다. 스위치 대신에 binary code를 사용한다고 해서 이것이 바뀌지 않는다. 또한 제어하는 bit를 묶어서 하나의 제어명령어를 만들수 있다. 따라서 코드 메모리에 있는 제어코드들은 순서도 있고 단위도 가질수 있다. 아무렇게나 메모리에 입력되서는 안된다. 각각의 device별로 자신만의 제어코드들이 존재한다. 좀 복잡하다. 수많은 device가 컴퓨터에 연결될텐데, 컴퓨터는 각각의 device를 선택했을때 device를 동작시키는 제어코드를 다 알고 있어야 한다.이말은 programmer들은 각각의 device가 갖는 제어명령어 형태를 알아야 해당 제어코드를 메모리에 입력하고 device를 동작할 수 있게 된다. 근데 이것은 현실적으로 불가능한 얘기다. 같은 speaker라해도 회사별로 speaker 제어명령어의 구조나 순서는 제 각각일수 있다. 100종류의 speaker별로 memory에 올려서 제어한다는 것은 비합리적이다. 그래서 중앙집권적 형태가 아닌 지방분권적형태를 사용한다. computer에 연결되는 device들은 모두 각자의 memory가 있고 동작키는 제어코드들이 함수별로 존재한다. 그리고 필요한 data만 컴퓨터로 부터 받는 형태로 바뀌게 된다. 모든 device는 컴퓨터의 입장에선 file의 형태로 추상화된다. 따라서 file을 열고 file에 data를 전달하거나, file로부터 데이터를 전달 받고 file close만 한다. 이것은 각각의 device들이 스스로 자신의 메모리에 있는 제어코드를 실행한다. 컴퓨터는 device가 가진 제어코드를 처리하지 않고 device들이 자신을 제어하는 구조로 바뀌게 된다. 그러면 memory라는 전기소자를 제어하는 제어코드는 어디에 있는가? 각각의 device가 자신을 제어하는 memory를 가지고 있듯이 memory도 device다. 따라서 memory를 제어하는 제어코드는 자기 자신에 위치한다.\nmemory code structure 다시 한번 정리해 보자. computer의 메모리는 code와 data영역이 있다. 여기서 code영역만 우선 보자. code 영역에 아무런 의미없는 binary code를 입력하면, 컴퓨터는 동작하지 않았다. 왜냐하면 메모리의 제어코드는 cpu와 memory라는 device를 동작시키는 제어코드라서 각각 형식과 순서가 있기 때문이다. 이런 명령어의 순서와 형식을 갖춘 구조로 memory에 제어코드가 올라가 있어야만 실행할 수 있다.\nmemory code for file i/o 초창기 메모리의 제어코드는 cpu, memory뿐만 아니라, 모터, speaker,등 컴퓨터에 연결된 다양한 device에 대한 제어코드가 존재했었다. 그래서 해당 device에 대한 제어코드도 메모리에 있었다. 메모리에서 각 device의 제어코드를 device에 전달해서 실행시켰다. 그런데 지금은 특정 device에 대한 제어코드를 가지고 있지 않다. 컴퓨터는 device를 file로 본다. 그래서 file을 선택해서 데이터만 주고 받는다. device를 동작시키는 건 각자의 device에서 알아서 한다.\nmemory data structure 모두 string으로 되어 있다. 여기서 의문이 들 수 있다. python file이나 stdin같은 buffer에 저장되는 것은 bytecode로 되어 있을 텐데, 그렇다면 python interpreter가 입력으로 받는 것은 byte값이지 string이 아니지 않냐? 이렇게 생각할 수 있다. 예를 들어서 다음과 같은 code가 a.py에 저장되어 있다고 하자.\na = 3 이것의 bytecode는 다음과 같다.\nFigure 2: bytecode1\na.py라는 file로 저장될때 위와 같이 저장될까? 그렇지 않다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/essay_computer_working_principles\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/pl_history_of_programming_language\/": {
        "title": "[pl] history of programming language from calcuation to OOP",
        "tags": [],
        "content": "잡설 최근 modern programming language중에는 oop언어가 아닌게 없다. functional language도 그렇고 c언어로 대표되는 절차형 언어도 oop를 모두 도입했다고 보면 된다. 가장 edge 언어는 oop언어라고 보면 된다. oop언어를 왜 사용하느냐? 라는 단도 직입적인 질문에, 세상의 모든 것은 객체로 나타낼수 있다. simulate될 수 있기 때문에 oop언어를 사용한다고 말한다면 너무 불친절 할 수 있다. 세상의 모든 것을 simulate되는 것이 도데체 무슨 상관 관계가 있는가? 이런 얘기를 하려면 역사를 좀 말해야 한다.\n시작 시작을 말하려면 problem과 solving, 그리고 계산에 대해서 말해야 한다. 태초부터 인간은 호기심이 많아서, 현실의 문제를 해결하는데 계산을 사용했다. logic과 math가 그렇게 나온 학문이다. 문제를 해결하는 도구로 나온 logic과 math는 매우 비슷했지만, 달랐다. 그리고 독자적으로 발전되었다. logic의 계산은 reasoning으로 추론을 사용한다. rule of inference로 계산을 한다면, 수학은 algebra, number theory를 근간으로 해서 계산을 한다. 예를 들면 4칙연산이다. logic은 인간의 언어로 부터 ambiguous를 제거해서 좀더 formal하다. 반면 math는 logic과 유사하지만, 사용하는 언어가 아주 달랐다. 인간이 문제를 해결하기 위해서 인간의 언어를 사용하는데, 인간의 언어자체는 계산에 맞지 않았기 때문에 비슷한 logic을 사용하던가, 전혀 다른 math를 사용해야 했다. 이것을 통합하려는 시도가 일어난다. logic과 math가 비슷했기 때문에 가능했다. 즉, logic이 axiom에서 시작되는 and,or,not같은 operator를 조립해서 강력한 함수를 만들어서 사용하듯이, math도 4칙연산으로 부터 강력한 함수를 만들어서 사용할 수 있다는 것이다. 둘다 foundation으로부터 쌓아올려진 학문이여서, 그 foundation을 다른 언어로 표현할 수 있다면, 통합이 가능한 것이다. logic에서 math를 통합하려는 시도가 나타났다. math의 강력한 계산능력을 logic으로 나타낼려는 시도다. 이렇게 하기 위해선 근간이 되는 algebra를 logic으로 나타내야 한다. 그래서 나타난 것이 first order logic이다. frege가 만든건데, frege는 계산을 위한 언어로 concept script를 제시한다. 이것은 FOL을 말한다고 보면된다. FOL은 algebra를 나타낼 수 있었다. 이것이 programming language의 시작이다. 즉 FOL로 수학을 나타낸것이다. 이것을 programming language라고 말한다. concept script가 programming language의 어원이 된다. 여튼 Programming language는 computer가 만들어지기 이전에 이미 만들어진것이다. frege이후, recursion을 도입한 괴델, 함수를 lambda로 표기한 church등에 의해 발달 되서 지금까지 왔다. church nuemerals를 보면 church또한 수학과 logic이 같음을 나타냈고, 그는 function으로 모든것을 나타냈다고 주장했다. 괴델도 recursion으로 모든것을 나타낼 수 있다고 했다. 이렇게 해서 programming language는 다양한 형태로 만들어진다. church처럼 function으로 모든것을 설명하거나, 아니면 logic으로 모든 것을 설명하는 prolog같은 형태의 언어도 만들어졌다. recursion을 사용한 괴델도 괴델numbering을 통해서 비슷한 얘기를 했다. 여튼 중요한 것은 computer가 만들어지기 전에 이미 만들어져 있었던 것이다. 여기서 갑자기 천재 한명이 나온다.turing이다. turing은 church의 방식을 다른 방식으로 증명해 냈다. 그리고 그 방식은 machine을 이용하는 방식이다. 그리고 새넌의 놀라운 석사논문과 von neumann의 방식이 결합되서 computer라는 게 세상에 나오게 된다.\n참조:https://youtu.be/oippSXvxUlw 대용량 데이터의 계산 문제를 해결하기 위해서 programming language를 이용해서 명확히 기술할 수 있게 되었다. 컴퓨터가 발명되면서 기계적 방식의 계산이 가능해졌다. 실제 물리적인 기계로 계산이 되는것이다. 정신적인 영역에서 물리적인 영역으로 계산은 이동하게 된다. 이때부터 계산을 하는 물리적 device인 hw와 sw로 나눠지게 된다. 그리고 이 때 당시에 사람들이 focus하는 것은 얼마나 대용량의 데이터를 효율적으로처리할 수 있는가?에 관심을 가졌다. 우리가 지금 알고리즘과 data structure라고 부르는 것들은 이때 당시의 산물이다. coding test를 한다는 것은 얼마나 효율적으로 빠르게 대용량 데이터를 처리하냐에 focusing이 되어 있다. 여기에는 현실세계에서 사용되는 data를 programming이 제공하는 data로 변환하는 작업이 필수적으로 따라오게 된다. 인간이 처리하는 data는 매우복잡한 data다. 수학에서 사용하는 수치가 아니다. 인간이 문제를 해결하기위해 현실의 문제를 수치화 해서 수학으로 풀어왔다. 프로그램이 만들어져서 수학의 모든것을 표현할 수 있지만, computer는 또 다르다. computer는 memory라는 device를 사용하기 때문에 모든 data는 선형으로 표시되며, ordering을 갖는다. 수학과 다르다. 수학에서는 현실의 문제를 수치화 할때 set이나,tree,graph형태의 structure를 사용해서 표현할 수 있다. ordering이 없어도 표현하고 이를 푼다. 하지만, computer에서 모든 data는 선형적으로 저장되고 ordering이 존재한다. programming language에서 이런 수치 데이터를 data structure라는 형태로 변환해서, 즉 전처리해서 사용한다. 어떻게 전처리해서 표현하느냐가 computer로 수행되는 program을 효율적으로 만들 수 있다.\n여튼 우리가 지금하는 coding test는 이시대의 산물이다.어떻게 인간이 다루는 data를 수치화 하거나, program이 사용하는 data형태로 변형해서 주어진 computer에서 얼마나 효율적으로 동작하게 만드는가? 그것이 focusing되어 있다.\nGUI와 OOP의 등장 GUI가 등장하기 전까지 programming은 대용량 데이터의 효율적인 계산에 focus를 두었다. 하지만, os가 cli 방식에서 gui방식으로 변경되면서 programming의 paradigm이 변하게 된다. 계산에 focus를 두기 보다 재사용성에 focus를 두게 된다. 생각을 해보자. GUI OS에서 모든것은 window로부터 시작된다. button,title bar같은 widget으로 만들어져 있는 window는 programming의 단위가 되버린다. 어떤 program을 짜더라도 window 로 부터 시작된다. 매번 window를 만들어서 사용해야 할까? 재사용이 해결되지 않고는 GUI OS 자체를 사용할 수 없게 된다. 여기서 OOP라는 개념이 사용되어 window 재사용 문제가 해결된다. smalltalk,c++,java,델파이같은 언어들은 기존의 pascal, c와 다르게 OOP방식으로 programming을 하고, GUI와 친화적이다. 왜냐면 GUI OS를 도입할때 생긴 재사용의 문제를 해결한 언어들이기 때문이다. 그런데 OOP언어를 설명할때, 이 세상 모든 것은 객체다. 모든것은 객체로 표현될수 있다고 한다. 이런 설명은 갑자기 나온건 아니다. 물론 system자체가 window라는 무거운 코드로 대체되면서, 무거운 코드를 재사용하기 위해서 나왔지만, 원래 그런 개념을 가진 언어가 있었다. 초창기 언어중 하나인 simula67에서 현실의 thing을 simulate하는것에 관심이 있었고 그 이전에 철학적으로 이 세상 모든 것은 object로 구성되어 있다는 Aristotle의 생각이 있었다. 그래서 세상의 모든 것을 흉내내는 simula에 방점을 찍은 언어와 개념이 OOP언어가 되는 것이다. 세상의 모든 것을 흉내낼 수 있다는 paradigm이 oop언어의 핵심적인 특징이 된것이다.\n우리가 computer에서 자판기라는 현실에 존재하는 machine을 simulate(흉내)낼 수도 있다. 이때 대용량 데이터 처리는 관심이 아니다. 단지 현실의 존재를 얼마나 simulate하느냐이다. 모든 앱과 web app들은 인간세상에 있는 존재들과 동일하다. 계산을 위한 programming이 아니라 존재를 위한 programming을 할 수 있는 것이다. 지금 핸드폰에 있는 app들은 모두 객체지향 프로그램으로 작성된것이다. 하나의 app은 하나의 존재고, 내부에는 수많은 레고블럭과 같은 존재로 구성되어 있다. 따라서 oop언어들은 계산이 아닌, simulate하기 위해서 만들어져 있다. 그래서 재사용성이 중요하고 상속이 중요하고 은밀성?이 중요한 것이다.\nTODO class와 prototype java, python은 class중심적 사고관이라면 js의 prototype은 객체 중심적 사고관이다. js에서는 class가 없다. 객체만 있고, 객체간의 관계는 서로 협력하는 관계다. 상속의 개념이 없다. 이렇게 한발짝 더 나아간 moder oop는 js다.\nthis와 self에 대해서 java의 this와 self는 class의 method나 member변수에 사용된다. class는 빵틀이라고 흔히 설명된다. 객체의 원형(prototype)을 class라고 하기도 한다. class에서 객체에 대한 설계를 한다. person이라는 class를 만든다고 하면 person의 팔,다리를 나타내는 function과 variable을 만들게 된다. 1000명의 사람을 만들었다고 하자. 철수, 영희, 개똥이\u0026hellip;개똥이의 팔은 영희의 팔과는 다르다. 각 instance에대한 접근을 하려면 self,this가 있어야 한다. 만일 self나 this를 사용하지 않는 method나 variable은 class가 가진 공통적인 기능과 요소에 불과하다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/pl_history_of_programming_language\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/python_grammar_in_one_shot\/": {
        "title": "[python] grammar in one shot",
        "tags": [],
        "content": "목적 python으로 된 code를 보고 이해하는 게 목적이다. 우선 python의 언어적 특징을 알아보자.\nabout python python의 특징 python으로 작성된 code를 이해하려면 python에 관해 알아야 할게 있다. python의 구성과 oop다. python은 c로 작성된 부분과 python으로 작성된 library로 나눠진다. python의 근간을 이루는 grammar, parser, class, data type은 c로 작성되었다. standard library도 c로 작성되었다. 나머지 library는 python으로 작성되어 있다. python은 oop language다. 모든 것이 객체다. 그리고 python은 엄청난 package가 제공된다. package를 설치하고 사용만 할 줄 알면 모든 것을 할 수 있다는 얘기가 있다. 좀 더 python이 가진 언어적 특징은 아래를 참고하자. 프로그래밍의 역사 를 보면 내가 생각하는 program에 대한 설명이 나와 있다.\npython의 종류 cpython: 일반적인 python이다. c로 구현되어 있다. pypy: jit compiler를 사용해서 cpython보다 빠르다. 코딩 테스트할때 많이 사용한다. pandas, sklearn,matplotlib을 지원하지 않아서 data분석에 사용되지 않는다. ipython: jupyter나 colab에서 사용하는 server client기반의 python이다. mypy: typ system. python preparation python 코드를 읽거나 작성하기전 알아야 할 사항이다. environment와 package 설치에 관한 부분이다. env는 conda를 사용 하고 package설치는 pip와 conda 를 사용한다.\npython environment create env conda create -n test-env python=3.7.0 conda create -n test-env python=3.7.0 anaconda shell에서 위 명령을 실행하면 test-env라는 환경을 아래 폴더 아래 만든다. anaconda를 덧붙이면 anaconda의 기본 package들이 설치된다고 한다.\nFigure 1: conda env\nlist envs conda env list shell에서 위 명령을 실행하면 env들을 보여준다.\nFigure 2: conda env list\nactivate env conda activate py310 shell에서 위 명령을 실행하면 py310이 activate된다.\nremove env conda env remove -n py310 env를 삭제하는 명령이다.\npython package install package conda install numpy conda로 numpy package를 설치하면, ~/anaconda3/envs/py310/lib/python3.10/site-packages 에 설치된다. package들이 설치되는 위치다.\npip install numpy pip로 설치해도 ~/anaconda3/envs/py310/lib/python3.10/site-packages 에 설치된다. pip와 conda는 동일한 위치에 설치한다. 그러나 pip와 conda가 설치하는 package는 같은 package도 아니고 같은 곳에서 package를 가져오지도 않는다. pip가 가져오는 package는 순수하게 python으로 만든 package고, conda가 가지고 오는 package는 다양한 언어로 만든 package라서 다른 package다. pip의 package는 python으로 만든 최신 package가 있고, conda의 package는 system에 좀더 안정화된 package다.\nlist installed packages conda list conda와 pip를 같이 사용하면 중복으로 package가 설치된다. conda list는 ~/anaconda3/envs/py310/lib/python3.10/site-packages 에 설치된 package들이 모두 출력된다. 여기에는 pip와 conda가 설치한 package들이 모두 있다. 만일 package가 없다면,\nconda install [package] conda로 package를 설정한다. 그런데 conda에는 없고 pip에만 있는 package는 pip로 설치해야 한다. 이때 \u0026ndash;upgrade를 붙이자.\npip install --upgrade [package] package를 설치할때 conda와 pip 어떤걸 사용할 지 고민하지 말자. 편한걸로 아무거나 사용하면 된다. 섞어서 사용해도 된다. 다만 pip는 \u0026ndash;upgrade를 사용해서 설치하자. pip는 최신 버전을 설치하지 않기 때문이다. 반면 conda는 default로 최신 버전을 설치한다.\npython interpreter 생성과 초기화 in the beginning $python shell에서 python을 실행하면 python interpreter가 생성된다. interpreter가 생성하면서 다음과 같은 것을 하게 된다.\n(1) symbol table을 만든다. interpreter가 실행되면, symbol table을 만든다. locals()와 globals()를 만드는데, module을 load할때 module의 symbol들을 local과 global symbol table에 저장한다. local과 global의 차이가 무엇인가?\nimport numpy a = 3 def test(): b = 3 print(\u0026#34; this is b {}\u0026#34;.format(b)) import로 module을 가져오면 module에서 정의된것은 모두 globals에 등록되어서 사용할 수 있다. 그리고 현재의 main module에 있는 a, test도 globals에 등록된다.반면에 locals는 b가 등록된다. (2) loader를 loading한다. _frozen_importlib_external.SourceFileLoader라는 loader가 있다. python의 내장 모듈과 standard library module을 load할 수 있는 loader다. python에서는 module마다 loader를 설정할 수 있다고 한다. 즉 customization loader가 있을 수 있다. loader를 load하고 symbol table에 등록한다.\n(3) loading standard library module sourceFileLoader로 math,os,sys와 같은 module을 loading한다. 그런 다음에 os가 제공한 정보로 설정된다. 아래는 그 예다.\nimport sys # 명령행 인자 확인 if len(sys.argv) \u0026gt; 1: # 첫 번째 인자는 스크립트 이름이므로 두 번째 인자부터 확인합니다. for arg in sys.argv[1:]: print(\u0026#34;명령행 인자:\u0026#34;, arg) # 실행 환경과 관련된 설정 확인 print(\u0026#34;실행 모드:\u0026#34;, sys.executable) # 인터프리터 실행 경로 print(\u0026#34;환경 변수:\u0026#34;, sys.path) # 모듈 검색 경로 print(\u0026#34;플랫폼:\u0026#34;, sys.platform) # 운영 체제 플랫폼 정보 (4) loading built-in function 두번째로 built-in module을 load하는데, built-in function들이 있다. 그리고 exception 관련 class를 loading한다.\n(5) loading module로부터 symbol table에 저장되는 것들. interpreter는 symbol table을 만들고, loader를 load하고, loader로 부터 module을 load한다. load를 하면 ascii나 byte로 된 module(파일)을 읽고 객체들을 메모리에 생성하게 되는데, 생성된 객체들의 symbol들을 symbol table에 저장한다. symbol table에는 미리 정해진 요소들이 있다. 아래에서 보겠지만, \u0026lsquo;name\u0026rsquo;,\u0026rsquo;package\u0026rsquo;,\u0026rsquo;doc\u0026lsquo;등등의 요소들은 미리 python interpreter가 생성될때 정해진 요소들이다. 이런 요소들은 인자로 전해진 code를 읽고서, symbol table에 저장되게 된다. python interpreter가 초기화되는 과정에서는 아래와 같은 요소들이 name만 있는 상태고 실제 value가 저장되는것은 stdin이나 python file이 인자로 전해져서 code를 evaluate하면서 설정되는 것이다. 아래는 미리 정해진 symbol table의 요소들이다. locals()는 local symbol table이고 globals()는 global(전역) symbol table이다.\nprint(locals()) print(globals()) {\u0026#39;__builtins__\u0026#39;: \u0026lt;module \u0026#39;__builtin__\u0026#39; (built-in)\u0026gt;, \u0026#39;__name__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__file__\u0026#39;: \u0026#39;\u0026lt;stdin\u0026gt;\u0026#39;, \u0026#39;__doc__\u0026#39;: None, \u0026#39;__package__\u0026#39;: None} {\u0026#39;__builtins__\u0026#39;: \u0026lt;module \u0026#39;__builtin__\u0026#39; (built-in)\u0026gt;, \u0026#39;__name__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__file__\u0026#39;: \u0026#39;\u0026lt;stdin\u0026gt;\u0026#39;, \u0026#39;__doc__\u0026#39;: None, \u0026#39;__package__\u0026#39;: None} __name__ symbol\npython interpreter가 초기화되는 과정에서 symbol table에 미리 만들어놓은 symbol중에 하나다. \u0026lsquo;name\u0026lsquo;은 현재 실행되고 있는 모듈의 이름을 나타낸다. python interpreter는 미리 \u0026lsquo;name\u0026lsquo;이라는 요소를 symbol table에 갖고 있다고 했다. module이란건 파일의 이름이다. 처음에는 None이지만, 인자로 stdin처럼 script가 전달되거나 파일이름이 전달되면, 실행되는 module의 이름이 설정된다. 그런데 직접전달 되는 경우, \u0026lsquo;name\u0026lsquo;은 무조건 모두 \u0026lsquo;main\u0026rsquo; 이라는 값을 갖게 된다. 아래의 예도 모두 stdin으로 전달되는 script라서 main이름을 갖는다.\nprint(\u0026#39;hello\u0026#39;) print(locals()) hello {\u0026#39;__builtins__\u0026#39;: \u0026lt;module \u0026#39;__builtin__\u0026#39; (built-in)\u0026gt;, \u0026#39;__name__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__file__\u0026#39;: \u0026#39;\u0026lt;stdin\u0026gt;\u0026#39;, \u0026#39;__doc__\u0026#39;: None, \u0026#39;__package__\u0026#39;: None} 다음 예를 보자. a.py와 b.py 두개의 file이 있다고 하자. 아래는 a.py다.\nprint(\u0026#34;this is a.py\u0026#34;) print(__name__) this is a.py __main__ b.py는 아래와 같다.\nimport a print(\u0026#34; this is b.py\u0026#34;) print(__name__) $ python b.py python b.py를 하면, 첫번째 문장 import a를 실행하는데, 이것은 a module을 evaluate한다. 그러면 \u0026ldquo;this is a.py\u0026rdquo; 가 출력되고 __name__에 해당하는 a가 출력된다. 그리고 main module로 넘어와서 \u0026ldquo;this is b.py\u0026quot;가 출력되고 b가 출력된다.\n다음 예를 보자. 2개의 file이 있다. a.py와 b.py이다. a.py는 함수가 정의 되어 있고, b.py에서 a.py의 함수를 호출한다.\ndef test_print(): print(\u0026#34;test.py) 아래는 b.py이다.\nimport a a.test_print() 여기서 python b.py를 실행해보자.\n$ python b.py main module인 b.py에서는 import a를 호출한다. a module을 실행하지만, 여기서 \u0026lsquo;name\u0026lsquo;은 a이고, test_print라는 symbol을 symbol table에 저장한다. 그리고 main module에서는 a module의 함수를 호출하기 때문에 \u0026lsquo;name\u0026lsquo;은 a이다.\n\u0026rsquo;name\u0026lsquo;의 사용: \u0026lsquo;name\u0026lsquo;값이 python의 인자로 지정되면 \u0026lsquo;main\u0026lsquo;이란 이름을 갖게 된다. 이것은 module의 entry point를 지정할 수 있게 해준다. python interpreter의 symbol table에 \u0026lsquo;name\u0026lsquo;이 main으로 지정되기 때문에 if __name__ = \u0026lsquo;main\u0026rsquo;:= 를 사용해서 module마다 entry point를 설정하는 것이다. 일반적으로 python으로 program을 작성할때 module로 작성한다. 각 module에는 class나 function을 define할 뿐이다. 다른 module에서 import하면, 정의된 function, class를 사용 한다. entry point를 지정하지 않으면, module들이 python의 인자로 주어져도, 아무것도 실행하지 않는다. entry point가 없기 때문이다. module에 entry point를 정의할때 사용하는게 symbol table에 저장된 \u0026lsquo;name\u0026lsquo;의 값인 \u0026lsquo;main\u0026lsquo;을 사용하는 것이다. \u0026lsquo;doc\u0026rsquo; symbol\npython interpreter에 초기 symbol table에는 \u0026lsquo;doc\u0026lsquo;라는 symbol이 할당되어 있다. 이 symbol에는 docstring이 저장된다. python에서는 module,class,function에 해당 기능을 설명하는 docstring을 기술할수 있다. 이것은 pydoc을 통해서 문서를 만들때 유용 하게 쓰인다. module의 doc string은 string literal로 작성되기 때문에 symbol table에 저장하기 위해서 \u0026lsquo;doc\u0026lsquo;라는 key값으로 저장한다. 아래를 보자.\n\u0026#39;\u0026#39;\u0026#39; this is doc string \u0026#39;\u0026#39;\u0026#39; print(locals()) {\u0026#39;__builtins__\u0026#39;: \u0026lt;module \u0026#39;__builtin__\u0026#39; (built-in)\u0026gt;, \u0026#39;__name__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__file__\u0026#39;: \u0026#39;\u0026lt;stdin\u0026gt;\u0026#39;, \u0026#39;__doc__\u0026#39;: \u0026#39; this is doc string \u0026#39;, \u0026#39;__package__\u0026#39;: None} \u0026lsquo;package\u0026rsquo; symbol\n\u0026lsquo;package\u0026lsquo;도 원래 python interpreter가 처음 실행될때 만드는 symbol table에 미리 setting된 symbol중 하나다. \u0026lsquo;name\u0026rsquo; 현재 동작하는 module의 이름을 나타내듯이, \u0026lsquo;package\u0026lsquo;는 현재 실행되고 있는 module의 package를 나타낸다. module은 python file이다. 반면 package는 module들을 포함하는 folder라고 볼 수 있다. 아무 folder나 package가 되는 것은 아니고, init.py가 포함된 폴더다. init.py에는 package에 포함되어 있는 module들이 공유하는 함수나 변수를 기술하거나 초기화하는 작업을 한다. 여튼 a.py가 아래와 같이 있다고 하자.\nprint(\u0026#39;hi\u0026#39;) print(__package__) hi None $ python a.py 여기서 \u0026lsquo;package\u0026lsquo;는 none이다. main module인 a.py에 package는 없다. 왜냐면 entry point이기 때문이다. 그러면 package가 있는 module을 사용한 예제를 만들어보자.\nsubmodule/a.py가 아래와 같다고 하자.\nprint(\u0026#34;__package__ = {}\u0026#34;.format(__package__) b.py는 다음과 같다.\nimport submodule.a print(\u0026#34;__package__ is \u0026#34;, __package__) $ python b.py b.py를 실행하면, import submodule.a를 실행한다. 따라서 submodule이 출력되게 된다. 그리고 다시 main module로 와서 none을 출력하게 된다.\n__package__의 사용: 상대 경로를 사용할 수 있게 한다. 예를 들어보자. Figure 3: tree1\n위와 같은 구조에서 main.py는 다음과 같다고 하자.\nfrom mypackage.submodule.python2 import printstr printstr() $ python main.py main.py를 실행하면 from mypackage.submodule.python2 import printstr를 실행한다. 즉, mypackage.submodule.python2.py를 실행한다. 따라서, \u0026lsquo;package\u0026lsquo;의 값은 \u0026ldquo;mypackage.submodule\u0026quot;로 설정된다. 여기서 python2.py 파일을 보자.\nfrom ..python1 import some_function from에서 상대경로를 나타내는 ..이 있다. 상대 경로를 사용할 수 있는 이유는 \u0026ldquo;package\u0026rdquo; 값이 symbol table에 있기 때문이다. 위에서 \u0026ldquo;mypackage.submodule\u0026quot;이란 값이 \u0026lsquo;package\u0026lsquo;값이기 때문에, 그에 따른 상대경로를 지정할 수 있다.\n\u0026lsquo;spec\u0026rsquo;:\nspec은 loader의 정보를\n\u0026lsquo;annotations\u0026rsquo;:\n요약 python code를 해석하고,code를 작성하기 위해선, 내가 python interpreter가 되어야 한다. python interpreter가 되어야 code를 해석할 수 있다. 인자로 주어진 code를 해석하기에 앞서서, python interpreter는 사전 준비를 한다. symbol table을 만들고, loader를 load하고, loader를 사용해서 standard library를 load하고, built-in function을 load한다. load된 모든 module의 symbol들은 symbol table에 저장되어 있다. 그래서 code를 해석할때, 해당 symbol에 대한 처리를 할수 있는 것이다. 여튼 그런 다음 argument에 대한 처리를 하게 된다. 우리도 python code를 보기전에 python interpreter가 되어보는건 어떨까?\nbuilt-in module built-in functions python interpreter가 load된 다음 built-in function을 load해서 symbol table에 저장한다.\nprint(globals()) {\u0026#39;__builtins__\u0026#39;: \u0026lt;module \u0026#39;__builtin__\u0026#39; (built-in)\u0026gt;, \u0026#39;__name__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__file__\u0026#39;: \u0026#39;\u0026lt;stdin\u0026gt;\u0026#39;, \u0026#39;__doc__\u0026#39;: None, \u0026#39;__package__\u0026#39;: None} \u0026#39;__builtins__\u0026#39;: \u0026lt;module \u0026#39;builtins\u0026#39; (built-in)\u0026gt;} built-in module에 built-in function들과 exception, warning들이 포함되어 있다.\nbuilt-in exceptions python interpreter가 load된 다음 built-in exception을 load한다.\nstandard libraries python interpreter가 load된 다음 standard library를 load해서 symbol table에 저장한다.\nos sys math 요약 $ python shell에서 python을 실행하면 python interpreter가 메모리에 만들어진다. 초기화 과정을 거치면서 python에 무언가 할 수 있는 능력이 생긴다.\npython interpreter first input python interpreter의 입력 string의 입력과 출력 python interpreter로 program을 실행시킨다. program은 python interpreter의 입력으로 주어진다. 입력은 stdin과 같은 buffer, .py로 끝나는 python file이다. python interpreter는 string으로 읽어오고 string으로 저장한다. file이던 buffer던 python interpreter는 string을 읽고 string을 쓴다. 그런데 이 설명은 조금 공허해 보인다. 그리고 의문점도 든다. computer에서 file과 buffer는 모두 binary code로 되어 있는데, string을 처리한다는게 와닿지 않는다.\npython grammar basic from과 import 직관적 이해 어떤 code를 보더라도 from import, import와 같은 구문을 볼 수 있다. 이것을 이해할 수 있어야 한다. module과 package를 직관적으로 이해해보자.\nimport sys import os import만 사용될 때,\n뒤의 인자는 module이거나 package다. 참고로 sys는 module이고 os는 package다. sys와 os를 path에서 찾는다. 그리고 eval()한다. import만 사용하면 name space를 갖는다. module.symbol형태로 사용한다. import numpy as np import 뒤에는 module or package가 온다. numpy라는 module을 path에서 찾고 eval()한다. as를 사용해서 namespace를 np로 변경한다. np = numpy모듈객체 생성으로 봐도 된다. from math import pi,square from이 사용되는 경우,\nfrom 뒤에는 module이 온다. path에서 math module을 찾아서 eval한다. import뒤에는 name(symbol)이 온다.module이나 package가 올수 없다. name space를 사용하지 않는다. pi, square 직접 사용한다. module, package 찾기 import sys print(sys.path) [\u0026#39;\u0026#39;, \u0026#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python27.zip\u0026#39;, \u0026#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7\u0026#39;, \u0026#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-darwin\u0026#39;, \u0026#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac\u0026#39;, \u0026#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac/lib-scriptpackages\u0026#39;, \u0026#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-tk\u0026#39;, \u0026#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-old\u0026#39;, \u0026#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload\u0026#39;, \u0026#39;/Library/Python/2.7/site-packages\u0026#39;, \u0026#39;/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python\u0026#39;, \u0026#39;/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/PyObjC\u0026#39;] python interpreter가 초기화 될 때, sys의 path를 os의 environment variable PATH를 읽어서 세팅하다. 그래서 import문을 보면 load할 module이나 package의 위치를 찾을 수 있는 것이다. 만일 package나 module을 만들고 참조하려면, sys.path 경로에 module이나 package를 위치시키면 된다. 참고로 package는 init.py가 있는 폴더를 말한다. 이 package가 site_packages에 있어도 참조가 되는데 site_packages는 pip나 conda가 package를 설치하는 위치다.\nassignment 개념 assignment는 code를 읽거나, code를 작성할때 반드시 보게되는 문장이다. assignment에 대해 한마디로 정의하자면, 객체를 생성시키는 operator다. data type에 따라서 객체는 다양한 구조를 갖고, 따라서 객체 생성 방식은 다양하다. int,float,string,tuple,list와 같은 python에서 기본적으로 주어지는 data type에 대해 살펴보자. 기본적인 data들이 assignment를 통해서 메모리에 구조화 되는지 내부동작을 직관적으로 이해할 필요가 있다.\nint assignment 예제1\na = -2 이것을 보고 내가 직관적으로 느끼는 것은 -2라는 literal을 보고 integer객체를 만들고, 그 객체와 a라는 symbol을 묶어서 symbol table에 저장한다는 것이다. 그러나 이것은 정확한 설명은 아니다. 정확한 설명을 위해선, 어느 정도의 내부구조를 알아야 한다.\n우선, python interpreter가 a=-2이라는 코드를 해석하기에 앞서서, python interpreter에게 인자가 주어진다. 인자로 주어지는것은 위의 예처럼, a = -2라는 code를 포함하는 stdin이라는 buffer이거나 .py라는 file이다. file이나 buffer나 내부적으로 진짜 구성되어 있는것은 모두 bit sequence다. 즉 0과 1의 비트로 이루어진 byte들로 구성되어 있다. 그런데, 그런 file을 editor로 열거나, stdin버퍼에서 input()나 read()같은 함수를 사용해서 읽은 결과를 보면 모두 string이다. 어떤 일이 벌어진 걸까? file이나 buffer는 자신의 민낯인 bytecode를 절대 보여주지 않는다. 자신이 어떤 문자열로 보여지고 기록될지를 encoding으로 나타내는데, 이 encoding을 사용해서 string으로 보여준다. 그래서 file이나 stdin과 같은 buffer에 있는건 그냥 string이라고 생각한다. 하지만 진짜 민낯은 모두 bit열로 되어 있다는 것이다. file이나 buffer에는 encoding rule이 적혀 있어서 사용할때는 encoding rule을 기술해야 한다.\n여튼 stdin에 a = -2는 stdin버퍼에 있고, 이것이 python interpreter의 입력이 되어서 token으로 만들고 parsing tree를 만든다. sentence마다 parsing tree가 만들어지고 이를 eval하게 된다. 여기서는 a=3이라는 하나의 sentence에 대한 parsing tree밖에 없다. 여튼 이제부터 처리과정을 살펴보자.\n보통은 오른쪽의 -2라는 값을 읽고 int객체를 생성한다. 그리고 객체의 생성자에게 -2값을 전달해서 -2라는 객체를 만들거라고 생각한다. 그런데 python에서 integer객체는 바로 객체를 생성하지 않는다. python은 속도를 위해서 cached라는 array linked list를 heap에 가지고 있다. cached array에는 -5 ~256까지의 값을 갖는 int object를 유지하고 있다. 그래서 cache에서 가져온다. 내가 여기서 cache array list라고 한 얘기는 cache에 있는 item들은 array처럼 32비트 거리만큼 연결되어 있기 때문이다. 그런데 struct를 보면, linked list처럼 pointer로 연결되어 있다.\na = 1 b = 2 print(id(1)) print(id(2)) 140493169136952 140493169136928 따라서 heap에 integer객체를 새로 생성하지 않는다. 그림을 보자.\nFigure 4: integer cached\n-2라는 값과 offset을 더해서 이미 만들어진 int 객체를 a라는 symbol이 가리킬 뿐이다.\nFigure 5: integer cached2\n위 그림을 보면, rvalue인 -2는 이미 evaluate되어서 heap에 있는 integer객체에 대한 pointer를 return한다. 그리고 a와 2가 가리키는 heap있는 integer객체를 symbol table에 등록한다.\nassignment 예제2\na = 500 -5~255까지의 정수는 heap의 cache라는 영역에 이미 만들어진 integer객체를 재사용한다. 그렇다면 500처럼 범위에 포함되지 않는 int는 어떻게 할까? 새로운 객체를 만든다. int 객체는 어떤 형태인지 알아보자.\nFigure 6: integer1\nint객체는 단순하다.500이라는 값을 갖는 객체를 만든다. 객체를 만들면 heap에 위치한다. symbol table등록하는 과정은 아래와 같다.\nFigure 7: integer2\n위에서 cpython에서 int struct의 경우 cpython에서 코드로 확인할 수 있다. cpython의 source code에서 int개체의 원형인 c의 struct는 다음과 같이 되어 있다. 예전에는 int struct였지만, 지금은 내부적으로 long을 사용한다.\n;;python_source/Python-3.10.12/Include/longintrepr.h struct _longobject { PyObject_VAR_HEAD digit ob_digit[1]; }; ;; python_source/Python-3.10.12/Include/longobject.h typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */ assignment 예제3\nimport sys print(sys.version) a = 100 b = 100 print(a is b) c = -100 d = -100 print(c is d) 2.7.16 (default, Aug 29 2022, 10:34:32) [GCC Apple LLVM 12.0.5 (clang-1205.0.19.59.6) [+internal-os, ptrauth-isa=deploy True True Figure 8: results\na = 100 은 -5~255사이의 값이기 때문에 이미 heap에 있다. 따라서 객체를 새로 생성하지 않고, 바로 symbol table에 a:100을 저장한다. b = 100 도 100이란 값이 이미 heap에 있기 때문에, 객체 생성을 하지 않고 symbol table에 b:100을 저장한다. a,b는 동일한 객체를 가리키기 때문에 a is b 는 True가 된다. 이것을 그림으로 표현하면 다음과 같다.\nFigure 9: a is b\nc = -100 은 -5~255에 포함되지 않는다. 따라서 heap에 객체를 생성한다. d = -100 도 새로운 객체를 heap에 생성한다. 따라서 객체의 주소를 비교하는 c is d는 False를 갖게 된다. 그림으로 보면 다음과 같다.\nFigure 10: c is d\n4칙 연산\npython에서는 모든것이 객체다. 따라서 4칙연산이 값의 계산이라기 보단 객체간의 계산으로 볼 수 있다. 같은 int type의 계산이라는 전제하에 다음을 생각해보자.\na = 3 + 5 위 코드를 보고 a = 8 이라는 것을 모르는 사람은 없다. 그리고 그렇게 해석하고 넘어가도 된다. 좀더 구체적으로 3과 5를 더해서 8이 나왔고, 8은 cache에 이미 만들어져 있기 때문에 가져온다고 말해도 된다.\n그런데 python에선 3,5를 단순히 value의 계산으로 보지 않는다. 3,5는 객체다. 따라서 python interpreter가 객체에서 어떤 과정을 통해서 evaluate하는 것을 알아야 한다. 3이란 digit을 보고 interpreter는 cache에 3이란 값을 갖는 객체가 있기 때문에 offset을 계산할 것이다. 아마도 3+5를 통해 8번째에 위치한 객체를 가리키고, 5도 cache에 저장되어 있기때문에 offset을 계산하면 5+5=10, 10번째 위치한 객체를 나타낸다는 것을 알것이다. + 는 2개의 객체에 대한 offset계산을 한다고 보면 된다. 즉 rvalue 3+5의 계산은 offset끼리의 연산이다. 8 + 10 = 18로 offset은 계산되고 18번째 객체의 주소와 a는 symbol table에 mapping될 것이다. return되는 객체의 주소는 값과 같다.\na = 500 + 30 그렇다면 -5~255범위에 포함되지 않는 경우는 어떻게 되는가? 이것도 마찬가지로 500에 30을 더해서 530이 나오고 530은 범위에 포함되지 않으니 int객체를 만든다고 이해하면 된다. 더 구체적으로는 위와 같이 offset계산도 생각해야 하지만, 이 정도로도 덧셈은 충분하다.\na = 500 -30 그렇다면 뻴셈은 어떨까? 뻴셈도 덧셈으로 보면된다. -30이란것도 2의 보수를 사용하면 양수로 처리되기 때문이다. 여튼 500 -30은 470이다. 이것은 -5~255범위에 포함되지 않기 때문에 470을 갖는 새로운 int객체를 만든다.\n곱하기도 마찬가지다. 곱하기도 덧셈의 일종이기 때문이다. 그러면 /은 어떻게 동작하는가?\na = 500 / 23 print(a) 21 500이라는 값은 binary로 나타낸다. 23도 binary로 나타내진다.\na = bin(500) b = bin(23) print(a) print(b) print(500 \u0026lt;\u0026lt; 23) 0b111110100 0b10111 4194304000 packing and unpacking packing과 unpacking은 assignment와 연결되어 있다. assignment가 객체를 만들고 symbol table에 symbol을 등록만 하는게 아니라, 여기에는 packing unpacking개념이 녹아 있다. 즉 assignment는 packing, unpacking이 수행해서 객체를 만들고 symbol table에 저장한다. 예를 들어보자.\na,b,*cs = 1,2 #unpacking이 모자라는 경우 print(a) print(b) print(cs) a1,b1,*cs1 = 1,2,3,4,5,6 #unpacking이 남는 경우 print(a1) print(b1) print(cs1) rvalue는 1,2다. 이것은 (1,2)로도 표시될 수 있다. ()는 생략된 것이다. ()가 있다고 생각하면, 이것은 primitive data를 ()로 packing한 것이다. 여기서 tuple객체가 만들어진다. tuple객체가 처음 생성되면 데이터를 위한 4개의 slot이 만들어진다. 여기에 1,2가 저장되어 있다. 그 다음 lvalue를 보면 여러개의 변수가 보인다. assignment에서는 이런경우 unpacking이일어난다. unpacking이라는 것은 tuple 객체가 가지고 있는 값들, 여기서는 list형태로 저장된 4개의 slot에서 값을 꺼내서 a,b에 할당한다. *cs에서 *는 list packing operator다. 정규식의 *와 비슷하다. 만일 할당될 값이 많다면 그 값을 list형태로 packing한다. 만일 할당될 값이 적다면 []를 갖는다. *는 unpacking될 구조의 원소가 할당될 변수보다 많거나 적을때 탄력적으로 할당하게 해준다.\na = 1,2,3 print(a) c,d,e = a print(c) (1, 2, 3) 1 s1 = \u0026#34;abcd\u0026#34; #packing s2 = str(\u0026#34;abcd\u0026#34;) #s1과 같은 의미 d1 = { \u0026#39;a\u0026#39;: 3, \u0026#39;b\u0026#39;:4} #packing d2 = dict(a = 3, b =4) # 객체 b = (1,2,3) c = {1,2,3} l = [1,2,3] 위의 literal들은 packing이라고 부른다. packing은 data item들을 value로 갖는 data structure 객체를 생성하는 것이다. 그래서 보면, literal로 객체를 생성할때는 item들이 primitive data value로 구성되어 있다. 반면에 객체를 직접사용하고 argument로 설정하는 경우, symbol을 사용할 수 있다.\na,b,c,d = \u0026#34;abcd\u0026#34; print(a) e,f,g,h = [1,2,3] print(e) a float print(5 == 5.0 == 5) True print(False == False) in [False] False print(False == (False in [False])) False print(False == False in [False]) True print(5 == 5.0 \u0026gt; 4) True print(.1+.1+.1 == .3) False print(.1+.1 == .2) True print (5 == True) False print(True \u0026gt; 4) False ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/python_grammar_in_one_shot\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/algorithm_thinking_about_algorithms\/": {
        "title": "[algorithm] thinking about algorithms",
        "tags": [],
        "content": "Algorithm 알고리즘을 한마디로 말한다면 problem solving이다.\nProblem 문제가 무엇인가? 문제에 대한 정의를 한마디로 말할순 없을 것이다. 다만 모든 문제는 미지의 것이 있다. 미지의 것은 우리가 구하고자하는 것이다. 문제는 또한 주어진 것이 있다. 이것을 data라고 부른다. 그리고 마지막으로 미지의 것이 어떻게 data와 연결되는 지 말해주는 조건이라는게 있다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/algorithm_thinking_about_algorithms\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/leetcode_1672_richest_customer_wealth\/": {
        "title": "[leetcode] 1672 Richest Customer Wealth",
        "tags": [],
        "content": "문제 링크 You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.\nA customer\u0026rsquo;s wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.\nexample1 Input: accounts = [[1,2,3],[3,2,1]] Output: 6 Explanation: 1st customer has wealth = 1 + 2 + 3 = 6 2nd customer has wealth = 3 + 2 + 1 = 6 Both customers are considered the richest with a wealth of 6 each, so return 6. example2 Input: accounts = [[1,5],[7,3],[3,5]] Output: 10 Explanation: 1st customer has wealth = 6 2nd customer has wealth = 10 3rd customer has wealth = 8 The 2nd customer is the richest with a wealth of 10. example3 Input: accounts = [[2,8,7],[7,1,3],[1,9,5]] Output: 17 constraints m = accounts.length n = accounts[i].length 1 \u0026lt;= m, n \u0026lt;= 50 1 \u0026lt;= accounts[i][j] \u0026lt;= 100\n생각 account라는 data를 사람과 bank라는 2개의 data로 나타내는데 2d array를 사용한다.\n풀이 class Solution(object): def maximumWealth(self, accounts): \u0026#34;\u0026#34;\u0026#34; :type accounts: List[List[int]] :rtype: int \u0026#34;\u0026#34;\u0026#34; output = [] for i,v in enumerate(accounts): output.append(sum(accounts[i])) return max(output) accept되긴 했다. 그런데 여기서 index를 얻어오기 위해서 enumerate 한것이 걸린다. 꼭 이런방법을 택했었어야 했을까?\n참조 ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/leetcode_1672_richest_customer_wealth\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/python_summary6_function\/": {
        "title": "python_summary6 function",
        "tags": [],
        "content": "", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary6_function\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/python_summary7_big_data_and_python\/": {
        "title": "python_summary7 big data and python",
        "tags": [],
        "content": "대용량 data의 처리 대용량 data의 처리에서 대용량 data는 string이나 array, list 같은 data collection에 있는 data를 말한다. 처리는 검색과 변환 이다. 처리하는 방식은 for-loop와 while과 같은 전통적 방식과 functional language에서 사용하는 방식으로 나누어 질 수 있다. 전통적방식은 기계식 방법이다. 절차형방식의 programming에서 건너온 개념이라서 몇가지 functional language와 다른 특징이 있다. 첫번째 machine에 해당하는 함수가 입력과 출력이 없어도 된다. functional language의 machine인 function은 입력과 출력이 필수다. 반면 전통적 방식 중 for-loop은 입력은 주어지지만 출력은 없어도 된다. 따라서 list comprehension으로 출력을 list로 만들어주는 방식으로 python에서는 개선했다. 그리고 while의 경우 입력과 출력이 없어도 된다. 그리고 for-loop은 데이터의 개수는 대용량이지만, machine은 1개다. 그래서 데이터가 10개라면 10번 machine을 켜서 순차적으로 실행한다. while은 조건이 True면 무한정 기계를 돌린다. 그런데 공통점은 하나의 machine이 한번 수행하는 것이다. 반면에 functional language에서 처리하는 방식들은 machine을 한개만 사용하지 않는다. 그래서 전동적 방식은 하나의 processor만 이용하지만, processor가 여러개인 경우, functional language에서 사용하는 방식은 여러개의 machine을 동시에 수행할 수 있다.그렇기 때문에 매우 효율적이다.\nfor-loop 대용량의 data를 처리하는데 가장 오래된 것은 for-loop이다. for-loop은 데이터를 하나하나 꺼내는 부분과, 데이터를 처리하는 함수가 합쳐진 structure다. 아주 오래전 부터 대용량의 데이터를 처리하는 방식이다. for-loop에서 한개의 data 입력을 받아서 한개의 data 출력을 return하는 function을 보면 누군가는 이렇게 질문할 수 있을꺼 같다. array나 list를 함수의 입력으로 주면 되지 않나? 그런데 함수가 입력만 array나 list로 받을뿐 처리는 함수내부에서 for-loop를 돌려서 처리한다. 데이터의 처리라는것은 입력받은 data를 다른 data의 형태로 변환하는것을 의미한다. 기본적인 함수는 하나의 data(datum)를 받고 하나의 data를 return하는 것이다. primitive data가 있는 것처럼 primitive data를 처리하는 primitive function이 있는데 예를들면, and, or, not, +, -,/ 같은 것들이 있다. 이 함수들이 2개의 인자를 갖는다고 생각할 수 있겠지만, 1개의 인자를 갖는 함수라고 본다. 그림으로 보면 다음과 같다.\nFigure 1: for-loop\nlist나 array같은 대용량의 data를 처리하는 가장 오래된 방법이다. 대용량 데이터에서 순차적으로 data를 꺼낸다. 꺼낸 데이터를 머신에 넣고 결과를 만든다. machine은 하나만 쓴다. 이게 일반적인 for-loop machine이다. for-loop의 block이 machine에 해당하는 함수다. 일반적인 사용법은 아래와 같다.\narr = [9,8,7,6,5,4,3,2,1] for i in arr: print(i) 9 8 7 6 5 4 3 2 1 continue를 사용해서 filtering효과를 낼수 있다. 즉 데이터에서 홀수만 출력하고 짝수는 출력하지 않는다.\narr = [9,8,7,6,5,4,3,2,1] for i in arr: if i % 2 == 0: continue print(i) 9 7 5 3 1 break를 사용해서 machine을 중간에 멈출 수도 있다.\narr = [9,8,7,6,5,4,3,2,1] for i in arr: if i == 7: break print(i) 9 8 while 대용량 data를 처리할 때, 전통적인 방식인 for-loop와 더불어 while이 있다. while은 함수라는 machine을 사용하지만, 그 machine이 반드시 입력과 출력이 있어야 한다는 보장을 하지 않는다.\nlist comprehension for-loop을 개량한 방식이다. for-loop이 한개의 machine을 통해서 나온 결과를 별도의 list나 array에 집어넣어야 한다. 이런 불편함을 없앤게 list-comprehension이다. 이미 list안에서 for-loop을 실행하기 때문에 결과를 위한 별도의 list나 array를 만들지 않아도 된다. list comprehension의 모양은 다음과 같다.\nnewlist = [expression for item in iterable if condition == True] expression은 결과가 오고, 그다음 for와 if가 온다.\narr = [9,8,7,6,5,4,3,2,1] temp = [results for i in arr] print(temp) map \u0026amp; filter functional language에선 for-loop을 사용하지 않았다. list나 array같은 대용량 data를 machine 하나만 사용해서 순차적으로 처리하는 방식이 비효율적이기 때문이다. 데이터 개수만큼 machine을 만들어서 동시에 처리한다. 이게 더 효율적이고 빠르다. machine을 data 갯수만큼 만들기 위해서 lambda function을 사용한다. 그러면 한방에 계산할 수 있다.\nfilter는 if문을 사용해서 filtering효과를 줄 수 있다. 동작방식을 그림으로 보면 다음과 같다.\nFigure 2: map \u0026amp; filter\nreduce map\u0026amp; filter처럼 여러개의 machine을 사용한다. machine이 한개의 입력만\nrecursion regular expression ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary7_big_data_and_python\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/github_multi_account_github_problem\/": {
        "title": "[github] multi account github problem",
        "tags": [],
        "content": "github의 통신 방법 통신방법은 http와 ssh 방식이 있다. git pull과 git push, git clone은 통신하는 명령어다. git clone할때 보면 http와 ssh가 있는 것을 볼 수 있다.\ngithub 인증 방법 대부분 public repo이기 때문에 git pull시에는 인증이 필요없다. 그러나 git push는 github에 쓰는 것이기 때문에 인증이 필요하다. 인증은 통신하는 방법에 따라 다르다. http는 PAT라는 토큰으로 인증할수 있고, ssh는 ssh자체에 인증이 필요하다.\nhttp로 통신 방법 http를 사용할 경우, git push때 github은 PAT를 요구한다. PAT를 입력해서 push를 하면 그 다음 부터 mac에서는 PAT가 osxkeychain에 보관된다. 보관되는 이유는 git config에서 credential helper로 osxkeychain을 설정했기 때문이다. 그런데 http방식의 문제는 multiple github계정을 사용할 경우 매번 osxkeychain의 github 아이템을 매번 지우고 새로 입력해야하는 문제가 있다.\nssh로 설정해서 통신 ssh를 설정하는 이유는 multiple account를 사용할 수 있기 때문이다.\nssh키로 multiple accounts 설정 ssh key 생성 hoyoul 계정 ssh-keygen -t rsa -C \u0026#34;hoyoul.park@gmail.com\u0026#34; -f ~/.ssh/id_hoyoul holy2frege 계정 ssh-keygen -t rsa -C \u0026#34;holy2frege.nil@gmail.com\u0026#34; -f ~/.ssh/id_holy2frege 만들어진 key를 각 github에 등록한다.\nholytofrege 계정 ssh-keygen -t rsa -C \u0026#34;holytofrege@fastmail.com\u0026#34; -f ~/.ssh/id_holytofrege ~/.ssh/config 설정 다음과 같이 설정한다. 여기서 host명이 중요하다. host명에 따라 github에서 repo를 clone할 때, 이 host명이 쓰이기 때문이다. 그래서 가능하면 github에서 복사한값과 유사하게 만든다. github.com이 github에서 복사한 값이기 때문에 -hoyoul로 postfix를 붙이는 방법을 사용한다.\n# 첫 번째 계정 Host github.com-hoyoul HostName github.com User hoyoul IdentityFile ~/.ssh/id_hoyoul # 두 번째 계정 Host github.com-holy2frege HostName github.com User holy2frege IdentityFile ~/.ssh/id_holy2frege # 세번째 계정 Host github.com-portfolio HostName github.com User holytofrege IdentityFile ~/.ssh/id_holytofrege server 연결 test ssh -T git@ host명 ssh -T git@holy2frege_github ssh -T git@hoyoul_github ssh -T git@holytofrege_github 사용자를 git으로 하고, host명을 입력해서 server에 접속 유무를 test할 수 있다.\nssh로 clone을 해서 사용한다. github에서 clone을 한다. clone시에 http, ssh인지 github cli가 있는데, ssh를 선택한다. 그런데 그 주소는 직접 github주소와 연결되어 있다. 이걸 좀 변경해야 한다. 어떻게 변경해야 하냐면, 이전에 ~/.ssh/config의 설정을 사용해서 github에 접근해야 한다. 따라서 github에서 복사한 주소는 아래와 같다면,\ngit@github.com:hoyoul/holy-brain.git 지금의 github.com은 ssh/config에서 설정한 host명으로 바꿔야 한다.\ngit@github.com-hoyoul:hoyoul/holy-brain.git braindump와 homepage에서 multiple 계정으로 인한 submodule trouble shooting multiple 계정을 사용하기 위해서 ssh방식으로 바뀌면서 homepage와 braindump의 submodule주소도 변경해야 한다. .gitmodules를 열고 url을 다음과 같이 바꾼다.\nhoyoul braindump [submodule \u0026#34;public\u0026#34;] path = public url = git@github.com-hoyoul:hoyoul/hoyoul.github.io.git ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/github_multi_account_github_problem\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/website_about_my_brain_blog_and_homepage\/": {
        "title": "[website] about my braindump blog and homepage usage",
        "tags": [],
        "content": "[My homepage setting from scratch] 기본정보 참조: from here (만들당시 기록한 note) homepage 운영 주소: https://frege2godel.me/ github source 주소: github address: https://github.com/holy2frege/main-blog github id: holy2frege github email: github repo(dev,publish): main-blog,holy2frege.github.io pat: 사용법 [step1] repo가져오기 (clone) 기본 정보\nlocal에 repo가 clone되어 있지 않다면 main-blog를 clone부터 한다. clone할때는 ssh방식으로 한다. ssh를 하는 이유는 multiple account문제 때문이다. 관련된 글은 여기 를 참조한다. clone하면 아래와 같은 directory구조를 볼 수 있다.\nFigure 1: main page\ngit pull\ngit pull을 해서 sync를 맞춘다.\ngit submodule init \u0026amp; git submodule update\n이제 publishing repo를 가져와야 한다. publishing repo는 holy2frege.github.io다. 이 repo는 main-blog안에 public폴더와 mapping되어 있다. 현재는 비워져 있다. public폴더로 진입해서 git clone으로 가져와야 할까? 가져오지 않는다. mapping되어 있다는것은 main-blog에서 mapping정보를 가지고 있기 때문에, 다른 방법을 사용한다. mapping에 대한 정보는 main-blog의 .gitmodules에 있다. git submodule init과 git submodule update를 통해서 holy2.frege.github.io를 가져올 수 있다. 이렇게 가져온 repo는 HEAD가 detach되어 있다.\ngit checkout main\ngit submodule foreach git checkout main: 그래서 git submodule foreach git checkout main을 해준다. git status를 해도 detach되어 있다면 git checkout main을 다시 해준다. git submodule update \u0026ndash;remote \u0026ndash;merge 해서 다시 update를 했다. 그런데도 detached head라서 git checkout main을 해주었다.\ngit pull\ngit pull (in public): 그리고 public 폴더에서 git pull을 했다.\n[step 2] article 수정 이제 문서를 만들거나 수정하면 된다. org 폴더에 가면 index.org파일 하나밖에 없다. 2nd-level의 headline에 보면 \u0026lsquo;CUSTOM_ID: page\u0026rsquo;가 보일텐데, 그 headline이 articles를 모아놓은 page라고 보면 된다. 거기서 원하는 page를 생성하거나 수정하면 된다. 수정이 끝나면 다음 단계로 가자.\n[step 3] m-x org-publish-all emacs의 설정파일에는 위 명령어를 수행하는 code가 이미 있다. html변환과 css,js를 처리를 구현하고 있다. 따라서 수행하면 public/index.html이 만들어진다.\n[step 4] git 반영 dev repo인 main-blog 폴더로 간다. git pull을 하고 git push를 한다. main-blog/public으로 이동한다. 마찬가지로 git 반영을 한다. 만일 처음이라면, 포맷하고 다시 시작하는 경우에는 git push할 때 PAT를 입력해도 git config \u0026ndash;global로 user이름과 email 설정이 필요하다. 설정을 하면 push가 되고 keychain에 등록된다. 처음이 아닐때 안될 때는 multi-account github problem이다. 즉 이미 osxkeychain에 다른 PAT가 저장되어 있기 때문이다. keychain app을 실행시켜서 login type이면서 github을 찾는다. 그리고 지운다. 그리고 다시 terminal에서 git push를 한다. id: holy2frege와 아래 pat을 입력하면 새로운 keychain이 만들어지고 push가 된다.\npat\n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\n[My braindump blog setting from scratch] 기본 정보 homepage 운영주소: https://braindump.frege2godel.me/?stackedPages=%2F github source 주소:\ngithub repo(dev,publish):holy-brain, hoyoul.github.io\ngithub address: https://github.com/hoyoul/holy-brain github id: hoyoul\ngithub email: hoyoul.park@gmail.com pat:\n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\n사용법 [step1] repo 가져오기 clone git clone https://github.com/hoyoul/holy-brain.git git pull을 한다.\n[step2] submodule 가져오기 public과 mapping된 submodule을 가져온다.\ngit submodule init\ngit submodule update\npublic폴더로 들어가서 update한다.\ngit submodule foreach git checkout main\ngit submodule update \u0026ndash;remote \u0026ndash;merge\ngit checkout main\ngit checkout main을 하고 git status를 하면 HEAD detach가 사라진다. 위에서 git checkout main만 해도 될듯한데, 잘 모르겠다. 그 다음 git pull을 한다.\n[step3] 문서 작성및 수정 org-roam에서 문서를 작성하기 때문에 emacs.org에서 org-roam 경로가 맞는지 확인한다.\n(org-roam-directory \u0026ldquo;~/hoyoul_projects/holy-brain/org\u0026rdquo;) ; replace with your path\nC-c r f로 문서를 수정하거나 만든다. 만들때는 영어로 title을 만들어야 한다. 만든 문서에는 org_head_for_blog라는 미리만든 yasnippet의 형식에 맞춰 문서를 작성한다. 제목,날짜, description template을 채우는 것이다. [step3-추가] 문서 작성 tip fieldset legend\nroam으로 문서를 만들고 yasnippet(C-c s)에서 org_head_for_blog를 선택하면 모든 blog의 article이 가져야 하는 time,author,email,description정보가 들어가고, 그것은 main.css의 fieldset legend로 css처리를 한다.\nFigure 2: legend\nheadlevel\nheadlevel은 4개만 정의 했다. org에서 headline을 그대로 사용한다.\nlevel1\nFigure 3: level1\nlevel2\nFigure 4: level2\nlevel3\nFigure 5: level3\nlevel4\nFigure 6: level4\nunderline\nunderline은 _로 둘러싸게 하면 된다.\nFigure 7: underline\nequal\neqaul 두개로 둘러 싸면 아래와 같은 모양이 나온다.\nFigure 8: equal\ntodo\ntodo는 org에서 C-c C-t로 만든다. 이것을 org에서 기술하면 아래와 같이 보인다.\nFigure 9: todo\nverse\nbegin_verse로 시작되는 verse block 다음과 같이 보인다.\nFigure 10: verse\nsource \u0026amp; example \u0026amp; text\nsource block은 color가 지원되고, example과 text는 highlight를 지원하지 않는 차이가 있다.\nFigure 11: source\nFigure 12: example\n기타 blocks\ntip,warning,important,attention은 거의 비슷한 모양이다. 이것들 모두 yasnippet으로 정의했기 때문에 shortcut으로 사용하면 된다. 모양은 다음과 같다.\nFigure 13: tip\nFigure 14: warning\nFigure 15: important\nFigure 16: attention\ntable\norg에서 많이 쓰는 구조 중에 table이 있다. 다음 예를 보자.\n온도 -4 -3 -2 -1 0 1 2 3 4 아이스크림 판매량 -6 -4 -2 0 2 4 6 8 10 보기 좋게 세로로 변경하자.\n온도 아이스크림 판매량 -4 -6 -3 -4 -2 -2 -1 0 0 2 1 4 2 6 3 8 4 10 [step 4] make all terminal에서 make all을 하면 org파일이 모두 md로 바뀐다.\n[step 5] hugo -d 이미 hugo는 깔려있어야 한다. 안 깔려 있다면, brew install hugo를 실행해서 설치한다. 이상태에서 hugo -d를 하면 md가 html로 바뀌면서 public폴더에 들어가게 된다.\n[step 6] git push git add, commit, push를 한다. 다음과 같은 에러가 날 수 있다.\nremote: Permission to hoyoul/holy-brain.git denied to holy2frege.\nfatal: unable to access \u0026lsquo;https://github.com/hoyoul/holy-brain.git/\u0026#39; : The requested URL returned error: 403\n이전에 사용했던 github 정보때문이다. holy2frege라는 user name으로 push할려니 문제가 생기는 것이다. 우선 급한대로 다음과 같이 하자.\ngit remote set-url origin https://hoyoul@github.com/hoyoul/holy-brain.git 그리고 pw를 물어보면 아래 값을 넣자.\npat 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\npublic folder: 이것도 마찬가지다. [ portfolio page ] domain설정 frege2godel이라는 domain에 subdomain을 만들어야 한다. 나는 가비아에서 domain을 구입했기 때문에 가비아에서 portfolio.frege2gode.me라는 CNAME의 domain을 설정했다.\nFigure 17: domain\n기본 정보 homepage 운영주소: https://portfolio.frege2godel.me github source 주소:\ngithub repo(dev,publish):holytofrege.github.io\ngithub address: https://github.com/holytofrege/holytofrege github id: holytofrege\ngithub email: holy.frege@fastmail.com pat:\n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\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/website_about_my_brain_blog_and_homepage\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/website_make_main_homepage\/": {
        "title": "[website] make main homepage",
        "tags": [],
        "content": "make blog 시작 nmain blog를 만들기로 했다. holy2frege라는 github id를 만들었다. 2개의 repo를 만들었다. main-blog라는 repo와 holy2frege.github.io다. main-blog는 개발 repo고 holy2frege.github.io는 publishing repo다. emacs에서 org파일을 만들고, ox-publish를 사용하면, org파일을 html로 변환해 public폴더에 publishing한다. 따라서 2개의 repo가 필요하다.main-blog에는 org파일을 작성하는 개발 repo지만, publishing repo는 domain주소를 hosting하고 web service를 하기 때문에 github에서 몇가지 설정을 해준다. domain 주소를 설정해준다.\ngithub-\u0026gt;settings-\u0026gt; pages -\u0026gt; https://frege2godel.me/ 2개의 repo를 local에 설치하자. 먼저 main-blog라는 repo를 설치하기 위해서 MyProjects/main-blog라는 폴더를 만들고, github에서 지시하는 대로 첫번째 commit을 만들어서 push한다. push할 때, 403에러가 발생할 수 있다.\n403 error pat\n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\npush할때 에러가 나면, keychain에서 github검색후 type이 login을 지우고 다시 push한다. id holy2frege, pw를 물어보면 pat를 입력한다.\nssh처리 remote가 git주소일때는 ssh처리가 필요하다. 그런데 https를 사용한다면 ssh처리는 상관없다. 위처럼 id와 pw로 pat를 사용하면 되기 때문이다. 위에서 keychain에서 login type을 갖는 gihtub을 제거한 후 다시 push할때 user,pw를 입력해도 제대로 안될 때가 있다. 이때 ssh key를 만들고 system에 등록해야 한다.\nssh-keygen -t rsa -b 4096 -C \u0026ldquo;holy2frege@gmail.com \u0026rdquo;\nsave할 이름을 id_rsa_holy2frege로 입력하고 enter를 계속 친다. 그러면, 다음과 같은 메시지를 볼 수 있다.\nYour identification has been saved in id_rsa_holy2frege. Your public key has been saved in id_rsa_holy2frege.pub.\nssh public key는 github 계정마다 다르기 때문에 이름을 입력해서 만들어줘야 한다. 그냥 enter만 입력하면 안된다.\neval \u0026ldquo;$(ssh-agent -s)\u0026rdquo;\nssh-agent가 동작하는지 확인한다.\nssh-add -K ~/.ssh/holy2frege\nssh-agent에 public key를 등록한다.\ngit push를 할때는 ssh접속을 하는데, 이때 local과 github 사이에는 ssh통신이 이루어진다. local에서는 ssh-agent가 local의 public key를 보내고 github은 등록된 public key를 대조해서 접근허가를 해준다. 따라서 ssh-agent에 public key를 등록한 것이다. 그 다음은 github에 public key를 저장해야 한다.\ngit submodule 403에러를 해결했고 main-blog repo를 local에 설치했으면 holy2frege.github.io라는 repo를 mainblog/public폴더에 clone해야 한다. clone이기 보다 submodule로 설치한다.\ngit submodule add https://github.com/holy2frege/holy2frege.github.io.git public\n이제 web site를 개발해보자. 내가 원하는 것은, emacs에서 org파일을 만들고 M-x org-publish-all을 실행하면, 혹은 C-c C-e로 export시키면, 작성된 org파일이 html로 변환되서 public폴더에 저장되는 것이다. public폴더는 github hosting서비스와 연동되어서 domain주소를 browser에서 접근가능한 것이다. 전체적인 폴더 구조는 아래와 같다.\nFigure 1: folders\norg-publish 설정 main-bolog에 org폴더를 만들고 작성한 org파일들이 public폴더의 html으로 변환되는 것은 org-publish package를 사용하기 때문이다. 이 기능을 사용하려면 emacs 설정 파일에서 org-publish project를 기술해야 한다. project를 정의하면 source 폴더에서 target폴더로 이동만 시킬수도 있고, 함수를 적용해서 결과 파일을 taget으로 이동 시킬 수 있다. 3개의 project를 만들기로 한다.\norg-\u0026gt; html project my-main-blog라는 project다. org파일을 html로 변환한다. source는 base-directory에서 정하고 target은 publish-directory가 된다. 적용되는 함수는 publishing-function이다. publish-function은 org의 요소들을 html요소로 transcode한다. org의 요소와 html의 요소는 1:1 mapping되지 않기 때문에 여러 편법이 사용된다는 것만 알고 넘어가자.\n(require \u0026#39;ox-publish) (setq org-publish-project-alist \u0026#39;( (\u0026#34;my-main-blog\u0026#34; :base-directory \u0026#34;~/MyProjects/main-blog/org/\u0026#34; :base-extension \u0026#34;org\u0026#34; :publishing-directory \u0026#34;~/MyProjects/main-blog/public/\u0026#34; :publishing-function org-html-publish-to-html :recursive t :html-head \u0026#34;\u0026lt;link rel=\\\u0026#34;stylesheet\\\u0026#34; href=\\\u0026#34;../css/styles.css\\\u0026#34; type=\\\u0026#34;text/css\\\u0026#34;/\u0026gt;\u0026#34; ) )) :html-head는 출력되는 html head에 html tag를 넣을 수 있게 한다. 보통 html head에 들어가는 css, java, meta tag를 넣는다. 여튼 이렇게 하고 M-x org-publish-all이나 C-c C-e P f를 실행하자. 그러면 위의 project가 실행된다.\n간단한 org파일을 만들고 M-x org-publish-all했을때 출력된 html파일은 실망이다. 엄청나게 많은 tag로 이루어진 html이 만들어졌기 때문이다. 고작 org문서에는 1st-level headline과 hello world라는 문자열만 있는데도 변환된 html문서는 알아보기 힘들정도로 긴 html파일이다.\norg-publish가 동작하는 방식은 option을 통해서 html의 특정요소를 출력할지 안할지를 결정한다. 나만의 backend를 만들지 않고 publishing function을 사용하기 때문에 어쩔 수 없다. 나도 나만의 backend를 만들고 싶었지만, 너무 복잡했다. 여튼 내가 원하는 html을 만들기 위해선 불필요한 option을 모두 꺼야 한다. emacs의 설정파일에서 정의한 project에서 option을 설정해야 한다. 아래 대충 정리를 했다.\npublishing settings\n:section-numbers nil :with-toc nil :html-head-include-default-style nil 이것을 해야 불필요한 style tag가 없어진다. :html-postamble nil 더 많은 option들은 여기에 나와 있다.https://orgmode.org/manual/Publishing-options.html org-publishing의 변환\n위와 같은 설정을 하고 변환하면 대부분 이런식으로 변환된다.\nFigure 2: org-publish1\ntitle을 h1으로 시작한다. 1st level headline은 div+h2쌍으로 표시되고, 1st headline의 content는 div+p쌍으로 표시된다. 2nd level headline은 div+h3쌍으로 표시된다. 2nd headline의 content는 div+p 쌍으로 표시된다. org to html publishing\norg에서 사용되는 모든 요소들은 org-html-publish-to-html함수에서 html tag로 변환되는데, 각각의 요소들이 어떻게 transcode되는지 살펴볼려면 다음을 파일을 변환해서 분석하면 된다. https://writequit.org/denver-emacs/presentations/files/example.org.html 한계점\norg를 구성하는 요소들과 html tag들이 1:1 mapping하지 않는다는 근본적인 문제가 있다. 예를 들어, 나는 html에 \u0026lt;span\u0026gt;test\u0026lt;/span\u0026gt;을 출력하고 싶은데, 이렇게 \u0026lt;span\u0026gt;만 출력하는 org요소가 없다. 그리고, org의 headline이 html로 conversion될 때, div+h조합으로 나오고,id와 class가 자동으로 만들어지는데, 이것을 내가 customize하기 어렵다. 정해진 값으로 나오고, 무조건 나온다고 보면 된다. org문서라는게 기본적으로 문서제목+문서내용이라는 block의 조합이라고 본다면 org의 headline이 div+h조합을 그대로 쓰는것도 나쁘지는 않다. 다만 css처리를 위해서 id에 대한 설정은 필요하다고 본다.\n여튼 이런 문제를 해결하기 위해서 나는 2가지 편법을 사용하기로 했다. 하나는 property고 다른 하나는 org special block이다.\nproperty 설정\nid,class는 css와 js처리에 있어서 매우중요한데, 그것을 자유롭게 customize할 수 없다는것은 이 방식의 한계라고 볼 수있다. 하지만, 제한적이지만, class와 id를 설정할수 있는 방식이 존재한다. org문서의 headline이 html tag로 export될때, div+h tag는 그대로 놔두고, 왜냐면 id와 class를 설정하는것은 property를 사용하는 것이다. 2개의 property가 사용되는데, 다음과 같다. :CUSTOM_ID:, :HTML_HEADLINE_CLASS:이다. 나는 custom_id만 사용해서 css선택자로 사용하기로 했다. 왜냐하면, headline에 custom_id속성을 처리하면, html로 변환되었을 때, outline-container-id이름, id이름, text-id이름으로 원하는 tag를 선택할수 있기 때문이다.\nhello :CUSTOM_ID: hello-id :HTML_HEADLINE_CLASS: hello-class\n!hello world!\nhi :CUSTOM_ID: hi-id :HTML_HEADLINE_CLASS: hi-class\n이것만 보면 와 닿지 않기 때문에 mapping그림을 첨부한다.\nFigure 3: org-publish2\norg-special-blocks\norg special block이라는게 있다. #+begin blah blah로 block을 만들어서 이것을 특정언어나 코드로 trans해준다. 이것을 customize해서 특정블록을 특정html code로 변환하는 special block을 만들어서 사용할 수도 있지만, 이미 있는 block중에 다음과 같은 것이 있다.\ntest 이것은 org문서에서 html코드를 입력하면 html code로 trans시 그대로 출력된다.\n이제 org문서를 설계하고 이를 바탕으로 css 설계를 하자.\norg문서 organization\n다음과 같은 구조로 page를 설계해보자.\nFigure 4: main blog\npage를 바탕으로 org파일을 만들어보자. 각각의 사각형은 headline을 뜻하고, 필기로 작성한것은 selector에 해당한다. headline은 제목과 내용으로 구성된다. 하지만, 위의 page에선 제목이 없는 경우도 있다.그것에 대한 처리는 별도로 했다. org를 작성할 때 고려한것은 다음과 같다.\norg headline에 사각형 selector를 나타내기 위해 property의 custom_id 사용. 예외) aside와 page는 org에서 headline이지만, 내용은 쓰지 않는다. 왜냐면, selector만 사용할것이기 때문이다. org에서 작성된 title과 subtitle은 html로 변환시 header tag안에 기술된다. unordered list는 그냥 html로 구현했다. Figure 5: mainblog org\nM-x org-publish-all을 하거나, C-c C-e P f를 눌러서 publishing하면 아래와 같은 html파일이 만들어진다.\nFigure 6: mainblog html\n대략적인 문서의 구조를 org 파일로 구현했다. 이제 selector를 사용해서 css처리를 하자.\ncss project css를 처리하기 위해선 org-publish의 css project를 만들어야 한다.\n(\u0026#34;my-main-blog-css\u0026#34; :base-directory \u0026#34;~/MyProjects/main-blog/css\u0026#34; :base-extension \u0026#34;css\\\\|scss\u0026#34; :publishing-directory \u0026#34;~/MyProjects/main-blog/public/css/\u0026#34; :recursive t :publishing-function org-publish-attachment ) 이것은 개발과정에서 사용되는 css파일을 public폴더로 이동해주는 역할이다. 실제 html코드에서 css에서 참조할때는 public위치의 css를 사용하게 해주면 된다. html코드에 삽입을 위해선, org project에서 명시해 야한다. 일부만 가져왔지만, 아래보면 :html-head에 명시했다.\n(setq org-publish-project-alist \u0026#39;( (\u0026#34;my-main-blog\u0026#34; :base-directory \u0026#34;~/MyProjects/main-blog/org/\u0026#34; :base-extension \u0026#34;org\u0026#34; :publishing-directory \u0026#34;~/MyProjects/main-blog/public/\u0026#34; :publishing-function org-html-publish-to-html :recursive t :html-head \u0026#34;\u0026lt;link rel=\\\u0026#34;stylesheet\\\u0026#34; href=\\\u0026#34;./css/style.css\\\u0026#34; type=\\\u0026#34;text/css\\\u0026#34;/\u0026gt;\u0026#34; 이제 css파일을 설정하자.\nprototype for css\nfont에 대한 처리\n내가 주로 사용하는 font는 Inter라는 폰트다. 구글에서 제공하는 font다. client에서 해당 폰트가 없을 수 있기 때문에 @import로 해당 font를 다운받게 했다.\n@import url(\u0026#39;https://fonts.googleapis.com/css2?family=Inter\u0026#39;); web page의 모든 text를 inter로 설정하기 위해선, font-family을 body에 설정하기로 한다. font-family는 글꼴을 설정하고 font는 글꼴이 가진 속성을 설정하기 때문에 font도 설정하기로 한다. 다음과 같이 설정했다.\n@import url(\u0026#39;https://fonts.googleapis.com/css2?family=Inter\u0026#39;); /* ============================================================================= elements ========================================================================== */ body { width: 100%; height: 100%; font-family: Inter, sans-serif; font: 14/1.5 Inter; } 폰트만 바꿔도 어느정도 차이가 난다.\nFigure 7: before_font\nFigure 8: after_font\n그리고 나는 모든 글자의 색을 약간 흐릿하게 설정한다. 이렇게 했을때, text별로 농도 조절이 dramatic한 효과를 낸다.\nbody { width: 100%; height: 100%; font-family: Inter, sans-serif; font: 13px/1.5 Inter; color: #595959; } 일반적인 폰트 설정은 다음과 같다. system font를 사용하도록 설정한다는 것이다. 그래야 속도도 좋고 보기도 좋다고 한다.\nbody { font-family: -apple-system, BlinkMacSystemFont, \u0026#39;Segoe UI\u0026#39;, Roboto, Oxygen, Ubuntu, Cantarell, \u0026#39;Open Sans\u0026#39;, \u0026#39;Helvetica Neue\u0026#39;, sans-serif; } apple system과 BlinkMacSystemFont는 맥, Segoe UI는 윈도우, Roboto는 안드로이드 OS의 기본 폰트다.\nicon의 적용\n가장 많이 사용하는 font-awesome이 유료화로 되서 나는 google icon을 사용했다. https://fonts.google.com/icons 여기에서 icon을 검색할 수 있다. 여기에 보면 사용방법이 나오는데, cdn과 사용법이 명시되어 있다. cdn주소는 다음과 같다.\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0\u0026#34; /\u0026gt; cdn을 html에 삽입하기 위해서 org project에서 다음과 같이 추가했다.\n:html-head-extra \u0026#34;\u0026lt;link rel=\\\u0026#34;stylesheet\\\u0026#34; href=\\\u0026#34;https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0\\\u0026#34; /\u0026gt;\u0026#34; 이렇게 cdn을 가져오고 사용하는 법은 google icon page에서 원하는 icon을 선택하면 span태그를 html에 삽입하라고 한다.\n\u0026lt;span class=\u0026#34;material-symbols-outlined\u0026#34;\u0026gt;emoji_people\u0026lt;/span\u0026gt; 위와 같이 삽입하면 된다.\nbasic layout\nlayout에대한 상식\nlayout을 처리하려면, container가 필요하다. 그리고 container는 부모, 자식들의 관계를 따질 필요가 있다.\n부모의 관계\ncontainer는 부모의 with와 height를 물려받아서 처리할 수 있다. 부모의 width:500px, height:500px이면, container는 width:100%, height:100%로 물려받을 수 있다. 어떤 자식은 부모의 dominance에서 벗어날 수도 있다. 그럴땐, container가 부모보다 큰 width와 height를 pixel로 기술하면 된다.\n자식과의 관계\ncontainer가 자식에 대한 layout을 관리할 수도 있다. 이렇게 하기 위해선 display를 flex로 해서 자식들을 하나의 축으로 나열하는 방식을 쓸수 있다. 물론 다른 방법들이 있지만, 내경우 flex를 사용하려고 하기때문에 이렇게 생각한다.\nbasic layout의 구현\norg-\u0026gt;html로 변환했을 때, 크게 body\u0026gt;content 아래 3개의 block이 있다. header, aside, page다. 만일 body\u0026gt;content아래에 header와 content라는 2개의 block만 있다면 flex를 사용하기 용이했을 것이다. 그런데 content아래에 3개의 block이 있고, 3개의 block은 flex의 축을 정하기 어렵게 만든다. 그래서 org에서 page와 aside를 감싸는 빈 container를 하나 더 만들기로 한다. 내용없는 headline에 property를 추가하는 식으로 했다.\n:PROPERTIES: :CUSTOM_ID: main :END: 이제 body\u0026gt; content\u0026gt; header, main \u0026gt; aside, page 형태로 css를 작성하자.\nbody css\nbody { width: 100%; height: 100%; font-family: -apple-system,Inter, sans-serif; font: 13px/1.5 Inter; color: #595959; } content\ncontent는 web page의 크기를 나타낸다고 보면 된다. 그래서 1200x820으로 했다. 자식으로 2개의 block이 있다. header와 main을 위 아래방향으로 하기위해서 column을 사용했다.\n.content{ margin: 0px 0px 0px 0px; padding-top: 50px; display: flex; flex-wrap: wrap; flex-direction: column; height: 820px; } header\nheader { height: 5%; widht: 100%; align-items: center; background: #fff; border-bottom: 1px #ccc solid; padding: 2px; display: flex; } main(#outline-container-main)\n#outline-container-main { height: 750px; widht: 100%; display: flex; flex-direction: row; } aside(#outline-container-aside) page(#outline-container-page) responsive web (지금은 뺐다) viewport meta tag를 html head에 넣는다.\n\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=500, initial-scale=1\u0026#34; user-scalable=\u0026#34;yes\u0026#34; /\u0026gt; 위의 것은 어떻게 보면 필수로 넣는것이다. 그 다음 css에서 처리를 해야한다.\n@media (max-width: 1010px) { .wrapper\u0026gt;.page{ flex: calc(20%); margin-right: 50px; } } @media (max-width: 700px) { .wrapper\u0026gt;.page{ flex: calc(20%); margin-right: 50px; } .footer{ margin-top: 800px; } } 화면이 왼쪽엔 header영역과 오른쪽엔 page영역으로 나눠져 있는데, 토탈하면 1300px정도 width를 갖는다. 1010px아래로 줄어들기 시작하면 어떤 처리를 하고, 계속 줄어들어 700px 이하로 width가 줄어들면 또다른 처리를 하게 했다. 1010px은 desktop browser에서 화면이 줄어들때 글자가 안보이기 때문에 이를 처리할려는 의도다. 700px은 핸드폰같은 mobile device에서 볼때 처리하기 위해서이다. flex:calc(20%)라는 코드가 있는데, 만일 이것이 없다면 화면이 10100px보다 작아지면 오른쪽 page영역이 header영역 아래로 바로 이동한다. 반면에 위 코드가 있기 때문에 바로 page가 header영역 아래로 이동하지 않고, 20%정도 남았을때 이동한다. 20%이상일때는 page의 size가 줄어들기만 한다. page안의 text가 있는데, page가 줄어들면서 줄도 줄어들지만, header아래로 이동하지 않게 된다.\nlayout 설정 내가 원하는 blog의 디자인은 다음 같았다. 이것에 맞추어 layout을 design을 해보았다. css파일은 위에서 정의했듯이 css/style.css에서 기술하면 된다.\norg-publish를 사용하지 않고 backend사용법(중단) org를 html로 변경(org-export-dispatcher) emacs에서 org문서를 다른 문서로 만들려면 org-export-backend가 필요하다. 우리가 C-c e를 누르면 org-export-dispatcher라는 메뉴가 보이는데, 각각의 메뉴들은 backend를 나타낸다.\nFigure 9: backend\n그러면 backend라는 것은 무엇인가? backend는 org문서를 구성하는 여러 구성요소들이 어떤식으로 변환될것인가를 정의한 코드를 의미한다.\n예를 들어서, org문서를 html로 만드는 html backend는 다음과 같은 코드로 되어 있다.\nFigure 10: htmlbackend1\nFigure 11: html backend2\n첫번째 부분은 html이란 이름의 backend를 정의하고, org문서를 구성하는 요소들을 html의 구성요소로 변환시키는 함수를 지정하고 있다. 두번째 이미지에서는 C-e C-c를 누를때 나오는 org-dispatcher의 menu를 만드는 부분과, org문서에서 html관련 option을 지정할 수 있는데, 지정된 option을 html에서 어떻게 처리할것인지 함수로 정의해놓았다. backend에서는 이렇게 org의 모든 문법적요소들이 html의 문법적 요소를 mapping하는 모든 것을 구성해야 한다.\n그런데 org문서에서 내 blog에 맞게 customize해서 html로 변환할 수도 있다. 모든 문법적 요소를 위와같이 정의할 필요 없이 상속해서 사용할 수 있다. 자신이 정의한 내용만 원하는대로 변환하고 나머지는 기존의 rule을 따르는 것이다. 이럴때 사용하는 함수가 org-export-define-derived-backend라는 함수다.아래는 my-backend를 사용하고 \u0026lsquo;html을 상속받는다. 사용법은 다음과 같다.\n(org-export-define-derived-backend \u0026#39;my-backend \u0026#39;html :menu-entry \u0026#39;(?z \u0026#34;Test to My Backend\u0026#34; ((?H \u0026#34;As HTML buffer\u0026#34;) (?h \u0026#34;As HTML file\u0026#34;) (?o \u0026#34;As ODT file\u0026#34; my_func)))) (defun my_func(a b c d) (message \u0026#34;test\u0026#34;)) html backend를 상속하기 때문에 ox-html.el에 있는 html백엔드를 그대로 사용한다. 다만 :menu-entry를 재정의한다. :menu-entry는 C-c C-e로 보여지는 org-export-dispatcher의 메뉴를 의미한다. menu에 정해진 key를 눌렀을때 함수가 호출하게 되어 있는데, 이함수를 사용자 정의함수로 설정할 수 있다. 여기서는 my_func()를 사용한다. menu에서 z o를 누르면 호출되는 my_func에는 4개의 인자가 전달된다.\nASYNC, SUBTREEP, VISIBLE-ONLY and BODY-ONLY\nmain blog 사용법 나는 ox-publish로 static website를 만들었지만, 이 방법은 그렇게 추천하지 않는다. 좀 복잡하다. 그래도 언젠가 수정할 사항이 생기기 때문에 어떻게 사용하는지는 적을 필요를 느꼈다.\n내용 변경 mainblog에 들어가는 내용은 index.org에 기술되어 있다. 그런데, 일반적 org와 다르다. 왜냐하면, html tag로 변환할때 원하는 html tag로의 변환이 안되기 때문에, property와 begin_export html과 같은 요소를 사용했기 때문이다. 내용을 변경하려면 org파일에서 내용들을 변경하면 된다. article을 추가하려면 3rd level headline을 작성하면 된다. 아니면 삭제할 수도 있다. 여튼 수정이 됐다면\u0026hellip;\nM-x org-publish-all 나의 emacs-lisp설정파일(emacs.org)에 보면 org-publish-all이 수행하는 project가 기술되어 있다. 3개의 project가 있는데, org,css,image에 대한 처리를 한다. org를 html로 변경하고, css,image는 public 폴더로 이동한다.\n(require \u0026#39;ox-publish) (setq org-publish-project-alist \u0026#39;( (\u0026#34;my-main-blog\u0026#34; :base-directory \u0026#34;~/MyProjects/main-blog/org/\u0026#34; :base-extension \u0026#34;org\u0026#34; :publishing-directory \u0026#34;~/MyProjects/main-blog/public/\u0026#34; :publishing-function org-html-publish-to-html :recursive t :html-head \u0026#34;\u0026lt;link rel=\\\u0026#34;stylesheet\\\u0026#34; href=\\\u0026#34;./css/style.css\\\u0026#34; type=\\\u0026#34;text/css\\\u0026#34;/\u0026gt; \u0026lt;link rel=\\\u0026#34;shortcut icon\\\u0026#34; href=\\\u0026#34;./img/favicon.ico\\\u0026#34; type=\\\u0026#34;image/x-icon\\\u0026#34;\u0026gt; \u0026lt;link rel=\\\u0026#34;icon\\\u0026#34; href=\\\u0026#34;./img/favicon.ico\\\u0026#34; type=\\\u0026#34;image/x-icon\\\u0026#34;\u0026gt;\u0026#34; :html-head-extra \u0026#34;\u0026lt;link rel=\\\u0026#34;stylesheet\\\u0026#34; href=\\\u0026#34;https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0\\\u0026#34; /\u0026gt;\u0026#34; :section-numbers nil :section-numbers nil :with-toc nil :html-head-include-default-style nil :html-postamble nil ;; :headline-levels 3 ;; :html-tag-class-prefix \u0026#34;my-org-\u0026#34; :html-postamble \u0026#34;\u0026lt;div class=\\\u0026#34;footer\\\u0026#34;\u0026gt;This project is maintained and Copyright © holyfrege 2024. All rights reserved. \u0026lt;br\u0026gt; Hosted on GitHub Pages\u0026lt;/div\u0026gt;\u0026#34; :html-indent t :html-doctype \u0026#34;html5\u0026#34; :html-html5-fancy t ) (\u0026#34;my-main-blog-css\u0026#34; :base-directory \u0026#34;~/MyProjects/main-blog/css\u0026#34; :base-extension \u0026#34;css\\\\|scss\u0026#34; :publishing-directory \u0026#34;~/MyProjects/main-blog/public/css/\u0026#34; :recursive t :publishing-function org-publish-attachment ) (\u0026#34;my-main-blog-img\u0026#34; :base-directory \u0026#34;~/MyProjects/main-blog/img\u0026#34; :base-extension \u0026#34;png\\\\|jpg\\\\|ico\\\\|mov\\\\|mp4\u0026#34; :publishing-directory \u0026#34;~/MyProjects/main-blog/public/img/\u0026#34; :recursive t :publishing-function org-publish-attachment ) )) git에 반영 수정이 끝났으면 holy2frege github에 반영하면 된다. publc폴더부터 반영하고, 그다음 개발 repo를 반영한다. 403에러가 나면 keychain에서 login type github을 삭제한 후에 id(holy2frege), pw(pat)를 입력한다. 반영후 frege2godel.me를 브라우저에서 확인해본다.\n수정 사항들 DONE 반응형 웹페이지 적용 반응형 웹페이지는 meta태그가 필요하다.\n\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026gt; 그리고 mediaquery를 사용할 줄 알면 된다. 참조:https://www.youtube.com/watch?v=qe3nSIg2k3Y 반응형 웹을 고려할때 기기별, 핸드폰, 태블릿, 그리고 pc의 3가지를 생각해야 한다. 핸드폰의 경우 세로버전,가로버전 2가지도 생각해야 한다. 나는 그냥 나만 볼 예정이기 때문에, 700px이하, 즉 핸드폰 세로로 볼때, 700-1024는 핸드폰 가로와 테블릿, 나머지는 pc로 생각해서 구현했다. 이게 맞는 boundary인지는 모르겠다.\n/* ##Device = Most of the Smartphones Mobiles (Portrait) ##Screen = 320px에서 479px 사이, I\u0026#39;m just using 700px. */ @media only screen and (max-width: 700px) { } @media only screen and (max-width: 1024px) { } 안에 들어가는 tag의 width설정과 height설정및 재배치는 chrome개발자도구에서 width를 줄여가면서 보여지는 tag의 css를 개발자도구에서 직접 수정해서 변화되는것을 보고 변경했다. 위에서 생활코딩 동영상하고 거의 같은 방식으로 수정했다. 개발단계에서의 test는 그렇게 편한것은 아니다. main-blog/css/style.css를 수정하고, M-x org-publish-all을 눌러서 publishing처리를 한다. 그런다음에 public폴더의 index.html을 버퍼에 연 후 M-x impatient-mode로 default browser를 연다. 그다음 개발자도구에서 테스트를 한다. 개발자도구에서 mobile device에서 iphone XR을 선택한다. 가로,세로를 테스트하는데 제대로 안된다. 적용이 안되는 거 같다. 그래서 개발자도구 pane을 좌우로 이동시켜서 테스트하고, 어느정도 만족하다 싶을때 git에 반영을 하는 방식으로 처리했다. 설계당시부터 responsive website를 염두에 두고 작성한다면, layout도 고민하고, 예를 들면, 어떤 해상도에서는 flex를 쓰지만, 다른 해상도에선 block으로 바꿔야 할지, 그리고 layout의 size인 pixel로 할지, 다른 단위로 할지도 고민할 거 같다. 여튼 완료는 되었다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/website_make_main_homepage\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/emacs_org_to_ipython_notebook\/": {
        "title": "[emacs] org to ipython notebook",
        "tags": [],
        "content": "org to .ipynb emacs에서 ipython notebook을 직접 다루려면 ein package 를 사용한다. 즉 notebook을 다운로드 받고 notebook형식을 유지한채 편집하고 다시 jupyter나 colab으로 보내는 패키지다. 그런데 org도 ipython notebook도 비슷하기 때문에 org를 notebook(.ipynb)으로 변환해서 colab이나 jupyter에서 사용할 수 있는데, 이것은 ox-ipynb 라는 package를 사용해야 한다. 굳이 이렇게 하는 이유는 emacs에서 org로 편하게 문서 작성하고 이것을 colab(gpu 지원)에서 실행할 수 있기 때문이다. 만일 gpu가 있는 computer를 사용하면 jupyter로 사용하면 된다.\nox-ipynb 사용법 github 위치 John Kitchin이라는 교수가 만든 github이다. from here 설정 .emacs.d/lisp폴더에 다운한다. lisp폴더는 down받은 elisp파일을 모아놓은것이다. 내가 임의로 만든것이다.\nemacs에 설정\n(add-to-list \u0026#39;load-path \u0026#34;/Users/holy/.emacs.d/lisp/ox-ipynb\u0026#34;) (require \u0026#39;ox-ipynb) org문서를 작성후에 C-c e(export dispatcher)를 누르면 변환할 수 있는 menu가 보인다. (org-\u0026gt; jupyter notebook)\nFigure 1: export dispatcher\n사용법 다운 받은 repo에는 example.org 라는 파일이 있다. 해당파일을 open해서 ipynb로 변환하면 된다.\n문제점 org모드에서 사용되는 image가 ipynb로 변환될때, image size가 조절되지 않는다.\norg 문서작성 org로 문서를 작성할때, ipynb로 변환 염두에 두고 있다면, 기존 org와는 다르게 해야 할께 있다.\ncode block code block은 ipython을 사용한다. snippet을 만들었는데, ipython_codeblock로 했다.\nnew cell cell을 만들 수도 있다.\n#+ipynb-newcell\nipython_cell로 snippet을 만들었다.\ntable table은 caption을 달 수 있는데, 이것도 snippet으로 만들었다. ipython_table이다.\nimage image도 snippet으로 만들었다. ipython_img\nhtml html을 직접 입력할수 있다. ipython_html\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_org_to_ipython_notebook\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/kaggle_courses_intro_arithmetic_and_variable\/": {
        "title": "[kaggle-courses-intro] Arithmetic and Variable",
        "tags": [],
        "content": "Arithemetic and Variables Printing 가장 중요한 명령어라고 한다.\nprint(\u0026#34;hello world\u0026#34;) hello world Arithemetic print(1+2) print(9-5) 3 4 Comments Variables ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/kaggle_courses_intro_arithmetic_and_variable\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/kaggle_courses_python_hello_python\/": {
        "title": "[kaggle-courses-python] hello python",
        "tags": [],
        "content": "Hello python ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/kaggle_courses_python_hello_python\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/kaggle_beginning\/": {
        "title": "[kaggle] beginning",
        "tags": [],
        "content": "kaggle kaggle은 초보자를 위한 guide를 제공한다. Learn이란 section이 있는데 기본중에 기본을 다룬다. 그것을 먼저 알아볼 필요가 있고, 그것이 기본기가 될 것이다.\nLearn Figure 1: kaggle 시작\nkaggle의 Learn을 보면 courses와 guide가 나온다. 이것을 먼저 하기로 한다. 물론 아주 기초적인 내용이라 이미 알고 있는게 있을것이다. 그래서 사람들은 kaggle은 competition부터 바로 하라고 한다. 난 돌아가더라도 처음부터 하기로 했다. 사람마다 공부하는 방식은 다 다른것이다.\ncourses Intro to programming Arithmetic and variable Functions Data types Conditions and Conditional statement intro to Lists Python hello python functions and getting help booleans and conditionals lists loops and list comprehensions string and dictionaries working with external libraries Intro to Machine Learnings How models work Basic Data Exploration Your First Machine Learning model Model Validation Underfitting and overfitting Random Forests Machine Learning Competitions Pandas Creating Reading and Writing Indexing, Selecting \u0026amp; Assigning ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/kaggle_beginning\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/leetcode_beginning\/": {
        "title": "[leetcode] beginning",
        "tags": [],
        "content": "leet code leet code는 학습할 수있는 chapter를 제공한다. explorer -\u0026gt; learn은 기초중의 기초다.\nFigure 1: leetcode explorer\nFigure 2: leetcode learn\nThe Leet Code Beginner\u0026rsquo;s Guide 1st problem (1480. Running Sum of 1D Array) 2nd_problem (1672. Richest Customer Wealth) ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/leetcode_beginning\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/leetcode_1480_running_sum_of_1d_array\/": {
        "title": "[leetcode] 1480 running sum of 1d array",
        "tags": [],
        "content": "문제 위치 여기 문제 Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]). Return the running sum of nums.\nexample1 Input: nums = [1,2,3,4] Output: [1,3,6,10] Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].\nexample2 Input: nums = [1,1,1,1,1] Output: [1,2,3,4,5] Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].\nexample3 Input: nums = [3,1,2,10,1] Output: [3,4,6,16,17]\nconstraints 1 \u0026lt;= nums.length \u0026lt;= 1000 -10^6 \u0026lt;= nums[i] \u0026lt;= 10^6 풀이 def test(): nums = [1,2,3,4] output = [] for index,value in enumerate(nums): sum = value for v in nums[0:index]: sum = sum + v output.append(sum) return output print(test()) [1, 3, 6, 10] 의도 우선 nums라는 list에 가리키는 pointer가 2개 있어야 한다고 생각했다. double for-loop을 생각한 것은 첫번째 pointer가 가리킬 때마다 첫번째 원소부터 첫번째 pointer까지 list가 생성되고 그 list의 합을 구해야 하기때문에 2개의 pointer가 필요하다고 생각했다. 이것을 for-loop이 아닌 recursive function으로 구현하는게 더 좋을거 같긴 하지만, 언뜻 생각나는게 for-loop이였다. 구현할때 index가 필요할꺼 같아서 enumerate를 사용해서 index를 얻어왔다. 두번째 for-loop는 slicing을 이용했는데, nums[0:0]은 for-loop안으로 진입하지 못하는거 같다.\nfor v in nums[0:index]: 그래서 첫번째 원소 처리를 첫번째 for-loop에서 가져온 첫번째 원소를 출력 list의 첫번째 원소값으로 하기위해 다음과 같은 처리를 했다. 이게 맞는지 모르겠다.\nfor index,value in enumerate(nums): sum = value accept되긴 했지만 찜찜하다.\n참고 좋은 solution이 많은데, 몇개를 옮겨쓰면 다음과 같다.\nclass Solution: def runningSum(self, nums: List[int]) -\u0026gt; List[int]: for i in range(1, len(nums)): nums[i] += nums[i - 1] return nums for-loop을 한개만 사용했다. nums를 계산하는 과정이 흥미롭다. 이렇게도 짤수 있구나 하는 생각이 든다. 아래에 있는 것도 신선하다. sum()가 list를 인자로 받으면 list의 모든 원소를 합하기 때문에 두번째 for-loop은 필요없다는 것을 말하고 있다.\nlst = [] num = 1 while len(lst) != len(nums): lst.append(sum((nums[0:num]))) num += 1 return lst 더 간단하게 짠것도 있다. itertools라는 module의 accumulate함수를 사용한 건데, 문제를 구현한 함수 같다.\nfrom itertools import accumulate a = [1,3,4] print(list(accumulate(a))) from itertools import accumulate class Solution: def runningSum(self, nums: List[int]) -\u0026gt; List[int]: return list(accumulate(nums)) 요약 우선 내 코드는 상당히 잘못되었다. double loop를 쓴것부터 잘못되었다. 한번의 loop는 돌려야 하는건 맞는거 같다. 그리고, 업무에서는 accumulate함수를 사용하면 될것이다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/leetcode_1480_running_sum_of_1d_array\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/linear_algebra_1_linear_algebra_introduction\/": {
        "title": "[linear algebra-1] linear algebra introduction",
        "tags": [],
        "content": "linear algebra에 대한 생각 인과 관계(causation)와 상관관계(correlation) 어떤 변수와 다른 어떤 변수와의 연관성이 있을때 relation이 있다고 한다. 예를 들어, x가 증가하면 y도 증가한다던지 혹은 x가 증가하면 y가 감소한다. x가 감소하면 y는 증가한다. 등등. 이런 관계를 영어로는 좀 더 명확하게 표현할 수 있는것 같다. 예를 들면, describe variables in terms of one another. 여튼 이런 관계는 수학적으로 표현할 수 있다. 인문학 분야에서도 이런 관계를 표현하는데, 좀 다르다. 인간관계, 상관관계와 같이 구분해서 표현하는데, 이것은 관계를 어떻게 해석하느냐의 문제다. 수학적으로는 어떤 변수의 값이 다른 변수의 값에 영향을 미치는 relation일 뿐이다.\nrelation과 수학적 표현 relation은 집합으로 표현할 수도 있고 1차방정식, 2차방정식, function으로도 relation으로 나타낼 수도 있다. 여튼 이렇게 수학적으로 나타낸 relation은 일종의 법칙과 같다. 예를 들어, 온도가 높아지면 아이스크림 판매량이 늘어난다.를 수학적으로 y = 3x +5처럼 나타낼 수 있다. 이렇게 수식으로 정의되면, 어떤 온도를 x에 집어넣으면 얼마만큼의 아이스크림이 판매될지 예측할 수 있다. 우리가 원하는건, 방정식을 만들고, data를 집어넣어서 예측을 하는 데 있다. 그럼 어떻게 방정식을 만들 수 있을까? data가 있다면 방정식을 만들 수가 있다.\n관계, 예측, data, 방정식 어떤 feature끼리의 관계가 있다면, 그 관계를 방정식으로 만들 수 있다면, 우리는 방정식을 통하여 어떤 data도 예측할 수 있다. 방정식을 만드는 방법은 data로 만든다.\ndata로 방정식 만들기 참조:https://pydata.tistory.com/29 intended: 온도가 올라갈때 마다 아이스크림 판매량을 예측하는 기계를 만들고 싶다. 매일 온도를 측정하고, 판매량을 기록했다. 이 data를 바탕으로 온도에 따라 아이스크림 판매량을 예측하는 기계를 만들고 싶다.\n온도 -4 -3 -2 -1 0 1 2 3 4 아이스크림 판매량 -6 -4 -2 0 2 4 6 8 10 보기 좋게 세로로 변경하자.\n온도 아이스크림 판매량 -4 -6 -3 -4 -2 -2 -1 0 0 2 1 4 2 6 3 8 4 10 이 data를 통해서 온도에 따른 아이스크림 판매량을 예측하는 기계를 만드는 가장 간단한 방법은 방정식을 만드는 것이다. 예를 들면 x를 온도, y를 판매량으로 하는 1차 방정식을 만드는 것이다. x와 y사이에 어떤 관계가 있다는 확신이 들기 때문이다. 그런데 반드시 1차 방정식이여야 하나? nonlinear한 2차방정식이나, 삼각함수나, 다른 방식을 사용할 수 없는가? 물론 있다. x와 y의 관계가 2차방정식의 모양을 가질 수도 있다.우선은 가장 간단한 1차방정식으로 이러한 기계를 만들 수 있는지 확인해 보자. 1차방정식은 모두 비슷한 모양이다. y = mx +b 라는 방정식의 모양이다. 여기서 우리가 방정식을 만들기 위해서는, m과 b를 구해야 한다. 그래야 y=mx+b라는 기계를 만들고, 임의의 온도를 x에 넣었을 때 판매량을 알 수 있기 때문이다.\nm = \\(\\frac{\\Delta y}{\\Delta x}\\), b =\u0026gt; what goes with x = 0\nm을 생각해보면, x가 1씩 증가할 때 y의 증가량이다. 직관적으로 봤을때 값은 2씩 증가하는 것을 볼 수 있다. 따라서 m은 2로 할 수 있다. y = 2x +b에서 b값을 찾아 보자. b는 x가 0으로 갈때, y값이다. 따라서 방정식은 y = 2x + 2가 된다. 그런데 실제 data를 가지고 1차방정식을 만족하는 m과 b를 구할 수 있을까? 거의 없다고 본다. data의 row가 많아질수록 이렇게 딱 떨어지는 기계는 만들 수 없다.\n이것에 대한 생각은 나중에 하고, 우리는 data를 통해서 방정식에 필요한 x의 계수 m과 y의 절편 b를 찾을 수 있음을 보였다. 물론 이렇게 딱 떨어지게 구하는 경우는 거의없다. 그런데, 다른 경우를 생각해 보자. 만일 판매량에 영향을 미치는 요소가 온도만 있는게 아니라, 습도, 해가 떠있는지 유무,등등\u0026hellip; 데이터의 x에 해당하던 온도뿐 아니라, A,B,C,D,\u0026hellip;X까지 24개의 종류가 있다면, 우리는 데이터로 부터 각각의 계수 24개를 구해야 한다. 어떻게 할 것인가? 또한 첫번째 예는 운이 좋아서 구했지만, row가 엄청많다면 더 힘들 것이다. 어떻게 구해야 할지 머리속에 떠오르지 않는다.\n이 때 필요한게 linear algebra다.\nlinear algebra를 설명하기 전에, 우리가 한것을 다시 overview해보자. 우리는 data로 방정식을 만들고, 만든 방정식에 임의의 온도를 넣었을때, 판매량을 예측할 수 있는 machine을 만드는 것이다. 이것을 비유하면, 마치 음식재료와 요리를 가지고 기계를 만들고, 그 기계에 음식재료를 넣는다면, 요리를 만들수 있다는 것과 비슷하다. 다시한번 말하면, X는 음식재료, Y를 음식이라고 하면, 그 정보를 가지고 음식만드는 기계를 만들고, 다른 재료를 넣더라도 비슷한 음식이 나오게 되는 것이다. 우리가 만드는 방정식은 기계다. linear machine이라고 할 수도 있다.\n결론은 우리가 원하는 기계는 여러가지 feature와 결과의 관계로 만들어진다. data로 부터 각각의 feature의 계수를 구하는데 있어 linear algebra를 사용할 수 있다는것만 알아두자.\n왜 linear Algebra인가? Non-linear algebra는 안되는가? 위의 예에서 보면, 2개의 변수를 갖는 경우나 3개의 변수를 갖는 경우나 모두 값이 실수값 하나다.그런데 값이 실수값이 아닌, 다른형태라면, 그것은 non-linear가 될수 있다고 본다.아래에 그것과 관련한 질문을 한적이 있다.\n왜 기계는 정해져 있는가? data가 주어지면, 우리는 기계를 만들고, 만든 기계로 예측을 한다고 했다. 그런데 주어진 data로 만드는 기계의 형태는 정해져 있다. linear machine이다. Y= AX + BY + CZ의 형태다. 여튼 우리는 지금 linear한 기계만 생각한다.\n[강의 시작-1] Scalar, Vector, and Matrix Scalar: 하나의 수를 나타낸다. s \\(\\in\\mathbb{R}^1\\) : 그 수를 s라 할때, 이와같이 표시할 수 있다. \\(\\mathbb{R}\\) 이 실수를 나타내는 집합이기 때문이다. vector: ordered list of number다. x = \\(\\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ \\vdots \\\\ x_n \\end{bmatrix} \\in \\mathbb{R}^n\\) , 여기서 vector는 n차원이다. \\(\\mathbb{R}^n\\) 은 실수를 나타내는 집합R이 n번 곱해진다는 얘기인가? n은 row의 개수를 말하는 거 같다. matrix: 2차원 array다. \\(A = \\begin{bmatrix} 1 \\ 6 \\\\ 3 \\ 4 \\\\ 5 \\ 2 \\end{bmatrix} \\in \\mathbb{R}^{3x2}\\) 3x2는 row의 개수와 column의 개수를 말하는 거 같다. matrix를 vector로 생각(column vector와 row vector) column: 원기둥 vector를 column vector라고도 부른다. 왜 column이란 이름이 붙였냐 하면, matrix를 볼때, matrix의 column이 vector모양이고, matrix는 column형태의 vector로 구성되었다고 생각했다. 모양을 보면, matrix는 column에 해당하는 vector로 분해될 수 있어 보인다. 그래서, matrix에서 vertical column을 column vector라고 불렀다. row vector란건 원래 없었다. vector는 column형태이기 때문이다. 그런데 column vector를 transpose연산을 하면 row vector matrix의 성분들을 vector로 나눌 수 있기 때문에,row vector란 말이 생겼다. vector를 matrix로 생각. matrix를 vector로 보면, column vector가 합쳐진것, 혹은 row vector가 합쳐진 것으로 볼 수도 있다. vector를 matrix로 볼수도 있다. \\(x = \\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\\\ \\vdots \\\\ x_{n} \\end{bmatrix} \\in \\mathbb{R}^n = \\mathbb{R}^{n x 1}\\) 위에 처럼 vector를 n개의 row와 1개의 column인 matrix로 표시할 수도 있다. 그럼 row vector도 마찬가지로 아래와 같이 표시할 수 있다. \\(x = \\begin{bmatrix} x_{1} \\ x_{2} \\ x_{3} \\end{bmatrix} \\in \\mathbb{R}^n = \\mathbb{R}^{1 x 3}\\) 즉 1개의 row와 3개의 column을 가진 matrix로 표시할 수 있다. Transpose 연산 row vector와 transpose 원래 row vector는 없었다. vector는 column의 모양을 하고 있었기 때문이다. 그런데, column형태의 vector를 row vector형태로 사용할 일은 많았다. 그래서 Transpose라는 연산을 통해서 row vector를 만들어 사용했다. 지금도 마찬가지다. vector는 transpose해서 row vector로 사용한다. 예를 들면 다음과 같다. \\(X = \\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\\\ \\vdots \\\\ x_{n} \\end{bmatrix}^T = \\begin{bmatrix} x_{1} \\ x_{2} \\ x_{3} \\ldots \\x_{n} \\end{bmatrix} \\in \\mathbb{R}^{1 x n}\\) n x 1의 column vector를 transpose해서 1 x n의 row vector를 만든 것이다. transpose와 matrix vector를 row vector로 만들기 위해서 transpose연산을 취했지만, matrix도 transpose연산을 취할 수 있다.\n아래를 보자.\nA = \\(\\begin{bmatrix} 1 \\ 6 \\\\ 3 \\ 4 \\\\ 5 \\ 2 \\\\ \\end{bmatrix} \\in \\mathbb{R}^{3 X 2}\\)\nA = \\(\\begin{bmatrix} 1 \\ 6 \\\\ 3 \\ 4 \\\\ 5 \\ 2 \\\\ \\end{bmatrix}^{T}\\) =\u0026gt; \\(\\begin{bmatrix} 1 \\ 3 \\ 5 \\\\ 6 \\ 4 \\ 2 \\end{bmatrix}\\)\nA matrix는 2개의 column vector로 보면 된다. 첫번 째 column vector가 첫번 째 row vector로 transpose되고, 두번 째 column vector가 두번째 row vector가 된다.\nMatrix notations Square Matrix row와 column이 같은 matrix를 square matrix라고 부른다. 특별한 기호로 나타내진 않는다.\ne.g., B = \\(\\begin{bmatrix} 1 \\ 6 \\\\ 3 \\ 4 \\end{bmatrix}\\)\nRectangular Matrix row와 column이 같지 않은 matrix를 Rectangular Matrix로 부른다. 이것도 특별한 기호를 사용하지 않는다.\ne.g., A = \\(\\begin{bmatrix} 1 \\ 6 \\\\ 3 \\ 4 \\\\ 5 \\ 2 \\end{bmatrix}\\)\nTranspose연산자 기호 Transpose는 matrix 상단에 T를 표시해서 나타낸다.\ne.g., \\(A^{T}\\) = \\(\\begin{bmatrix} 1 \\ 3 \\ 5 \\\\ 6 \\ 4 \\ 2 \\end{bmatrix}\\)\ncomponent의 표시 Matrix의 하나의 원소를 지칭하는 방법, index는 1부터 시작한다. e.g., \\(\\textbf{A}_{ij}\\) , \\(\\textbf{A}_{21}\\) = 3\nmatrix에서 column vector와 row vector표시 row vector\nmatrix에서 row vector는 row를 지정하고 column을 :로 표시한다. 그리고 둘 사이 ,가 삽입된다. e.g.,\\(\\textbf{A}_{i,:}\\) \\(\\textbf{A}_{2,:} = \\begin{bmatrix} 3 \\ 4 \\end{bmatrix}\\)\ncolumn vector\nmatrix에서 column vector는 column을 지정하고 row를 :로 표시한다.그리고 둘 사이 ,가 삽입된다. e.g.,\\(\\textbf{A}_{:,j}\\) \\(\\textbf{A}_{:,2} = \\begin{bmatrix} 6 \\\\ 4 \\\\ 2 \\end{bmatrix}\\)\nsummary scalar가 무엇인지? vector가 무엇인지? matrix가 무엇인지를 배웠다. 어떤 응용에 있어서 그런 용어가 가진 역할이라던가 본질에 대한 의미라기 보다는 생김새, 모양 구조를 배웠다. 예를 들면, 숫자로 된 data가 낱개로 있을때는 scala, 어떤 구조로 organize되어 있으면, vector, matrix 용어로 부른다는 것이다. 아직까진 별다른 얘긴 없다.\n[강의 시작-2] vector/Matrix 덧셈 곱셈 위에서도 말했듯이 우리는 data로 1차원기계를 만들것이다. 수많은 음식재료가 나오기 때문에, 즉, 음식재료가 많기 때문에, matrix나 vector로 만들지 않으면 안된다. 데이터가 vector, matrix형태로 organize되어 있을때, 그것들을 가지고 어떤 처리, 계산을 할수 있어야 한다. 정확하게는 1차원기계의 계수와 절편을 계산해야 하기때문에 Matrix/vector에 대한 계산 방식을 알아야 한다. 그리고 vector는 계산에 있어서 matrix로 취급한다.\n덧셈과 뻴셈 addition 덧셈은 같은모양의 matrix끼리만 할 수 있다.\nscala 곱 그냥 scalar값을 더하거나 뺀다. 더하거나 빼도 같은 모양이 된다.\n내적(inner product, dot product) 내적을 계산하면, 앞 매트릭스의 column과 뒷 매트릭스의 row가 같아서 소멸되고, 앞의 매트릭스의 row와 뒤의 column으로 size가 정해진 매트리스가 새로 만들어진다. 예를 들어서, 100x30과 30x500의 matrix는 100 x 500의 matrix를 만들어 낸다. 내적은 matrix와 matrix를 곱해서 새로운 matrix를 만들어낸다는 것이다. 덧셈이나 scala곱은 기존의 matrix 크기를 변화시키지 않는다. 하지만, 내적은 다르다. 내적은 두개의 matrix를 기반으로 새로운 모양의 matrix로 만든다. 새로운 모양의 matrix가 기존의 matrix보다 클수도 작을수도 있다. 이럴땐 내적을 해야해!라던가 내적이 어떨땐 내적을 사용해! 뭐 이런건 나오지 않았다.\n내적은 not commutative. commutative라는 말은 교환법칙이다. AB \\(\\not=\\) BA. 강사는 3가지의 경우를 모두 예를 들어서 설명한다.\nAB는 계산이 되지만, BA가 계산이 안되는 경우 \\(A \\in \\mathbb{R}^{2X3}\\) 고 \\(B \\in \\mathbb{R}^{3X5}\\) 이면, \\(AB \\in \\mathbb{R}^{2X5}\\) 이지만, $BA$는 만들 수 없다.\nAB와 BA계산이 되지만, size가 안맞는경우 \\(A \\in \\mathbb{R}^{2X3}\\) 고 \\(B \\in \\mathbb{R}^{3X2}\\) 이면, \\(AB \\in \\mathbb{R}^{2X2}\\) 이지만, \\(BA \\in \\mathbb{R}^{3X3}\\) , 따라서, \\(AB \\neq BA\\).\nAB와 BA계산도 되고 size도 맞지만 계산이 다른 경우\neg., \\(\\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 4 \\end{bmatrix}\\) \\(\\begin{bmatrix} 5 \\ 6 \\\\ 7 \\ 8 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 19 \\ 22 \\\\ 43 \\ 50 \\end{bmatrix}\\)\n\\(\\begin{bmatrix} 5 \\ 6 \\\\ 7 \\ 8 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 4 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 23 \\ 34 \\\\ 31 \\ 46 \\end{bmatrix}\\)\n값이 다른것을 알 수 있다.\nother properties Distributive A(B+C) = AB + AC :commutative같은 경우 성립이 안되는 경우를 모두 보여주었다. 분배 법칙의 경우도 조건이 있는거 아닌가? A의 column과 B row 가 같아야 하고, A의 column과 C의 row가 같아야 만 저 식이 성립되는거 아닌가? 어째든 성립이 된다고 가정하면, 결과는 어떻게 될까? 성립이 되면,AB라는 매트릭스와 AC라는 매트릭스가 만들어지고 두 매트릭스가 size도 같다면, 하나의 매트릭스가 결과값으로 나올 것이다. 그러나 반드시 하나의 매트리스가 된다는 보장은 없다. AB + AC인 상태가 될 수있다.\nAssociative A(BC) = (AB)C Associative도 A의 column과 B의 row가 같으면 위 계산이 가능하다. 결합법칙은 괄호의 연산이 가능하다면 순차적으로 풀면된다. 내적으로 연결된 계산을 할땐 어떤순서로 해도 상관없다는 뜻이다.\nProperty of Transpose \\((AB)^{T} = B^{T}A^{T}\\) 내적의 transpose를 transpose의 내적으로 바꿀수도 있고, transpose로 된 matrix의 내적을 묶은후 transpose할 수 있다. transpose는 size의 경우 뒤바뀜이 일어나고 1st row가 1st column으로 이동한다.\n[강의시작 2-1] Linear System Linear System: 연립방정식과 그에 따른 연산을 포함한다. Linear system에선 여러개의 Linear Equation을 Matrix를 사용해서 풀수 있다.\nLinear Equation 이전에 말했듯이 우리가 Linear Algebra를 사용하는 이유는 요리재료와 음식이 주어질때, 이 정보를 가지고 Linear Equation이란 기계를 만든다고 했다. Linear Equation 기계의 형태는 대략적으로 정해져 있다. 왜냐면 Linear Algebra를 사용하기 때문이다. 우리는 위에서 음식재료가 하나일때는, 하나의 음식재료 가지고 y = ax +b라는 형태의 기계를 만든다고 했다. 그 기계를 만든다는 것은 a와 b를 구하는 것이라고 했다. 아래 표에서 보듯이 음식재료 X가 Y라는 음식이 주어지면 방정식의 계수와 절편을 푸는것이다.\nX -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 그리고 여러종류의 음식재료가 있을때는, 예를 들어 2개의 음식 재료 W,X가 있고, 만들려는 음식이 Y 일 때는,\nW -2 -1 -5 -1 0 5 3 7 1 X -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 Y = aW + k1꼴의 방정식과 Y = bX + k2이란 방정식을 둘다 만족시키는 계수(a,b)와 절편(k1,k2)을 찾아야 한다.\n음식재료가 3개일때도 보자.\nV -2 -1 -5 -1 0 5 3 7 1 W -2 -1 -5 -1 0 5 3 7 1 X -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 Y = aV k1 라는 꼴의 기계, Y= bW +k2라는 기계, Y= cX +k3라는 기계를 모두 만족시키는 하나의 기계를 만들어야 한다. 최종기계는 어쩌면, Y = aV + k1 = b k2, Y = aV +bW + cX + k꼴의 기계의 a,b,c 그리고 k 절편을 구하는것일 지도 모른다.\nlinear algebra의 적용(linear system과 linear equation) linear system: set of linear equations,연립방정식을 뜻한다. 우리는 이 linear system을 풀면된다. 즉 여러개의 linear equation이 모인 linear system을 matrix, vector형태로 표시하고 이를 계산해서 각각의 linear equation의 계수와 절편을 구한다. 그러면 우리가 표를 사용해서 계수와 절편을 구하려고 equation을 만들었는데, 변수와 계수를 변경한다. 왜냐면 우리가 원하는건 계수였기 때문에 계수가 변수가 된다. 그리고 우리는 matrix형태로 data(table)을 표현할 수 있어야 한다. 그리고 절편은 없다고 생각하자. 식을 간단하게 하기 위해서이다. 우리에게 주어지는 것은 음식재료와 음식을 가지고 기계를 linear algebra 기계의 계수를 구해보자. 예를 들어 보자. 이건 강사의 예제다. 강사는 4가지 정보(data)를 바탕으로 얼마나 오래사는지를 예측하고 싶어한다. 우리는 linear machine을 만들어야 한다. 아래는 data다. 이것으로 linear machine을 만들어 보자.\nPerson_ID 1 2 3 Weight 60kg 65kg 55kg Height 5.5ft 5.0ft 6.0ft Is_smoking yes(=1) No(=0) Yes(=1) life-span 66 74 78 위 data를 가지고 linear machine(값을 예측하는 기계)을 만드는데는 process가 필요하다.\n위 data를 linear system으로 구성한다. linear system을 풀면 linear machine의 계수를 알수 있다. 계수만 알면 linear machine이 만들어 지는 것이다. linear system을 만들자. linear system은 linear equation으로 구성된다.linear equation으로 만들기 위해서 표를 transpose하자. transpose하면 matrix로 표현하기 쉽다.\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 3 55kg 6.0ft Yes(=1) 78 \\(60x_{1} + 5.5x_{2} + 1x_{3} = 66\\) \\(65x_{1} + 5.0x_{2} + 0x_{3} = 74\\) \\(55x_{1} + 6.0x_{2} + 1x_{3} = 78\\)\n이렇게 linear combination을 통해 linear system을 만들었다. 이제 matrix/vector형태로 만든다.\n\\(\\begin{bmatrix} 60 \\ 5.5 \\ 1 \\\\ 65 \\ 5.0 \\ 0 \\\\ 55 \\ 6.0 \\ 1\\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\end{bmatrix}\\) = \\(\\begin{bmatrix} 66 \\\\ 74 \\\\ 78 \\end{bmatrix}\\) 이렇게 보면 Ax = b의 형태다.\nmatrix는 대문자, vector는 소문자로 표시한다. 여기서 좀 tweak(조금 고치다;튜닝)을 하면, 아래와 같이 볼 수도 있다.\n\\(a^{T}_{1}x = 66\\) \\(a^{T}_{2}x = 74\\) \\(a^{T}_{3}x = 78\\)\n이제 여기까지하면 data를 가지고 linear system을 만들었다고 볼 수 있다.\nlinear system 풀기 prerequisite for solving linear system\nlinear system을 푼다는 것은 계수인 x vector를 구하는 것이다. 그런데 풀기위해선 행렬 계산법에 대해 몇가지 개념들을 알아야 한다. 그중 Identity matrix를 먼저 살펴보자.\nIdentity Matrix\n항등 행렬로 부른다. 항상 등식이 성립하는 matrix다. diagonal entry들이 모두 1인 square matrix다. I라고 표시하고 다음과 같이 size를 표시한다.\n\\(I_{n} \\in \\mathbb{R}^{n X n}\\)\ne.g., \\(I_{3}\\) = \\(\\begin{bmatrix} 1 \\ 0 \\ 0 \\\\ 0 \\ 1 \\ 0 \\\\ 0 \\ 0 \\ 1 \\end{bmatrix}\\)\n이 matrix의 특징은 이 matrix에 곱해지는 matrix의 결과는 자기자신이라는 것이다. 예를 들어보자.\ne.g., \\(\\begin{bmatrix} 1 \\ 0 \\ 0 \\\\ 0 \\ 1 \\ 0 \\\\ 0 \\ 0 \\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\end{bmatrix}\\) = \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\end{bmatrix}\\)\n3x3과 3x1로 3x1의 vector가 계산되지만, 그 vector가 자기자신임을 알 수 있다. vector도 matrix의 일종이다.\nInverse Matrix\nIdentity matrix를 통해서 Inverse Matrix의 개념이 생겼다고 한다. Inverse Matrix도 Identity matrix처럼 squared matrix다. 어떤 matrix가 있을 때, 그 matrix의 inverse matrix를 내적하면 자기 자신이 된다.\ninverse matrix\nsquare matrix \\(A \\in \\mathbb{R}^{n X n}\\) \\(A^{-1}A\\) = \\(AA^{-1}\\) = \\(I_{n}\\) 특이한 것은 \\(A^{-1}\\) 를 구할때, A와 I를 알고 있기 때문에, A와 I를 적당히 처리해서 구할 수 있을거라고 생각하지만, 구할 수 없다. 예를 들어 \\(AA^{-1}\\) = \\(I_{n}\\) 이니까, 양변에 \\(A^{-1}\\) 을 내적해서 구할수 있지 않을까 하고 생각하는데, 구할 수 없다. inverse matrix는 구하는 공식이 있다.\ne.g., \\(A\\) = \\(\\begin{bmatrix} a \\ b \\\\ c \\ d \\end{bmatrix}\\) 라 하자.\n\\(A^{-1}\\) = \\(\\frac{1}{ad - bc}\\) \\(\\begin{bmatrix} d \\ -b \\\\ -c \\ a \\end{bmatrix}\\)\ne.g., \\(A\\) = \\(\\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 4 \\end{bmatrix}\\) 라 하자. \\(A^{-1}\\) = \\(\\frac{1}{4 - 6}\\) \\(\\begin{bmatrix} 4 \\ -2 \\\\ -3 \\ 1 \\end{bmatrix}\\) = \\(\\begin{bmatrix} -2 \\ 1 \\\\ \\frac{3}{2} \\ - \\frac{1}{2} \\end{bmatrix}\\)\n즉, A에서 ad-bc를 계산한 후, diagonal의 component들을 바꿔주고 나머지는 -값을 해준다.\n여기서 한가지 특이한건, matrix는 transitive하지 않다고 했다. 즉 교환법칙이 성립하지 않는다. AB와 BA는 같지 않았다. 하지만, A와 A의 역행렬은 교환법칙이 성립하는 것을 볼 수 있다.\nSolving linear system\n이제 linear system을 풀기 위한 준비가 되었다. data를 가지고 우리는 linear system을 만들었다. 그 구조는 다음과 같았다.\n\\(Ax = b\\)\n\\(\\begin{bmatrix} 60 \\ 5.5 \\ 1 \\\\ 65 \\ 5.0 \\ 0 \\\\ 55 \\ 6.0 \\ 1\\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\end{bmatrix}\\) = \\(\\begin{bmatrix} 66 \\\\ 74 \\\\ 78 \\end{bmatrix}\\)\n\\(Ax = b\\) 에서 계산을 위한 matrix인 Identity와 Inverse matrix를 사용해서 푼다. 풀이 과정은 다음과 같다.\n\\(Ax = b\\) \\(A^{-1}Ax = A^{-1}b\\) \\(I_{n}x = A^{-1}b\\) \\(x = A^{-1}b\\)\n이제 적용해 보자. 우리의 linear system에서 \\(A^{-1}\\) 을 구해보자.\n\\(A^{-1}\\) = \\(\\begin{bmatrix} 0.0870 \\ 0.0087 \\ -0.0870 \\\\ -1.1304 \\ 0.0870 \\ 1.1314 \\\\ 2.0000 \\ -1.0000 \\ - 1.0000 \\end{bmatrix}\\)\n이제 \\(x = A^{-1}b\\) 을 계산하면 된다.\n\\(x = A^{-1}b\\) = \\(\\begin{bmatrix} 0.0870 \\ 0.0087 \\ -0.0870 \\\\ -1.1304 \\ 0.0870 \\ 1.1314 \\\\ 2.0000 \\ -1.0000 \\ - 1.0000 \\end{bmatrix}\\) \\(\\begin{bmatrix} 66 \\\\ 74 \\\\ 78 \\end{bmatrix}\\) = \\(\\begin{bmatrix} -0.4 \\\\ 20 \\\\ -20 \\end{bmatrix}\\)\n이렇게 하면 linear system을 풀었다.\nlinear machine\n우리는 linear system을 계산해서 linear machine의 계수를 구했다. 이제 linear machine을 완성시키자.\nlinear machine coefficients = \\(\\begin{bmatrix} -0.4 \\\\ 20 \\\\ -20 \\end{bmatrix}\\)\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 3 55kg 6.0ft Yes(=1) 78 (life-span) = -0.4 x (Weight) + 20 x (Height) -20 x (Is_smoking)\nlinear system의 한계? rectangular matrix의 inverse matrix\nlinear system을 풀기 위해서, 우리는 Identity Matrix와 Inverse matrix를 배웠고 또 활용했다. 그런데 Identity matrix와 Inverse Matrix는 모두 square matrix다. Rectangular matrix는 역행렬이 존재하지 않는다. 그래서 위의 계산방식으로 사용할 수 없다. 그러면 linear system을 풀수 없다는 얘기인가? 그렇지 않다. 그것에 대한 얘기를 할것이다. 물론 programming상에선 알아서 구해주기 때문에 걱정하지 않아도 된다.\nNon-Invertable Matrix A for Ax = b 위에서 data를 가지고 linear machine을 만들었다. linear machine을 만드는 과정에서 역행렬을 사용했다. 그런데 역행렬을 만들 수 없는 경우가 있다. 이전에도 말했듯이 rectangular matrix도 역행렬을 만들 수 없다. 그런데 square matrix도 역행렬을 만들 수 없는 경우가 존재한다. 예를 들어보자.\neg., \\(A = \\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 6 \\end{bmatrix}\\)\n위 matrix는 square matrix이다. 그러나 ad-bc가 0이다. 따라서 역행렬이 존재하지 않는다. ad -bc를 계산하지 않아도, 위 matrix의 column vector는 한개 feature의 data다. 즉 2개 feature data라고 볼 수 있는데, 이 2개의 data가 같은 data로 볼 수 있다. 첫번 째 column에 2를 곱하면, 두번 째 column과 같아진다. 이런경우 역행렬을 구할 수 없다고 볼 수 있다.\n어떤 matrix가 주어졌을때, 역행렬이 존재하는지 안 하는지를 판별하는게 ad -bc가 0인지를 계산했는데, 이것을 A의 determinant라고 한다. 보통은 다음과 같이 표시한다.\n\\(det A\\)\n그러면, 3X3 matrix에서 determinant를 구할 수 있을까? 구할 수 있다. 4X4\u0026hellip;등등.. 강사는 그림으로 알켜줬지만, 난 여기에 적진 않겠다.\n역행렬 존재의 의미. linear system에서 data행렬이 3x3의 square행렬이고, 역행렬이 존재해서 linear machine의 계수를 구할 수 있었다. 그런데, 우리가 받는 data가 3개의 feature를 갖고, 3개의 값만 있지 않다. 정방행렬 형태의 data는 일부러 만든것이고, 실제는 rectangular data일 확률이 더 높다. 또한 정방행렬의 data가 주어진다고 해도 판별식이 0인경우가 많다. 판별식이 0이면 역행렬이 존재하지 않기 때문에 위의 방식으로 해를 구할 수가 없다. inverse matrix로 해를 구할수 없다고 해서, 해가 없다라고 말한다면, 그것은 맞는 것일까? 그렇지 않다. 정방행렬에서 판별식이 0인 경우는 해가 없을수도 있지만,해가 무수히 많을 수도 있기 때문이다. 아래 예를 보자.\neg., \\(\\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 6 \\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\end{bmatrix}\\) = \\(\\begin{bmatrix} 4 \\\\ 12 \\end{bmatrix}\\)\n위 matrix는 판별식(determinant)가 존재하지 않는다. ad-bc가 0이다. 따라서 inverse matrix가 존재하지 않는다.그러면 이 linear system의 해는 없는것인가? 아니면 해가 무수히 많은 것인가? 위 matrix 곱을 풀어서 보자.\n\\(x_{1} + 2x_{2} = 4\\) \\(3x_{1} + 6x_{2} = 12\\)\n두 equation들은 동일하다. 왜냐면 3을 윗방정식에 곱했을 때 같은 동일한 직선이기 때문이다. 우리가 해라고 말하는건 위에서 풀어쓴 두 직선의 교점을 얘기한다. 두직선의 교점은 무수히 많다. 따라서 matrix곱의 해는 무수히 많다. 즉 해는 무수히 많다.\n그럼, 해가 없는 경우를 살펴보자. 위 방정식을 그대로 이용하자.\n\\(x_{1} + 2x_{2} = 4\\) \\(3x_{1} + 6x_{2} = 13\\)\n이 경우도 판별식은 0이다. 따라서 역행렬로 해를 구할수는 없다. 따라서 matrix곱을 풀어써보자. 두개를 직선으로 본다면 동일한 직선이 아니다. 따라서 해가 무수히 많지도 않다. 판별식이 0이 아니고 역행렬이 있다면, unique한 해를 가질텐데 그렇지도 못하기 때문에, 따라서 이 경우는 해가 존재하지 않는다.\n강사는 2개의 video를 참조영상으로 제공했다. mit 선형대수 강좌 18,19다. 여기1 여기2 이게 무슨 의미인가? data를 사용해서 기계를 만들려고 할려면 matrix곱을 풀어야 한다. 그런데, matrix곱형태의 계산은 어렵다는 것이다. matrix곱 해결방법으로 흔히 쓰이는 inverse matrix로 양변에 곱해서 해결할려는 시도는 한계가 있다는 것이다. 첫번째 한계는 sqaure matrix만 역행렬이 존재한다는 점이다. 두번째 한계는 sqaure matrix라고 해도, 판별식이 0이 되는 경우, 역행렬을 양변에 곱해서 해를 구하는 계산은 할수 없다는 점이다. 세번째로, matrix의 크기가 커지면, 판별식 자체 계산이 힘들다는 것이다. 설사, 위의 세가지 경우를 벗어나, square matrix이고, 역행렬이 존재하고, 그리고 계산이 가능하다 할지라도, 해가 1개만 unique하는 경우만 답을 구할 뿐이다. 우리는 해가 한개인,unique한 해를가지고, 기계를 만들 수도 있지만, 해가 여러개 되는 경우에도 기계를 만들어야 하고, 혹은 해가 없는 경우에도 기계를 만들어야 한다. 따라서 우리는 square matrix에 구애 받지 않는 rectangular matrix곱의 해를 구하는 방법과, 해가 없는경우, 해가 무수히 많은 경우의 처리를 생각해야 한다.\nRectangular matrix의 계산 data를 제공 받아서,우리는 linear machine을 만든다고 했다. 그러기 위해선 linear machine의 coefficients가 필요했다. 이것이 matrix곱에서의 x벡터(가중치 벡터)를 의미한다. x벡터를 data로 부터 구했을때, 새로운 data의 예측이 가능했다. 그런데 matrix곱형태의 해를 구하는 계산이 역행렬을 곱하는 식으로는 안된다는 점과, 해가 없을때, 해가 무수히많을때를 해결해야 한다.\n우선 해를 따져보자. Rectangular한 data가 주어질때, rectangular matrix가 가진 모양의 특징이 있다. 모양에서 해의 개수를 예측가능하다는 것이다. m: 방정식수(data수) n:feature라고 했을때, 다음과 같이 일반적으로 예측할 수 있다.\nm \u0026lt; n : 보통은 해가 무수히 많다.\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 일반적인 얘기다. 100% 이렇다라고 말할 수는 없다. 여튼 이런 경우를 under-determined system이라고 부른다고 한다.\nm \u0026gt; n : 보통은 해가 없다.\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 3 55kg 6.2ft Yes(=1) 78 4 55kg 6.4ft Yes(=0) 78 5 55kg 6.0ft Yes(=1) 78 6 55kg 5.8ft Yes(=1) 78 이 경우도 일반적인 얘기다. 보통 해가 없는경우가 많고, over-determined system이라고 부른다.\noh my god! 나는 Rectangular matrix도 역행렬을 구하는 다른 방식이 있을 줄 알았다. 그런데 그 설명은 아직 없다. 해를 구하는 계산을 설명하기에 앞서서, 해가 1개인지, 해가 무수히 많은지 아니면 존재하지 않는지에 대해서 먼저 고민해야 한다.\n해가 unique하다는 것은 기계를 1대 만들수 있고, 그 기계로 예측을 할수 있기 때문에, 제일 좋은 케이스다. 그런데 해가 없다는 것은 data를 가지고 machine을 만들지 못한다는 얘기가 된다. 두번째 해가 무수히 많다는 얘기는 우리가 구할려는 x벡터가 어떤값을 가져도 상관없다는 얘기가 된다. x벡터(가중치벡터)가 1000개 2000개 존재할 수 있다는 얘기도 된다. 1000개 2000개 무한하게 많은 기계를 만들수 있다는거다. 그런데, 주어진 data에 대한 각각의 기계의 값은 동일하나, 새로운 data에 대한 각 기계마다 예측값이 다 다를 것이다. 이게 문제다. 그러면, 해가 없는 경우, 해가 많은 경우는 어떻게 해야 하나? 해가 없는경우, 기계를 만들 수 있는가? 어떻게 기계를 만들것인가? 해가 많은 경우, 어떤 기계를 선택할 것인가? 하는 문제가 있다.\nmachine learning과 deep learning은 이런 문제를 해결하기 위한 solution을 준다.\n해가 없는 경우를 보자. 예를들어 1000개의 equation을 모두 만족하는 해가 없다고 할때, 근사화된 해를 선정한다. 근사화된 해라는 것은 예를 들어, 어떤 계수들을 가질때, 결과오차율의 합이 제일 작다면, 그것을 해로 정한다.\n해가 무수히 많은 경우는 regularization이란 기법을 사용한다. regularization은 보통 risk management라고 부른다. 많은 해 중에서, 가장 risk가 적은 해를 선택하겠다는 것이다. 예를 들면, 아래의 표를 통해서 우리는 여러개의 해를 구했다고 치자.\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 해는 가중치라고 했다. weight, height, is_smoking에 대한 가중치 벡터가 해가된다. 이 해가 여러개 있다고 치자. 어떤해는 height에 150, 다른 어떤해는 20이라는 값을 갖는다면, 150의 가중치를 갖는다는것은 결과에 지대한 영향을 준다. 혹은 키에 민감한 반응을 보여주는 machine이라고 말할 수 있다. 우리는 해가 여러개 있는 경우, 하나를 선택하는 것이다. 이것에 대한 선택은 어떤 법칙은 없다. 다만 민감도(risk)를 따져서 선택할 뿐이다.\n내가 질문한 내용. 오피스아워에서 질문했던건데요. 해결되었습니다. 제가 말도 잘못하고, 잘 모르다보니 이상한 말을 많이 하게 되네요. 여튼 문제는 해결됐습니다.아래는 제가 생각했던,질문가졌던 내용과 배경을 말해봤습니다.\n[질문배경] 저는 우리가 하는게 수치data로 방정식과 같은 수학적 formula를 만들고, 만든 방정식에 수치data를 입력해서 값을 예측하는 모델을 만든다고 생각했습니다. 마치 음식재료와 요리를 넣어서 음식만드는 기계를 만든다고요. 그래서 간단한 표(data)에서 방정식을 만들어봤습니다. 1차방정식을 아래표에서 계산 하면, 기울기는 x의 증가량과 y의 증가량을 구해서 2를 구했고, y절편은 x가 0일때니까 2를 구했습니다. 그래서 y = 2x +2로 방정식을 만들었는데요.\nX -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 만일 음식재료가 많을 경우(아래와 같은표)는 위의방식대로 만들기 어렵다. 그래서 linear algebra를 사용한다고 생각했습니다.\nW -2 -1 -5 -1 0 5 3 7 1 X -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 그런데 여기서 생각한게 음식재료가 많아봤자(A, B, C \u0026hellip;W,X) 결국에는 Aa+Bb+Cc…와 같은 linear한 방정식만 만드는것 같아요. 여기서 non-linear한 방정식을 만드는 것은 없을까? 하다가 그러면 위에처럼 1차방정식을 data로 유도하듯이 2차방정식을 어떻게 유도하는지를 알고 싶었어요. 그런데 찾아보니 https://sciencing.com/quadratic-equations-table-10001169.html 이 방식이 있더라구요. 여기선 data가 ordered pair형식으로 되어 있더라구요. 그래서 table에 있는 data가 아래와 같은 형태로 되어 있다면 non linear하다고 생각했습니다.\nX (-4,2) ( -3,4) (-2,1) (5,-1) (0,2) (1,2) (2,3) (3,3) (4,4) Y -6 -4 -2 0 2 4 6 8 10 그런데 결론적으로 제가 잘못생각했습니다. 여기서 tuple의 모양은 의미가 없고, tuple을 vector로 생각해서 vector를 넣는 tensor로 non-linear처리가 가능하다는 강사선생님이 말씀하셨는데, 즉 저기의 tuple모양은 vector로 봐도 된다고 하신것과 다름없다고 생각됩니다. 그리고 한동훈님이 말씀하신 것도 일맥상통한거 같습니다. 즉 저기의 tuple모양이던 list모양이던 vector로 치환될 수 있다. 따라서 굳이 tuple같이 따질 필요가 없다. 이말이 맞는거 같습니다.\n여기서 또 질문 어떤 data가 있고, 그 data를 사용해서 방정식을 만들고, 만든 방식으로 예측한다. 그런데 왜 1차방정식만을 생각할까? 음식재료가 있고, 요리가 있을때, 서로간의 관계를 왜 1차 방정식기계만으로 한정하냐는 말이다. 다른 기계는 없을까? 2차방정식도 그중에 하나고, 다른형태의 기계도 만들 수 있는거 아닌가?\nX -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 여기서 또 질문 우리가 해야하는건 data가 주어지면, data로부터 기계를 만드는 것이다. 기계는 1차방정식의 형태다. 1차방정식은 여러 형태가 있지만, 음식재료가 A와 같다면, 우리는 y= Av+Bw+CX+D의 기계를 만들어야 한다. 그러면 어떻게 linear algebra를 사용해서 이런 기계를 만들 수 있을까? 그리고 data가 주어질때, A가 아닌 B의 형태로 주어졌을때, 동일한 data이지만 모양만 transpose한것이라면, 만들어지는 기계는 동일한 것인가? 라는 질문을 던질 수도 있다.\nV(음식재료) -2 -1 -5 -1 0 5 3 7 1 W(음식재료) -2 -1 -5 -1 0 5 3 7 1 X(음식재료) -4 -3 -2 -1 0 1 2 3 4 Y(음식) -6 -4 -2 0 2 4 6 8 10 W(음식재료) X(음식재료) Y(음식) -2 -4 -6 -1 -3 -4 -5 -2 -2 -1 -1 0 0 0 2 5 1 4 3 2 6 7 3 8 1 4 10 ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/linear_algebra_1_linear_algebra_introduction\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/linear_algebra_2_linear_independence\/": {
        "title": "[linear algebra-2] linear independence",
        "tags": [],
        "content": "summary of lecture 14 and about lecture 15 lecture 14에서 배운것은 다음과 같다. 우리는 주어진 data로부터 machine을 만든다. 즉 linear system이라는 연립방정식의 형태로 만드는데, matrix곱의 형태다. data에 해당하는 matrix와 해에 해당하는 가중치 벡터의 곱의 형태로 나타내진다. 즉, 가중치 벡터의 값을 계산할 수 있다면, machine을 만들게 되는 것이다. 가중치 벡터의 값을 계산하기 위해서 역행렬을 양변에 곱하는 방식을 설명했었는데, 이건 squared matrix에만 해당하기 때문에, Rectangular matrix에는 적용이 안되는것을 보았다. 설사 주어진 data가 sqaured matrix형태라고 할지라도, ad-bc가 0이되면, 역행렬을 구할수 없어서 해를 구하지 못했다. 그리고 역행렬을 구할 수 없는것을 자세히 살펴보니, 해가 없거나, 해가 무수히 많은 경우가 있는 것을 알았다. 우리의 최종 목표는 해가 unique하다면, 그 해로 machine을 만드는 것이고, 해가 없다면, 주어진 data를 만족 시키는 가장 그럴싸한 가중치 벡터를 정하는 것이다. 그리고 해가 무수히 많은 경우, 어떤 해를 선택하느냐?는 민감도에 따라 선택할 수 있다고 했다. lecture 15에서 예상되는 강의는, 주어진 data로부터 linear system을 만들때,rectangular matrix의 곱 형태로 주어질때, unique한 해를 구하거나, 해를 못구하는 경우, 해가 무수히 많은 경우를 판단하는 방법을 배울거 같다. lecture 14에서는 squared matrix의 unique한 해를 구하는 방법과, 판별식에 따라 해가 무수히 많은 경우와 해가 없는 경우를 예를 들어서 살펴봤기 때문이다. 이번장에선 좀 더 일반적인 형태일 수도 있는 rectangular matrix 곱의 처리에 대해서 배울거 같다.\nLinear Combinations 개요 갑툭튀로 linear combination이 나온다. linear combination이 나온것은 Rectangular matrix 곱을 처리하기 위한 한 방편이기 때문이다. matrix곱으로된 linear system이 주어졌을때, 해가 있는지,없는지조차 알수 없고, 있다면 어떻게 구해야하는지도 못하는 상황이다. 그래서 linear combination을 사용하는 것 같다.\n우선, 기본 개념에 대해 말해보자. vector들의 기본연산은 vector들의 덧셈과 scalar와 vector의 곱이다. 이것을 조합해서 \\(cv + dw\\) 형태로 나타낸것을 linear combination이라고 한다.\nvector의 addition은\n\\(v + w\\)\nvector의 linear combinations은\n\\(cv + dw\\)\nvector의 addition은 vector의 linear combination중 c와 d가 1인 경우를 뜻한다.\nLinear System의 변경. data가 주어졌을 때, Linear machine을 만드는데 필요한 coefficients를 구하기 위해서 Linear system을 만들었다. Linear System은 matrix로 만들었었다.\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 3 55kg 6.0ft Yes(=1) 78 \\(\\begin{bmatrix} 60 \\ 5.5 \\ 1 \\\\ 65 \\ 5.0 \\ 0 \\\\ 55 \\ 6.0 \\ 1\\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\end{bmatrix}\\) = \\(\\begin{bmatrix} 66 \\\\ 74 \\\\ 78 \\end{bmatrix}\\) Ax = b의 형태다.\n이전 장에서 matrix곱 형태로 된, 위와 같은 방정식의 해를 구하는 방식은 역행렬은 한계가 있어서 안된다고 했다. 또한 해가 있는지 없는지도 기존의 역행렬 방식엔 한계가 있다고 했다. 이 상황에서 matrix곱형태의 방정식을 강사는 linear combination형태로 바꿀 수 있다고 말한다. 해가 있는지 없는지도 모르고 있다고 해도 어떻게 구해야 하는지 모르는 상태에서 linear combination으로 표현하는 게 rectangular matrix곱을 처리하는데 어떤 도움이 되는것일까?\n\\(\\begin{bmatrix} 60 \\\\ 65 \\\\ 55 \\end{bmatrix}\\) \\(x_{1}\\) + \\(\\begin{bmatrix} 5.5 \\\\ 5.0 \\\\ 6.0 \\end{bmatrix}\\) \\(x_{2}\\) + \\(\\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix}\\) \\(x_{3}\\) = \\(\\begin{bmatrix} 66 \\\\ 74 \\\\ 78 \\end{bmatrix}\\)\n여튼, linear combination으로 바꿨다. 이전의 matrix와 vector의 곱보다 더 직관적으로 방정식처럼 보이긴 한다.\n\\(\\begin{bmatrix} 60 \\\\ 65 \\\\ 55 \\end{bmatrix}\\) \\(x_{1}\\) + \\(\\begin{bmatrix} 5.5 \\\\ 5.0 \\\\ 6.0 \\end{bmatrix}\\) \\(x_{2}\\) + \\(\\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix}\\) \\(x_{3}\\) = \\(\\begin{bmatrix} 66 \\\\ 74 \\\\ 78 \\end{bmatrix}\\) =\u0026gt; \\(a_{1}x_{1} + a_{2}x_{2} + a_{3}x_{3} = c\\) 의 형태다.\nlinear combination을 풀어쓰면 아래와 같이 볼 수 있는데, 이것은 matrix곱을 풀어쓴 형태와 같다. 즉 matrix의 곱을 linear combination으로 나타내도 동일한 식이라는 뜻이다.\n\\(60x_{1} + 5.5x_{2} + 1x_{3} = 66\\) \\(65x_{1} + 5.0x_{2} + 0x_{3} = 74\\) =\u0026gt; matrix곱을 풀어쓰면 동일하다. \\(55x_{1} + 6.0x_{2} + 1x_{3} = 78\\)\n여기서 linear combination으로 표현하나 matrix곱으로 표현하나 동일한 식인건 알았다. 그러면, linear combination으로 표현을 하면 해가 있는지 없는지 여부, 혹은 해가 있다면 구할 수 있다는 것인가?\nspan 강사는 span이란 개념을 이어서 설명한다. span과 linear combination과 어떤 연관이 있는지 모르겠지만, span이란 개념을 알아야 한다고 한다. span은 vector들을 원소로 하는 무한 집합이라고 한다. 그러면, span이란 집합은 어떻게 만들어지고, 도데체 span이 무엇인가? 어떤 집합인가? 라는 질문을 할 수 있다. span은 어떤 vector들이 주어질때, 그 vector에 모든 선형결합을 적용해서 만들어지는 집합이다. 예를 들어보자.\neg., 어떤 vector가 있다.\n\\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}\\)\n이 vector의 linear combinations는 실수를 곱해서 나오는 모든 vector들의 집합이다. 그리고 그 무한 집합을 이 vector의 span이다라고 말한다. 즉 vector가 원점에서 해당점으로의 선분이라고 하면, 이 벡터의 linear combinations는 직선을 나타내는데, 그것이 span이다. 즉 linear combinations의 집합이 span이다.\neg., 두개의 vector가 있다고 하자.\n\\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}\\) \\(\\begin{bmatrix} 4 \\\\ 5 \\\\ 6 \\end{bmatrix}\\)\n이 두 vector에 취할 수 있는 모든 계수를 곱해서 linear combinations형태로 만든다. 아래와 같이 만들면 무한집합이 만들어 진다.\n\\(c_{1}\\) x \\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}\\) + \\(c_{2}\\) x \\(\\begin{bmatrix} 4 \\\\ 5 \\\\ 6 \\end{bmatrix}\\)\n즉, 위 두개 vector의 span은 d\\(c_{1}\\) 과 \\(c_{2}\\) 에 모든 실수를 넣었을때 얻을수 있는 모든 vector들의 집합이다.\n구체적으로 예를 들면, \\(c_{1}\\) 과 \\(c_{2}\\) 의 값이 (0,0)이라고 할때,\n\\(\\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}\\)\n\\(c_{1}\\) 과 \\(c_{2}\\) 의 값이 (1,1)이면\n\\(1\\) x \\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}\\) + \\(2\\) x \\(\\begin{bmatrix} 4 \\\\ 5 \\\\ 6 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 5 \\\\ 7 \\\\ 9 \\end{bmatrix}\\)\n이렇게 계속 vector들이 만들어지고, 만들어지는 vetor들의 집합을 span이라고 한다.\nspan of { \\(\\left{ \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} , \\begin{bmatrix} 4 \\\\ 5 \\\\ 6 \\end{bmatrix} \\right }\\) }로 표시된다.\n지금 까지 진행상황을 보면, matrix곱으로 된 방정식에선, 해가있는지, 없는지도 모른다. 즉 계산조차 안되는 상황이다. 이런 상황에서 강사는 matrix의 곱을 linear combination으로 표현하고 span을 갑자기 배웠다. span을 배우는 이유는 기하학적인 의미와 linear combination과의 관계가 있기 때문이다. matrix곱을 linear combination으로 표현하는데, linear combination은 span을 나타내기 때문이란다. 방정식은 Ax = b꼴로 나타내는데, A라는 matrix를 linear combination으로 표현할 수 있고, linear combination을 기하학적으로 해석하기 위해서 span이란 개념이 도입된다는 것이다.\nspan의 기하학적 의미 span이라는게 주어진 vector나 vector들을 linear combination을 해서 나오는 vector들의 집합이라고 했다. 이 span이라는 것을 기하학적으로 생각해 보자. 주어진 vector가 하나라고 하자. 좌표공간에서 vector 한개는, 원점을 기준으로 하는 하나의 선분으로 볼수도 있고, 하나의 점으로 볼 수도 있다. 이 벡터의 linear combinations라는 것은 실수를 곱해서 나오는 결과들이다. 이것들의 집합이 span이 된다. 한개 vector의 span이란 기하학적으로는 원점과 주어진 벡터의 점을 통과하는 직선으로 볼 수도 있고, 주어진 벡터라는 선분을 통과하는 직선으로 볼 수 있다. 한개 벡터의 linear combinations들은 주어진 벡터 선분의 길이를 늘리거나 줄일뿐이다.\n따라서, 만일 어떤 방정식이 주어졌다고 생각하자. matrix곱의 형태다. 이것을 linear combination으로 풀어쓸 수 있었다. 좌변은 linear combination의 형태고, 우변은 vector다. 이런 형태를 어떻게 해석할 것인가? 우변의 vector가 좌변의 linear combination으로 표현된다는 것은 좌변의 column vector들의 span의 원소라고 말할 수 있다. 이것이 의미하는 바는 이방정식에서 해는 존재한다가 된다. 만일 linear combination형태로 만들수 없다면 해는 없다라고 말해도 된다.\n구체적인 예를 들어보자. 우리가 어떤 data로 부터 matrix곱 형태의 방정식을 얻었다고 하자.\n\\(\\begin{bmatrix} 1 \u0026amp; 4 \\\\ 2 \u0026amp; 5 \\\\ 3 \u0026amp; 6 \\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\end{bmatrix}\\) = \\(\\begin{bmatrix} 5 \\\\ 7 \\\\ 9 \\end{bmatrix}\\)\n이것의 좌변을 linear combination형태로 바꾸자.\n\\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}\\) x \\(x_{1}\\) + \\(\\begin{bmatrix} 4 \\\\ 5 \\\\ 6 \\end{bmatrix}\\) x \\(x_{2}\\) = \\(\\begin{bmatrix} 5 \\\\ 7 \\\\ 9 \\end{bmatrix}\\)\n여기서 기하학적으로 보면 \\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}\\) 와 \\(\\begin{bmatrix} 4 \\\\ 5 \\\\ 6 \\end{bmatrix}\\) 로 이루어지는 span안에 \\(\\begin{bmatrix} 5 \\\\ 7 \\\\ 9 \\end{bmatrix}\\) 가 포함되는지 여부는 \\(x_{1}\\) 과 \\(x_{2}\\) 로 구할 수 있다. \\(x_{1}\\) 과 \\(x_{2}\\) 이 1이되면 식도 만족하고 span안에 포함된다고도 말할수 있다.\nMatrix곱을 linear combination으로 변경(column) linear combination의 장점 다시 한번 review하면, 우리는 data를 가지고 linear system을 만들었다. 그런데 linear system을 matrix 형태로 계산을 해서 해를 구했다. matrix를 계산한다는 것은 inverse matrix와 내적을 사용했다. Identity matrix의 개념도 들어가게 된다. 그런데 이 방식으로는 rectangular matrix곱에는 적용되지 않는다. 해가 있는지 없는지도 계산할수 없다. 그래서 다른 대안으로 linear system을 matrix가 아닌, linear combination으로 나타냈고, 여기서 해를 계산할 수도 있지만, 계산이 아닌 기학학적인 의미를 따져서 해가 있는지 없는지 여부를 기하학적으로 따질 수 있게 되었다.\nlinear combination으로 표현하는것의 또다른 장점은 계산량에서 잇점이 있다고 한다. 예를 들어보자. 우리가 data로부터 matrix 형태의 linear system을 만들었다고 가정하자.\neg., \\(\\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 6 \\end{bmatrix}\\) \\(\\begin{bmatrix} x \\\\ y \\end{bmatrix}\\) = \\(\\begin{bmatrix} 4 \\\\ 12 \\end{bmatrix}\\)\n이 matrix multiplication은 matrix의 row vector와 column vector의 내적으로 계산될 수 있다.\n\\(1 x + 2y =4\\) \\(3x +6y = 12\\)\n계산은 (2번의 곱셈 + 1번의 덧셈) x 2배가 사용된다. 즉 6번의 계산량이 있다.그런데 linear combination으로 나타낸다면 계산량은 어떻게 될까?\n\\(\\begin{bmatrix} 1 \\\\ 3 \\end{bmatrix}\\) x + \\(\\begin{bmatrix} 2 \\\\ 6 \\end{bmatrix}\\) y = \\(\\begin{bmatrix} 4 \\\\ 12 \\end{bmatrix}\\) =\u0026gt; \\(ax + by =c\\)\n위와 같이 linear combination으로 계산하면, 계산량은 절반이 된다. vector를 통째로 1개로 본다. 그러면 2번의 곱과 1번의 덧셈만 하면 된다. 이것은 좀 어패가 있긴하다. 그러면 matrix의 계산은 Matrix를 한개를 통으로 본다면, 1번의 계산일 뿐이기 때문이다.\nmatrix의 곱을 linear combination으로 변환 matrix와 vector곱 형태 여튼 강사가 말하고자 하는것은 matrix로 표현된것을 linear combination으로 변환된 형태로 사용하고 싶은 것이다. 그러면 matrix multiplication들이 linear combination으로 변환되는 과정을 예를 들어 보자.\neg., \\(\\begin{bmatrix} 1 \\ 1 \\ 0 \\\\ 1 \\ 0 \\ 1 \\\\ 1 \\ \\llap{-} 1 \\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}\\) =\u0026gt; \\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) 1 + \\(\\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix}\\) 2 + \\(\\begin{bmatrix} 0 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) 3\n위의 모양은 linear combination을 나타내는 전형적인 모양이라고 한다. 즉 matrix와 column의 곱으로 나타내지면, matrix는 column으로 분해되고, column은 가중치이기 때문에, 분해된 matrix column과 가중치로 linear combination을 만들어낸다.\nmatrix와 matrix의 곱형태를 linear combination으로 변환 예시1\neg., \\(\\begin{bmatrix} 1 \\ 1 \\ 0 \\\\ 1 \\ 0 \\ 1 \\\\ 1 \\ \\llap{-}1 \\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\ \\llap{-}1 \\\\ 2 \\ 0 \\\\ 3 \\ 1 \\end{bmatrix}\\) =\u0026gt; 3x3x3x2 =\u0026gt; 3x2형태다. \\(\\begin{bmatrix} a_{1} \\ b_{1} \\\\ a_{2} \\ b_{2} \\\\ a_{3} \\ b_{3} \\end{bmatrix}\\)\n이것을 \\(\\begin{bmatrix} a \\ b \\end{bmatrix}\\) 꼴이라고 생각하자. a,b is vector.\nlinear combination의 결과는 column vector다. matrix의 곱 결과 matrix가 나왔지만, 나온 matrix를 보면, 2개의 column vector로 이루어져 있다고 보고, 각 column vector인 \\(a\\) 와 \\(b\\) 를 linear combination으로 나타낼 수 있다면 좌변의 matrix의 곱을 linear combination형태로 변환이 가능하다는 얘기가 된다.\n이전의 matrix와 vector의 곱을 linear combination으로 나타낸것을 기억해 보자. 좌변 matrix의 각각의 column vector에 vector를 계수로 해서 linear combination을 나타냈었다.\neg., \\(\\begin{bmatrix} 1 \\ 1 \\ 0 \\\\ 1 \\ 0 \\ 1 \\\\ 1 \\ \\llap{-} 1 \\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}\\) =\u0026gt; \\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) 1 + \\(\\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix}\\) 2 + \\(\\begin{bmatrix} 0 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) 3\n그러면, 비슷하게, 좌측의 matrix로부터 column vector로 분해하고, 우측의 matrix는 가중치로 생각하면 된다. 위에서는 가중치가 한개의 vector였다면, 아래에서는 가중치가 2개의 vector라고 보면된다. 그 결과가 [a b]형태가 되는 것이다.\n\\(\\begin{bmatrix} 1 \\ 1 \\ 0 \\\\ 1 \\ 0 \\ 1 \\\\ 1 \\ \\llap{-}1 \\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\ \\llap{-}1 \\\\ 2 \\ 0 \\\\ 3 \\ 1 \\end{bmatrix}\\) , 이것이 아래와 같이 변한다.\n\\(a = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) 1 +\\(\\begin{bmatrix} 1 \\\\ 0 \\\\ -1 \\end{bmatrix}\\) 2 + \\(\\begin{bmatrix} 0 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) 3\n\\(b = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) -1 +\\(\\begin{bmatrix} 1 \\\\ 0 \\\\ -1 \\end{bmatrix}\\) 0 + \\(\\begin{bmatrix} 0 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) 1\n예시2\neg., 3X3행렬과 3X3행렬의 곱을 linear combination으로 똑같이 나타낼 수 있다. 결과는 아래와 같은 형태이기 때문에,\n\\(\\begin{bmatrix} a \\ b \\ c \\end{bmatrix}\\)\n계산과정은 같다. 좌측은 column vector로 분해되고, 우측은 가중치를 나탄내다고 볼 수 있다.\n즉, 결론적으로 말하면, matrix multiplication은 linear combination으로 나타낼 수 있다는 것이다.\nmatrix의 곱을 linear combination으로 표현하기2 (row) 개요 matrix의 곱으로 표현된 식을 linear combination으로 나타낼 수 있다고 했다. 그런데 linear combination에서 vector는 column vector를 말하는 거지, row vector를 말하는 게 아니다. row vector로 linear combination을 만들수 있을까?\nrow vector와 column vector간에는 관계가 있다. 무턱대고 matrix와 matrix의 곱을 row vector의 계산식으로 표현할려고 시도 할 수 있는데, 강사는 row vector와 column vector의 transpose한 관계가 있고 그 관계를 이용하는게 쉽게 matrix의 곱을 row vector linear combination로 나타낼 수 있다고 한다. 사담이지만 강사는 처음에 vector라는 단어가 column vector를 의미한다고 했다. row vector라는 단어는 애초부터 없다고 했다. 그런데, column vector에 transpose한 연산을 적용 시켜서 나온 결과도 모양이 다른 vector이기에 row vector라고 불렀다고 했다.\ncolumn vector의 transpose 그런 transpose라는 연산에 대해서 살펴보자. row vector linear combination은 transpose를 이용한다고 하니 transpose를 알 필요가 있다. column vector의 transpose는 row vector다. item의 column이 row가 되고 row가 column이 되기 때문이다. 즉, item의 row와 column이 바뀌는 게 transpose다.\n\\(item_{i,j}\\) =\u0026gt; \\(item_{j,i}\\)\n1(1,1) =\u0026gt; 1(1,1) 2(2,1) =\u0026gt; 2(1,2) 3(3,1) =\u0026gt; 3(1,3) \\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}\\) =\u0026gt; \\(\\begin{bmatrix} 1 \\ 2 \\ 3 \\end{bmatrix}\\)\nmatrix의 곱의 transpose matrix 곱에 대한 transpose연산 법칙이 아래와 같이 존재한다.\n\\((AB)^{T} = B^{T}A^{T}\\)\nrow vector combination transpose를 사용하는게 matrix곱의 row linear combination을 쉽게 만드는 방법이라고 했는데, 위의 transpose의 교환법칙을 이용한다.\n\\((AB)^{T} = B^{T}A^{T}\\)\n윗식에서 A와 B의 matrix곱에 대한 transpose할것이다. 그리고 다시 transpose한다면 원래 식과 동일한 계산이된다. 즉 transpose를 두번해서 원식으로 돌아올 수 있기에 다른 식은 아니다. 그런데 왜 transpose를 하는가? transpose를 하면 row vector linear combination형태가 나오기 때문이다. 다음 예를 보자.\n\\(A =\\) \\(\\begin{bmatrix} 1 \\ 1 \\ 0 \\\\ 1 \\ 0 \\ 1 \\\\ 1 \\ \\llap{-}1 \\ 1 \\end{bmatrix}\\) , \\(B =\\) \\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}\\)\nA와 B의 곱을 transpose 해보자.\n\\(\\left(AB \\right)^{T}\\) = \\(\\left( \\begin{bmatrix} 1 \\ 1 \\ 0 \\\\ 1 \\ 0 \\ 1 \\\\ 1 \\ \\llap{-}1 \\ 1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} \\right)^{T}\\) =\u0026gt; transpose하면 교환 법칙에 의해서 \\(\\begin{bmatrix} 1 \\ 2 \\ 3 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\ 1 \\ 1 \\\\ 1 \\ 0 \\ \\llap{-}1 \\\\ 0 \\ 1 \\ 1 \\end{bmatrix}\\)\n이 나오게 되는데, 이런 형태의 matrix곱이 row vector linear combination을 만들수 있게 해준다. column vector로 linear combination을 만들때는 왼쪽의 matrix에서 column vector를 분해하고, 우측의 matrix는 가중치 matrix였다. 여기서는 반대다. 왼쪽의 matrix가 가중치를 나타내고, 오른쪽 matrix에서 row vector를 분해한다. 이렇게 분해된 row vector와 가중치를 linear combination으로 나타낼 수 있다. 아래가 바로 row vector linear combination이다.\n1 x \\(\\begin{bmatrix} 1 \\ 1 \\ 1 \\end{bmatrix}\\) + 2 x \\(\\begin{bmatrix} 1 \\ 0 \\ \\llap{-}1 \\end{bmatrix}\\) + 3 \\(\\begin{bmatrix} 0 \\ 1 \\ 1 \\end{bmatrix}\\)\n이것은 원래의 matrix곱의 계산결과하고는 다르다. 같게 하기 위해선, transpose를 해야 한다. 원래의 matrix 곱에 transpose를 한건 단 하나의 이유, row vector linear combination을 만들기 위해서였다. 이렇게 만든 후 다시 transpose하면 column vector가 나오는게 그게 matrix곱의 결과다.\n우리가 지금 한것은 matrix와 column vector의 곱은 row vector combintation으로도 계산할 수 있고, column vector combination으로 계산할 수 있다는 것이다.\n일반적 형태의 matrix곱을 row vector linear combination으로 나타내기. 아래와 같은 matrix 곱이 있다고 하자.\n\\(\\begin{bmatrix} 1 \\ 2 \\ 3 \\\\ 4 \\ 5 \\ 6 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\ 1 \\ 0 \\\\ 1 \\ 0 \\ 1 \\\\ 1 \\ \\llap{-}1 \\ 1 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 6 \\ \\llap{-}2 \\ 5 \\\\ 15 \\ \\llap{-}2 \\ 11 \\end{bmatrix}\\)\n이것을 row vector linear combination으로 나타내기 위해선, 우선 matrix의 곱에 transpose를 한다.\n\\(\\begin{bmatrix} 1 \\ 1 \\ 1 \\\\ 1 \\ 0 \\ \\llap{-} 1 \\\\ 0 \\ 1 \\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\ 4 \\\\ 2 \\ 5 \\\\ 3 \\ 6 \\end{bmatrix}\\) =\u0026gt; 3x3 3x2 =\u0026gt; 3x2, \\(\\begin{bmatrix} a_{1} \\ a_{2} \\\\ b_{1} \\ b_{2} \\\\ c_{1} \\ c_{2} \\end{bmatrix}\\) =\u0026gt; \\(\\begin{bmatrix} a \\\\ b \\\\ c \\end{bmatrix}\\) a,b,c 3개의 row vector.\nrow vector로 linear combination을 만들기 위해서 좌측의 matrix는 가중치가 되고, 우측 matrix는 row vector로 분해가 된다고 했다. 가중치와 row vector로 표현된 linear combination이 각각 결과의 a,b,c row vector가 된다. 즉 row vector combination에선 가중치 matrix도 row vector들이 분해된 row vector 각각에 적용된다. column vector에선 column vector가중치들이 column vector각각에 적용된것과 같다. 아래와 같이 a,b,c를 구한 후 transpose하면 원식과 같게 된다.\n\\(a =\\) 1 \\(\\begin{bmatrix} 1 \\ 4 \\end{bmatrix}\\) + 1 \\(\\begin{bmatrix} 2 \\ 5 \\end{bmatrix}\\) + 1 \\(\\begin{bmatrix} 3 \\ 6 \\end{bmatrix}\\)\n\\(b =\\) 1 \\(\\begin{bmatrix} 1 \\ 4 \\end{bmatrix}\\) + 0 \\(\\begin{bmatrix} 2 \\ 5 \\end{bmatrix}\\) + -1 \\(\\begin{bmatrix} 3 \\ 6 \\end{bmatrix}\\)\n\\(c =\\) 0 \\(\\begin{bmatrix} 1 \\ 4 \\end{bmatrix}\\) + 1 \\(\\begin{bmatrix} 2 \\ 5 \\end{bmatrix}\\) + 1 \\(\\begin{bmatrix} 3 \\ 6 \\end{bmatrix}\\)\nmatrix곱과 linear combination matrix와 matrix의 곱은 linear combination으로 나타낼 수 있다. row combination으로 할 수도 있고, column combination으로 나타낼 수도 있었다. row combination은 계산 방식도 column combination과 반대고, 마지막에 transpose를 해주는것도 잊으면 안된다.\nouter product inner product와 outer product라는 용어에 대해 알아 볼 필요가 있다.\ninner product: 두개의 vector를 곱했을때, 결과가 scala이면 inner product라고 부른다.\n\\(\\begin{bmatrix} 1 \\ 2 \\ 3 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) =\u0026gt; \\(\\begin{bmatrix} 6 \\end{bmatrix}\\)\nouter product: 두개의 vector를 곱했을 때, matrix형태를 가지면서 차원이 커질 때, outer product라고 부른다.\n\\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\ 2 \\ 3 \\end{bmatrix}\\) =\u0026gt; \\(\\begin{bmatrix} 1 \\ 2 \\ 3 \\\\ 1 \\ 2 \\ 3 \\\\ 1 \\ 2 \\ 3 \\end{bmatrix}\\)\n내적과 외적은 vector에서 사용하는 용어다. matrix에는 내적이나 외적이란 용어가 없다. 여기서, vector의 연산인 outer product를 소개하는 이유는, 행렬의 곱셈에 outer product가 사용될 수 있기때문이다. 다음과 같이 matrix곱이 있다고 하자.\n\\(\\begin{bmatrix} 1 \\ 1 \\\\ 1 \\ \\llap{-}1 \\\\ 1 \\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\ 2 \\ 3 \\\\ 4 \\ 5 \\ 6 \\end{bmatrix}\\)\nmatrix와 matrix의 곱을 계산하는 방식은 위에서 배웠듯이 matrix의 column vector와 row vector의 내적을 계산해서 구할 수 있다. 그 다음은 linear combination으로 변환한 후 계산해도 된다. 그런데, 때에 따라서는 outer product형태로 변환해서 계산하면 간단히 계산할 수 있다고 한다. 아래는 outer product형태로 변환해서 계산하는거라고 하는데, 엄청 간단한것을 볼 수 있다.\n\\(\\begin{bmatrix} 1 \\ 1 \\\\ 1 \\ \\llap{-}1 \\\\ 1 \\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\ 2 \\ 3 \\\\ 4 \\ 5 \\ 6 \\end{bmatrix}\\) =\u0026gt; \\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\ 2 \\ 3 \\end{bmatrix}\\) + \\(\\begin{bmatrix} 1 \\\\ \\llap{-}1 \\\\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} 4 \\ 5 \\ 6 \\end{bmatrix}\\)\n행렬의 곱을 column linear combination으로 표현할때는 column vector들과 column 가중치를 곱해서 column형태로 나타냈고, row linear combination의 경우는, row 가중치를 row vector에 곱해서 row vector를 만들어 냈다. 그런데 outer product는 column vector와 row vector의 곱으로 나타낸다. 매우 간단하게 계산되는것 같다.\nrank-1 rank1과 기저 벡터 rank-1이란 말은 기저벡터가 1개라는 뜻이다. 아래는 matrix 곱이다. 따라서, outer product의 합으로 계산할 수도 있고, linear combination으로 계산할 수도 있다. 그런데 계산을 하는게 아니라, 기하학적으로 어떤 의미가 있을까? 그리고 전형적 outer product의 모양이기도 하다.\n\\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\ 2 \\ 3 \\end{bmatrix}\\) =\u0026gt; \\(\\begin{bmatrix} 1 \\ 2 \\ 3 \\\\ 1 \\ 2 \\ 3 \\\\ 1 \\ 2 \\ 3 \\end{bmatrix}\\)\n위의 계산을 column vector기준으로 말할 수도 있고, row vector기준으로 말할 수 있다. column vector기준으로 말한다면, column vector에 1을 곱해서 나온 vector와 2를 곱해서 나온 vector, 3을 곱해서 나온 vector의 결과가 결과 matrix에 있다고 볼수있다. 이것을 기하학적으로 다음과 같이 설명할 수 있다.\n\\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) 은 하나의 선분이다.\n여기에 1을 곱하거나, 2, 3을 곱해서 나오는 vector들은 하나같이 해당 vector의 span에 포함된다. \u0026hellip;,-3,-2,-1,0.5,1,2,3\u0026hellip; 이런 실수를 곱해서 나오는 vector들은 모두 원래 vector를 늘이거나 줄이거나 할 뿐이다. 따라서 vector 선분을 포함하는 직선인 span에 다 포함되게 되어 있다.\n여기서, 좌변의 column과 가중치를 곱해서 나오는게 matrix의 column요소라고 본다면, 좌변의 column을 기저 vector라고 부른다. 또한 결과 matrix는 rank가 1인 matrix라고 부른다.\n동일한 예제 \\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\ 2 \\ 3 \\ 4 \\end{bmatrix}\\) =\u0026gt; \\(\\begin{bmatrix} 1 \\ 2 \\ 3 \\ 4 \\\\ 1 \\ 2 \\ 3 \\ 4 \\\\ 1 \\ 2 \\ 3 \\ 4 \\end{bmatrix}\\) =\u0026gt; 결과 matrix의 각 column vector는\n옆과 같이 만들어진다. \\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) 1 , \\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) 2 , \\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) 3 , \\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) 4\n이것도 기학학적인 측면에서 살펴보면, 좌변의 column에 가중치를 곱해서 나오는 vector들이 matrix를 구성한다. matrix를 구성하는 column vector는 좌변 column vector의 span에 포함되기 때문에, 좌변의 column vector는 기저벡터가 되고 우변의 matrix는 rank1 이라고 말할 수 있다.\n그런데 이것은 위에서도 말했지만, column vector기준으로 설명한 것이다. row vector기준으로 설명하면 어떻게 될까?\n좌변의 [1 2 3 4] 벡터에 1을 곱한것들이 우변의 matrix의 row vector를 구성한다. 따라서 [1 2 3 4]이란 vector는 기저벡터로 볼 수 있고, 기저벡터의 span에 우변 matrix를 구성하는 row vector들이 모두 포함되기 때문에 rank1 matrix라고 볼 수 있다.\n그런데 왜 갑자기 rank-1이란 matrix를 소개했을까? 우리가 지금배우고 있는것과 무슨 연관이 있는 것일까? 우리는 matrix곱을 linear combination으로 나타낼 수 있고, span을 통해서 해가 있는지 없는지도 알수 있다고 했다. matrix의 곱을 linear combination으로 나타낼때, matrix의 column 개수만큼, column vector와 가중치의 곱으로 나타냈었다. 그리고 각각의 column vector는 eigen vector에 해당한다고 설명했다. 하지만, 위에서든 outer product예나 rank-1 matrix의 경우는 matrix가 여러개의 eigenvector가 아닌 1개의 eigenvector로도 나타낼 수 있음을 보여준다.\n실제 데이터의 응용 강사는 여기서 예를 든다. 만일 우리에게 어떤 data가 큰 matrix형태로 주어진다고 하자. 500x 2400의 크기를 갖는 matrix다. 그리고 방정식이 아래와 같이 주어진다 하자.\n\\(\\begin{bmatrix} 1 \\ 1 \\ \\ldots \\ 0 \\\\ 1 \\ 0 \\ \\ldots \\ 1 \\\\ \\vdots \\ \\ \\vdots \\\\ \\ 1 \\ 1 \\ \\ldots \\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\ x_{2} \\ \\ldots \\ x_{2400} \\end{bmatrix}\\) = \\(\\begin{bmatrix} y_{1} \\\\ y_{2} \\\\ \\vdots \\\\ y_{500} \\end{bmatrix}\\)\n이것을 linear combination로 표현한다면, 2400의 column과 가중치를 곱하는 식을 만들수 도 있다. 그리고 2400개의 eigenvector가 있다고 말할수 있을것이다.\n그런데, 이 matrix가 어떤 2개의 matrix곱으로 표시될 수 있다고 하자. 예를 들면, 500X2로 된 matrix와 2x2400의 임의 matrix로 표시된다고 하자. 두개의 matrix의 곱은 500x2400의 matrix가 된다는 건 확인할 수 있다. 그림으로 표시하면 아래와 같다.\n\\(\\begin{bmatrix} 1 \\ 1 \\ \\ldots \\ 0 \\\\ 1 \\ 0 \\ \\ldots \\ 1 \\\\ \\vdots \\ \\ \\vdots \\\\ \\ 1 \\ 1 \\ \\ldots \\ 1 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 1 \u0026amp; 3 \\\\ 2 \u0026amp; 3 \\\\ \\vdots \u0026amp; \\vdots \\\\ 3 \u0026amp; 5 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; \\ldots \u0026amp; 3 \\\\ 4 \u0026amp; 5 \u0026amp; \\ldots \u0026amp; 6 \\end{bmatrix}\\)\n우변의 2개의 column이 어떤 matrix와 곱해서 좌변이 만들어진다는 것은 우변 2개의 column vector가 기저 벡터고 기저벡터에 가중치에 해당하는 matrix를 곱해서 좌변이 나온다고 볼 수 있다. 위에서도 기저벡터와 rank1 matrix 설명과 동일한 것이다. 좌변의 matrix는 rank2라고 말할 수 있는데, 이것을 factorization이라고 해서, matrix를 인수 분해 한다고 말한다. 그런데 이렇게 big table이 주어졌을 때, matrix곱의 방정식을 무조건 linear combination으로 나타내는게 아니라, pre-processing처럼, matrix factorization을 하면 해당 방정식을 더 쉽게 분석할수 있다는 의미에서 이것을 배우는거 같다. 이렇게 matrix factorization을 해서(인수분해해서) 우변과 같이 만들기는 쉽지 않다.\n여튼,이게 추천시스템에도 쓰이고, 여러 논문 주제에 쓰인다고 한다.\nstyle transfer 어떤 image가 주어질때, 특정한 style로 고흐, 피카소같은 style로 변경시킬 수가 있는데, 이때, matrix factorization이 사용된다.\n복습 개요 어떤 data가 주어지고, data로 부터 예측하는 machine을 만들어야 한다.\nperson ID Weight Height Is_Smoking Life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 3 55kg 6.0ft Yes(=1) 78 위와 같은 data가 주어지면, 주어진 data로부터 matrix equation을 만들 수 있다.\n\\(\\begin{bmatrix} 60 \\ 5.5 \\ 1 \\\\ 65 \\ 5.0 \\ 0 \\\\ 55 \\ 6.0 \\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\end{bmatrix}\\) = \\(\\begin{bmatrix} 66 \\\\ 74 \\\\ 78 \\end{bmatrix}\\)\nmatrix equation을 inverse matrix와 identity matrix를 사용해서 x벡터의 값을 구할 수 있다면, 우리는 data를 가지고 기계를 만들수 있게 된다. 만든 기계로 새로운 데이터에 적용을 해서 나온 값으로 예측을 하면 된다. 물론 여기에 한계는 있다고 했다. squared matrix에서만 inverse matrix와 identity matrix로 해를 구할 수 있고, rectangular matrix에서는 이 방법으로는 해를 구할수 없다는거\u0026hellip;또한 squared matrix라고 할지라도 해를 구할수 없는 경우가 있다는거\u0026hellip; 최종적으로 해가 있는지도 없는지도 계산으로 알기가 쉽지 않다. 그래서 이 방식은 안쓰인다고 봐도 되는 거 같다.\n따라서 강사는 윗 방법에는 관심이 없고, matrix의 곱을 linear combination으로 나타낼려고 한다. 그리고 나타낸 linear combination에서 다른 개념들을 적용시킬려고 한다.\n\\(\\begin{bmatrix} 60 \\\\ 65 \\\\ 55 \\end{bmatrix}\\) \\(x_{1}\\) + \\(\\begin{bmatrix} 5.5 \\\\ 5.0 \\\\ 6.0 \\end{bmatrix}\\) \\(x_{2}\\) + \\(\\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix}\\) \\(x_{3}\\) = \\(\\begin{bmatrix} 66 \\\\ 74 \\\\ 78 \\end{bmatrix}\\)\nlinear combination으로 나타내면 해가 있는지 없는지를 기하학적인 해석이 가능하다. linear combination으로 나타낸 3개의 column vector로 만들어지는 span에 결과 vector가 포함되면 해가 있는 것이고, 포함되지 않으면 해가 없다고 해석하는 것이다.\n즉, \\(\\begin{bmatrix} 66 \\\\ 74 \\\\ 78 \\end{bmatrix}\\) 이 span = \\(\\begin{Bmatrix} \\begin{bmatrix} 60 \\\\ 65 \\\\ 55 \\end{bmatrix}, \\begin{bmatrix} 5.5 \\\\ 5.0 \\\\ 6.0 \\end{bmatrix} , \\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix} \\end{Bmatrix}\\) 에 포함 여부가 해의 존재를 알려준다.\n만일 결과 vector가 span에 포함된다면, 거기서 해가 unique할 수도, 아니면 무수히 많을수도 있다. 만일 해가 unique하다면, 3개의 vector는 linear independent하다. 해가 무수히 많다면, 3개의 vector는 linear dependent하다.\n선형 독립(linear independence) 선형 독립과 선형 의존은 vector들간의 관계를 나타낸다. 어떤 vector 2개가 주어졌다고 가정하자. 여기서 span을 알아야 한다. 한 개의 vector는 선분이고, 그 vector의 span은 직선이라고 했다. 두개 vector의 span도 말할수 있다. 두개의 vector를 linear combinations들로 만들어지는 수많은 점들은 하나의 평면을 만들수 있는데, 그 평면이 두 vector의 span이 된다. span의 개념이 linear dependent와 linear independent의 속성을 나타내는데에 쓰인다.\n\\(\\begin{bmatrix} 1 \\\\ 0 \\\\ 2 \\end{bmatrix}\\) , \\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}\\)\n앞의 vector로 만들어지는 span에 뒤에 vector가 포함된다면, linear dependent하다. 반면에 앞 vector의 span에 뒤의 vector가 포함되지 않는다면, linear independent하다고 한다. 3개의 vector가 있는경우에도 똑같이 해석할 수 있다. 하나의 vector에 2개의 vector가 포함된다면 linear dependent하다. 두개의 vector의 linear combinations안에 마지막 vector가 포함되도 linear dependent한것이다. 여튼, 그런데 이것을 계산할 수 있을까? 첫번째 vector의 span을 모두 나열하고, 두번째 vector가 그 span에 포함하는지 안 하는지 계산할 수 있는가? 가우스 소거법으로 가능하다고 하는데, 강의에선 설명하지 않는다.\n그런데 이 모양을 보면, 지금껏 우리가 배워왔던 개념과 어떤 공통된 부분이 있다. 우리는 data를 사용해서, matrix곱으로 된 방정식을 만들었다. 그리고 matrix곱을 linear combination으로 만들었다. 좌변의 linear combination은 eigenvector와 가중치들의 곱의 합으로 되어 있었다. 그런데 좌변의 eigenvector들의 관계를 설명하기 위해서, 선형독립과 선형의존을 얘기하는 것같다. 이전에 matrix factorization에서도 큰 matrix를 linear combination으로 나타내면 엄청나게 많은 column곱으로 나타낼수 있지만 작은 matrix곱으로 표현되는 경우도 보았다. outer product에서도 matrix는 여러개의 column과 가중치가 아닌, 한개의 column vector와 row vector의 곱으로 나타낼 수 있었다. 즉 eigen vector가 적으면 적을수록 해가 있는지 없는지 판단하고, 해를 구하는데 있어서도 계산이 적어질 것이다. 여기서 선형독립과 선형의존은 linear combination으로 나타내지는 좌변의 eigenvector의 수를 줄이기 위한 처리과정으로 보인다. 즉 eigenvector가 2개 있을때, 2개 vector가 선형독립인지, 선형의존인지를 알게 된다면, eigenvector의 수는 줄어들 것이다.\n강사는 practical한 정의를 다음과 같이 내린다.\nGiven a set of vectors \\(v_{1}, \\ldots , v_{p} \\in R^{n}\\), check if \\(v_{j}\\) can be represented as a linear combination of the previous vectors \\(\\{ v_{1},v_{2},\\ldots, v_{j-1} \\}\\) for j=1,\u0026hellip;p\n위의 의미는 vector가 p개 주어질때, 선형 독립과, 선형 의존을 확인하기 위해선, 첫번째 vector에 대한 span에 두번째 vector가 포함되는지 여부를 확인한다. 포함이 되지 않는다면, 세번째 vector가 첫번째,두번째 vector의 span에 포함되는지 여부를 확인하는 작업을 p개까지 한다. p개까지 했을때, 모두 이전 span에 포함되지 않는 vector들이라면 각각은 선형독립이고, 만일 이전 vector들의 span에 포함되는게 하나라도 있다면, 선형 의존이 된다는 말이다.\n선형독립 formal한 정의 위에서, 선형 독립과, 선형의존의 의미를 얘기했었다. 2개의 vector가 있을때, 하나의 vector의 span안에 다른 vector가 포함된다면 선형 의존이라고 했고, 포함되지 않는다면 선형 독립이라고 했다. 선형종속과 선형독립은 span의 개념에 대한 이해가 필요했었다. 그런데 선형독립과 선형종속을 이해해야 하는 이유는 무엇인가? 선형종속과 독립을 말할수 있다면, matrix곱으로 표현된 방정식의 해를 직접 구할수는 없어도 해가 있는지 없는지 여부, 해가 있다면 unique한지 무수히 많은지를 알수 있다고 한다. 이런 개념적인 설명말고, 우리가 지금 알려고 하는것에 촛점을 맞춰보자.\nmatrix 곱에 대한 방정식은 linear combination을 사용한 방정식으로 바꿀수 있고, 그 방정식의 해가 있는지 여부는 span의 포함여부로 확인할 수 있다고 했다. 그런데 다음과 같은 경우를 생각해보자. 어떤 linear combination가 0 vector와 같다는 방정식이 있다고 하자.\n\\(\\begin{bmatrix} v_{1} \\ v_{2} \\ \\ldots \\ v_{3} \\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ \\vdots \\\\ x_{p} \\end{bmatrix}\\) = \\(\\begin{bmatrix} 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{bmatrix}\\)\n\\(x_{1}v_{1}\\) + \\(x_{2}v_{2}\\) \\(\\ldots\\) + \\(x_{p}v_{p} = 0\\)\n이 방정식의 해는 존재하는가? 반드시 존재한다. 해가 0벡터가 되면 식을 만족하기 때문이다. 즉 위방정식의 해는 최소 1개 이상 존재한다. x가 0벡터이면 최소 1개의 해가 존재한다.\n\\(x =\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ \\vdots \\\\ x_{p} \\end{bmatrix}\\) = \\(\\begin{bmatrix} 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{bmatrix}\\)\nunique하게 존재하는가? 만일 0벡터가 아니면서 윗식을 만족하는 vector가 존재한다면, 0벡터 말고 또 다른 해가 있다는 뜻이다. 이것을 선형 독립과 선형 종속의 개념으로 설명할 수 있다고 한다. 어떻게 설명할 수 있을것인가? 0벡터가 아닌 해가 있다고 가정한다.\n\\(x =\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ \\vdots \\\\ x_{p} \\end{bmatrix}\\) = \\(\\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ \\vdots \\\\ 3 \\\\ \\vdots\\\\0 \\end{bmatrix}\\)\n위와 같이 어떤 vector가 만족한다고 하자. 즉 해가 0벡터와 위 vector 2개의 해를 갖는다는 것이다. 그러면 저 해가 진짜 해인지 아닌지를 어떻게 판별할 것인가? 강사는 말한다. 저 해에서 0이 아닌값을 갖는 item이 30번째에 있고, 30번 이후로는 0값을 갖는다고 하자. 그러면 p가 100인경우에 원래 식이 바로 아래식으로 바뀐다.\n\\(x_{1}v_{1}\\) + \\(x_{2}v_{2}\\) \\(\\ldots\\) + \\(x_{100}v_{100} = 0\\)\n\\(x_{1}v_{1}\\) + \\(x_{2}v_{2}\\) \\(\\ldots\\) + \\(x_{30}v_{30} = 0\\)\n윗 식에서 \\(v_{30}\\) 만을 남겨둔 채 모두 이항한다.\n\\(v_{30} =\\) \\(-(x_{1}/x_{30})v_{1}\\) \\(-(x_{2}/x_{30})v_{2}\\) \\(\\ldots\\) \\(-(x_{29}/x_{30})v_{29}\\)\n그러면 \\(v_{30}\\) 은 \\(v_{1}\\) 부터 \\(v_{29}\\) 벡터들의 linear combination형태로 나타내지고 \\(v_{1}\\) 부터 \\(v_{29}\\) 의 span에 \\(v_{30}\\) 이 포함되면 선형독립이 되어 해가 존재하는게 된다.\nGeometric understanding of Linear Dependence Figure 1: geometric\n위 그림에서 보면 \\(x\\) 라는 vector가 있다. 그리고 \\(v_{1}\\) 과 \\(v_{2}\\) 라는 vector가 보인다. 우리가 \\(v_{1}\\) 과 \\(v_{2}\\) 의 계수를 어떻게 설정하면 x라는 점을 가리킬까? 가 해를 구하는 거라고 보면된다. 위에서 \\(v_{1}\\) 과 \\(v_{2}\\) 의 span은 하나의 plane영역을 뜻하기 때문에, 그 영역에 x가 있으면 해가 있다고도 말한다.\n근데 여기서 생각해봐야 할께 있다. 우리가 matrix곱에서 linear combination을 만들었는데, 2개의 vector가 좌변에 linear combination으로 있다고 하자. 위에서 말한 v1과 v2가 좌변에 있는것이다. 그리고 우변에 x라는 vector가 있다고 하자. 그러면, x라는 vector는 v1과 v2로 만들어지는 span에 포함되어 있는것이다. 즉 v1과 v2라는 linear combination으로 만들어진다. v1과 v2라는 eigenvector로 이루어진 평면에 x가 있기 때문에 해가 있다고 말하고, 그 해는 linear combination의 계수에 해당하는 2,3이 된다.\n그런데 만일 v3란 vector가 좌변에 있다고 하자. v3란 vector가 v1과 v2로 이루어진 평면에 속한 vector라고 하자. 즉 선형 종속된 경우다. 이럴경우, x라는 vector가 v1과 v2를 늘이거나 줄여서 평행 사변형으로 그 값이 정해질 수도 있지만, v1과 v3를 사용해서 그 값이 정해질 수도 있다. 예를 들면, v1=5, v2=0, v3=3, 또 v2와 v3로 표현될 수도 있다. v1=0, v2=20, v3=5 라고 하자.이것은 해를 나타내는 벡터가 (2,3,0)도 있을 수 있지만, (5,0,3),(0,20,5)라는 해를 가질수도 있다는 것이다. 어차피 좌변의 vector가 선형종속적이기 때문에 최소 하나의 eigenvector가 중복이 되는 것이다. 따라서 2개의 eigenvector로 나타내는 평면에 있기 때문에, x를 나타내는 평행사변형이 여러개가 될 수 있는 것이다.\n이제 선형독립을 생각해보자. 좌변의 linear combination을 이루는 v1,v2,v3가 선형독립이라면 x를 나타내는 육면체는 하나만 존재한다. 즉 해가 한개만 존재한다. linear combination의 좌변에 있는 vector가 선형 종속일때는 여러 평행사변형이 만들어져서 여러개의 해를 가졌다면, 선형독립인 경우 단 하나의 해를 갖는다.\nSubspace and Basis subspace란 개념의 정의는 닫혀진 linear combination의 subset을 말한다. span의 부분집합 정도로 이해하면 된다고 한다. subspace는 선형결합에 대해서 닫혀있다는 개념이 있다는게 특이하다.\nDefinition: A subspace H is defined as a subset of \\(R^{n}\\) closed under linear combination: 닫혀있다는, 집합에서 어떤 연산을 수행한 결과가 집합에 포함될 경우 닫혔다고 한다. 자연수에서 + 연산은 닫혀있다. -연산은 열려 있다.\n예를 들어보자. subspace는 우선 a subset of \\(R^{n}\\) 이다. 따라서, \\(R^{3}\\) 에서 하나의 subset을 생각해보자.\n\\(\\begin{Bmatrix} \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}, \\begin{bmatrix} 4 \\\\ 5 \\\\ 9 \\end{bmatrix} \\end{Bmatrix}\\) \\(\\in R^{3}\\)\n이 subset이 linear combination에 대해 닫혀 있는가? 여기서 두 vector를 더하면\n\\(\\begin{bmatrix} 5 \\\\ 7 \\\\ 12 \\end{bmatrix}\\) 는 위 subset에 포합되어 있지 않다.\n따라서, 닫혀있지 않다. 그래서 이것은 subspace는 아니다.\nspan의 경우는 항상 닫혀있다. 따라서 span은 subspace이다.\nBasis of a subspace Basis는 기저 벡터라고도 한다. subspace를 이루는 vector들의 집합을 말한다. subspace를 span이라고 봐도 된다고 했다. 왜냐하면, 어떤 vector가 주어졌을때, 그 주어진 vector의 linear combination해서 얻게 되는 vector들의 집합이 닫혀있기 위해선 span이여야 하기 때문이다. 또한 기저 vector들은 서로 선형 독립인 특징을 가져야 한다. 선형독립이라는 것은 기저벡터의 linear combinations에 다른 기저벡터가 포함되지 않는 경우를 말한다.\n예를 들어보자.\n\\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}\\) \\(x_{1}\\) + \\(\\begin{bmatrix} 4 \\\\ 5 \\\\ 6 \\end{bmatrix}\\) \\(x_{2}\\) + \\(\\begin{bmatrix} 5 \\\\ 7 \\\\ 9 \\end{bmatrix}\\) \\(x_{3}\\)\n어떤 linear combination의 위와 같을때, 여기의 basis는 무엇인가?\n\\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}\\) , \\(\\begin{bmatrix} 4 \\\\ 5 \\\\ 6 \\end{bmatrix}\\) 이다.\n왜냐하면,\n\\(\\begin{bmatrix} 5 \\\\ 7 \\\\ 9 \\end{bmatrix}\\) 는 \\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}\\) 과 \\(\\begin{bmatrix} 4 \\\\ 5 \\\\ 6 \\end{bmatrix}\\) 을 더해서 만들어지기 때문이다.\n즉 2개의 vector의 span에 포함되는 vector이다. basis는 2개 vector일 뿐이다.\n어떤 subspace가 주어진다면, 그 subspace는 하나의 직선으로 주어질수도 있고, 평면으로 주어지거나 육면체로도 주어질 수 있을 것이다. 여기서 basis를 찾을 수 있을것인가? 그리고 basis는 모두 unique한가?라는 질문을 할 수 있다.\nFigure 2: geometric 2\n예를 들어서 위의 그림을 보면 하나의 subspace가 주어졌다. 이 subspace를 span하는 basis는 unique한가?가 질문이다. 그 질문에 대해서 강사는 unique하지 않다고 한다. subspace에 포함되는 임의의 벡터 v1을 선택하고, v1과 다른 방향을 갖는 아무 벡터를 선택해도, 두 벡터를 span해서 subspace를 만들수 있기 때문에 unique하지 않다고 한다. 즉 여러개의 기저벡터가 있을수 있다. 다만, 중요한것은 subspace를 span하는 기저벡터의 개수는 정해져 있다고 한다. 어떤 basis를 사용하더라도 해당 subspace를 만들어내는(span)할 수 있는 기저벡터의 수는 정해져 있다고 한다. 이 정해진 subspace를 span하는 기저벡터의 개수를 dimension이라고 부른다.\nDimension of subspace 위에서도 얘기했듯이 subspan을 이루는 기저벡터는 정해져 있지 않다. 예를 들어 평면을 만드는 subspace의 기저벡터는\n\\(\\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}\\), \\(\\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix}\\) 이 될수도 있고, \\(\\begin{bmatrix} 4 \\\\ 8 \\end{bmatrix}\\), \\(\\begin{bmatrix} 8 \\\\ 4 \\end{bmatrix}\\) 이 될수도 있는 것이다.\n다만, 평면인 subspace를 span하는 기저벡터의 수는 2개다.라고 말할 수는 있다. 이 정해진 개수를 dimension이라고 부른다.\n우리가 3차원공간에서 가장 큰 subspace인 \\(R^{3}\\) 를 생각해보자. 이것이 subspace가 되려면, 조건이 있었다. linear combination에 대해서 닫혀있어야 한다. 그리고 기저벡터는 linear independence해야 한다.\n우선 \\(R^{3}\\) 가 subspace가 될 첫번째 조건을 살펴보자. linear combination에 대해 닫혀있다는 것은 어떤 vector가 \\(R^{3}\\) 에 속해 있다면, 기저벡터의 linear combination으로 나타낼 수 있다는 뜻이다. 기저벡터는 여러개가 있지만, 가장 간단한 것은 다음과 같은것이 있다.\n\\(\\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}\\) , \\(\\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\end{bmatrix}\\) , \\(\\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}\\)\n3차원 공간상의 모든 vector를 기저 벡터로 모두 표현(linear combination으로 표현) 할 수 있어야 subspace가 된다. 예를 들어보자.\n\\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 5 \\end{bmatrix}\\)\n위 vector는 기저벡터로 표현될 수 있다.\n\\(\\begin{bmatrix} 1 \\\\ 2 \\\\ 5 \\end{bmatrix}\\) = 1 \\(\\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}\\) + 2 \\(\\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\end{bmatrix}\\) + 5 \\(\\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}\\)\n따라서 subspace가 될 조건 linear combination에 대해서 닫혀있다는 만족한다.\n두 번째로, subspace의 기저벡터들이 linear independence해야 한다는것은, 기저벡터 중 어떤 하나의 span에도 다른 기저벡터가 포함되면 안된다. 위의 3개의 기저벡터들은 다른 span에 포함되지 않는다.\n\\(R^{3}\\) 에서의 basis와 마찬가지로 \\(R^{5}\\) 에서 basis도 동일한 기저벡터를 구할 수 있다.\n여기서 말할려는건, subspace와 span은 같다라는 것과 subspace를 이루는 기저벡터의 수는 정해져 있다는 것이다.\ncolumn space column space라는 용어가 있다. matrix가 있을때, matrix를 이루는 column들을 기저벡터로 하는 space를 생각할 수 있는데, 그것을 column space라고 부른다. A matrix의 column space는 Col A라고 쓴다. 예를 들어보면,\n\\(A = \\begin{bmatrix} 1 \\ 1 \\\\ 1 \\ 0 \\\\ 0 \\ 1 \\end{bmatrix}\\) =\u0026gt; col A = span \\(\\begin{Bmatrix} \\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\end{bmatrix} , \\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix} \\end{Bmatrix}\\)\n그런데, 우리가 data로 부터 machine을 만들때, matrix곱의 형태를 linear combination 형태로 변형했었다. 그리고 변형된 linear combination의 column들은 eigenvector로 생각하고, 그 eigenvector들이 선형 독립이라면, unique한 해가 한개 존재한다고 말했다. 우리가 linear combination형태로 변형하지 않아도, matrix곱형태에서 matrix의 column들이 eigenvector라고 말할 수도 있다. 그것을 용어로써 말한다면, col A, 즉 A matrix의 column space라고 말할수 있다. linear combination으로 모양을 바꾸기전에 column space를 말할수 있다는 것이다.\n여튼 위의 matrix를 볼때, A의 column space를 말할 수 있는데, column space는 span하고 똑같은 말이라고 했다. 그런데 단순히 어떤 matrix가 주어졌을때, column space라고 말하면서, matrix를 구성하는 column vector들을 eigenvector라고 하면서 span 표기법으로 나타낼 수 있는가? 안된다. span으로 나타낼려면, 그리고 span과 subspace가 동일하게 쓰일려면, 2가지 조건을 만족해야 했다. 첫번째, basis에 대한 선형독립인가? basis를 사용해서 만들어지는 span집합에 linear combination이 닫혀 있는가?이다. 두가지 조건이 만족하는지 살펴보자.\nA = span \\(\\begin{Bmatrix} \\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\end{bmatrix} , \\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix} \\end{Bmatrix}\\)\n위에서 두개의 vector는 같은 방향이 아니다. 따라서 선형독립이다. 같은 방향이라는것은 하나의 기저벡터에 실수배를 했을때 배율로 맞아떨어지면, 같은 방향이다. 위 두개 vector는 서로 방향이 다른 선형 독립인 vector들이다. 그리고 두개의 basis를 가지고 linear combination으로 만들어지는 vector들은 위 span에 포함될 것이다. 따라서 위와 같이 matrix가 주어질때, column space를 위와 같이 말해도 된다. 어떤 matrix가 주어질때, column space를 matrix의 column vector로 eigenvector로 하기 위해서는 두 vector가 선형독립이어야 위처럼 column space를 말할수 있다. 만일 matrix의 한 column vector가 다른 column vector의 실수배가 되거나, linear combination으로 나타낼 경우, 즉, 선형의존성이 있다면, column space는 의존하는 vector는 제외가 된다. 그런 예를 살펴보자.\n\\(A = \\begin{bmatrix} 1 \\ 1 \\ 2 \\\\ 1 \\ 0 \\ 1 \\\\ 0 \\ 1 \\ 1 \\end{bmatrix}\\) , 여기서 \\(\\begin{bmatrix} 2 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\end{bmatrix}\\) + \\(\\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix}\\)\n어떤 matrix A가 주어졌다고 하자. A의 column vector들을 가지고 무조건 아래처럼 column space로 만들수 없다.\nA = span \\(\\begin{Bmatrix} \\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\end{bmatrix} , \\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix}, \\begin{bmatrix} 2 \\\\ 1 \\\\ 1 \\end{bmatrix} \\end{Bmatrix}\\)\n위에서 봤듯이, A matrix의 마지막 column vector는 다른 2개의 column vector들의 linear combination으로 표현된다. 즉 선형 종속적인 vector이기 때문이다.\n\\(\\begin{bmatrix} 2 \\\\ 1 \\\\ 1 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\end{bmatrix}\\) + \\(\\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix}\\)\n따라서 A의 column space인 col A는 다음과 같다.\nA = span \\(\\begin{Bmatrix} \\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\end{bmatrix} , \\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix} \\end{Bmatrix}\\)\n여기서 dimension은 어떻게 되는가? dimension은 space, 즉 span과 관련한 용어다. 위와 같은 span이 있다면, span의 dimension은 basis의 개수라고 했다. 즉, eigenvector의 개수 이기 때문에 2가된다.\n그런데 궁금한것은 어떤 matrix가 주어졌을 때, 그것의 dimension 계산을 어떻게 하는가? 즉 linear independent한 vector의 개수를 어떻게 찾아 내는가? 그것에 대한 얘기는 하지 않는다. 다만, 어떤 matrix가 주어졌을때, 그 matrix가 10개의 column vector로 구성된다고 해도, dimension은 10보다 작을것이다. 라고 말 할수 있다는것만 얘기했다.\nRank of matrix matrix의 특징을 나타내는 개념중에 rank가 있다. rank는 matrix의 dimension을 얘기한다. 아래와 같이 나타낼 수 있다.\nrank A = dim col A\n어떤 matrix가 주어졌을 때, column space를 구하는데, column space는 matrix를 구성하는 column vector들이 선형독립의 특성을 갖는 column vector를 span하는 space라고 했고, dimension은 선형독립인 column vector의 개수라고 했기 때문에 위와 같은 식으로 나타낼 수 있다.\nRank의 개념은 matrix factorization과 outer product의 개념과도 연관 지을 수 있다. 예를 들어, 우리가 어떤 matrix가 주어지고 rank도 주어진다면 matrix를 factorization할 수 있다. 4개의 column을 가진 matrix가 rank가 2라면 우리는 2개의 column을 갖는 matrix와 2개의 row를 갖는 matrix곱으로 나타낼 수 있다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/linear_algebra_2_linear_independence\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/python_summary3_about_class\/": {
        "title": "python_summary3 about class",
        "tags": [],
        "content": "OOP programming class 기본 class 선언 예시 example\nclass Courier(object): # (object)는 생략가능 NATIONALITY = \u0026#39;KOR\u0026#39; # 클래스 속성 def __init__(self, name: str, address: str): # 생성자 self.name = name # attribute 초기화 self.address = address elf.parcels = [] def assign(self, parcel: str) -\u0026gt; None: self.parcels.append(parcel) def deliver(self) -\u0026gt; None: for parcel in self.parcels: print(parcel, \u0026#34;배달중\u0026#34;) class 특징들 class이름은 대문자. 상속은()를 사용한다. class attribute는 전역적으로 선언 class의 member attribtue는 init에서 self로 초기화. class 생성 example class Courier(object): # (object)는 생략가능 NATIONALITY = \u0026#39;KOR\u0026#39; # 클래스 속성 def __init__(self, name: str, address: str): # 생성자 self.name = name # attribute 초기화 self.address = address self.parcels = [] def assign(self, parcel: str) -\u0026gt; None: self.parcels.append(parcel) def deliver(self) -\u0026gt; None: for parcel in self.parcels: print(parcel, \u0026#34;배달중\u0026#34;) courier1 = Courier(\u0026#34;김기사\u0026#34;,\u0026#34;경기도 성남시 정자동\u0026#34;) print(courier1.name, \u0026#34;-\u0026#34;, courier1.address, \u0026#34;근무중\u0026#34;) courier1.assign(\u0026#34;편지\u0026#34;) courier1.deliver() class declaration class Courier(Object): class 이름은 CamelCase가 관습적으로 사용된다. 부모 class가 지정되지 않으면, object가 자동 상속된다. 그런데 object는 class가 아니라 객체라는것도 유의해야 한다. 모든 class는 object객체를 상속한다. Object class가 아니다. object객체에 있는 method를 built-in function이라고 부른다. class Attribute class Courier(Object): Nationality = \u0026#39;KOR\u0026#39; 속성은 2가지가 종류가 있다. class attribute와 member attribute. 둘다 객체가 갖는 속성이다. 하지만 여러 모로 다르다.\n우선 의미가 다르다. 붕어빵틀로 붕어빵을 찍어낼때, 붕어빵의 내용물은 붕어빵 객체마다 다를수 있다. 하지만, 붕어빵의 크기에 대한 속성은 모든 붕어빵 객체가 동일한 값을 갖는다. 생성하는 순서와 방식이 다르다. class를 python interpreter가 읽으면서 class객체를 만든다. 그때, class 객체의 attribute는 객체의 한 요소로 값이 만들어진다. 반면에 member attribute는 객체가 생성될때 init이라는 생성자에서 local하게 생성된다. python interpreter가 class로 쓰여진 부분을 읽어서 만들어지는 class객체에는 class변수에 해당하는 pointer와 function들에 대한 pointer들이 있을 뿐이다. python interpreter가 객체선언을 읽으면 그때 객체를 만들게 되는데, 그때는 init이라는 생성자를 호출 시켜서 member attribute를 생성하게 된다. 접근하는 방식이 다르다. class attribute는 class 자체 객체에 포함된 속성이라서 아래와 같이 사용한다. 반면에 member attribute는 객체를 만든 후에야 생성자에 의해 만들어진다. 그리고 그 이후에 객체.attribute로 사용될 수 있다. print Courier.Nationality class의 function들. class 내부에 있는 함수들이 있다. 이 함수들은 method라고 부른다. 이 method는 내부에 self라는 argument들을 가지고 있다. 이 self라는것은 객체를 의미한다. 예를들어서, python interpreter가 아래에서 보듯이 class Holy를 읽게 되면, Holy라는 이름의 class객체를 생성하고 method를 등록한다. Holy class 자체에서 method를 호출하려면, 첫번째 인자가 self라는 객체를 요구받는다. class자체객체를 전달할 순 없다. 즉 method를 사용하려면, 아래처럼 Holy class로부터 tempholy같은 객체를 만든다. 만들어진 객체에는 method들이 등록되어 있지는 않다. 객체에서 method를 호출하는것은 class객체에 등록된 method를 호출하는것이고, 그래서 첫번째 인자는 self로 되어 있는 것이다. self에는 tempholy가 인자로 들어가서 수행하는 것이다. tempholy객체에는 자신의 class에 대한 포인터가 등록되어 있기 때문에 class에 정의된 method들을 호출 할 수 있다. 다시 말하면, class는 class멤버변수와 method의 껍데기만 가진채로 생성이 되고, 객체가 만들어지면, 그 객체에는 class pointer가 있기 때문에, class의 class attribute와 method를 수행할 수 있는 것이다. class의 method를 수행하는 방식은 2가지가 있다. 하나는 class자체 객체에서 호출하는 것이다.\nclass Holy(object): class_var = \u0026#34;temp\u0026#34; def __init__(self, name: str): self.name = name print(\u0026#34;constructor\u0026#34;) def assign(self, newname:str) -\u0026gt; None: self.name = newname print(self.name,\u0026#34;assign method\u0026#34;) print(Holy.class_var) tempholy = Holy(\u0026#34;holy\u0026#34;) print(tempholy.assign(\u0026#34;park\u0026#34;)) print(Holy.assign(tempholy,\u0026#34;lee\u0026#34;)) 생성자(객체 속성) 객체를 생성할때 init()가 호출된다. init()는 class에 정의되어 있다. python에서 객체를 생성할 때는 무조건 =(asignment)를 사용한다. 이때 생성자의 모양에 따라 argument를 넣어 주어 생성한다.\ncourier1 = Courier(\u0026#34;김기사\u0026#34;, \u0026#34;경기도 성남시\u0026#34;) = 은 rvalue와 lvalue를 입력으로 받는다. rvalue의 type인 Courier가 courier1 객체에 들어가고, Courier의 method인 init()가 호출된다. 인자로는 \u0026ldquo;김기사\u0026rdquo;,\u0026ldquo;성남시\u0026quot;가 stack에 저장되고, Courier의 init()의 argument들은 function의 local변수이기 때문에 stack의 값으로 초기화된다. __init__함수에 보면, self는 courier1이 전달 되기 때문에, init()에 보면, self.name과 같은 식으로 객체를 만드는게 보인다. 이것은 courier1이라는 객체내에서 value값으로 만들어 지는 것이다. 따라서 courier1에서는 접근할수 있다. 그런데, 특이한게 있다. value는 생성자에 있는 member 변수가 아니다. java에서는 member변수가 아니라면, 객체에서 아래처럼 마음대로 member객체를 만들수가 없다. 그런데 python은 객체에서 member변수? member객체를 생성해서 사용할 수 있다.\ncourier1.value = 10 magic method: 생성자 initializer\ndunder method를 magic method라고 부르기도 한다. 즉 __로 시작하고 __로 끝나는 method를 뜻한다. init method도 dunder method다. 위에서도 이 init method에 대한 설명을 했는데, init method는 객체가 생성될때 호출된다. 예를 들면,\ncourier1 = Courier(\u0026#34;김기사\u0026#34;, \u0026#34;경기도 성남시\u0026#34;) 여기서 Courier class객체는 이미 만들어져 있다. class로 정의하면 생성이 되기 때문이다. 즉 이미 만들어진 type객체인 Courier의 init()를 호출하는 것으로 보면 된다. courier1은 인자로 전달되어 self로 assign되게 된다.\nmagic method: 소멸자\nclass Courier(object): def __del__(self): self.parcels.clear() 객체가 소멸할 때 호출된다고 한다. python에선 GC(Garbage Collection)을 가지고 있는데, 주기적으로 참조 되지 않는 객체를 삭제한다고 한다.\n객체지향의 3요소와 특성들 상속 inheritance class Courier(object): object는 부모 class, Courier는 자식 class가 된다.\n다형성 polymorphism 같은 이름의 method를 다르게 작성. 다중 상속이 가능하다고 한다. 그리고 super를 통해서 상위 class에 대한 접근이 가능하다. 이것이 polymorphism과 큰 관련이 있는지는 모르겠다. super를 사용하는 예제를 보여준다.\nclass Courier: def __init__(self, name:str): print(self) self.name = name print(\u0026#34;courier 생성자\u0026#34;) self.address = \u0026#34;부산\u0026#34; self.parcels = [] def assign(self, parcel: str) -\u0026gt; None: self.parcels.append(parcel) def deliver(self) -\u0026gt; None: for parcel in self.parcels: print(parcel, \u0026#34;super 배달중 -\u0026#34;, self.address) class JejuCourier(Courier): def __init__(self, name: str, ticket: int): print(\u0026#34;생성자juju\u0026#34;) # super().__init__(name) super(name) self.ticket = ticket def deliver(self) -\u0026gt; None: print(self.ticket, \u0026#34;티켓으로 제주도 이동\u0026#34;) super().deliver() # courier = JejuCourier(\u0026#34;김기사\u0026#34;, 15) JejuCourier(\u0026#34;김기사\u0026#34;, 15) # courier.assign(\u0026#34;편지\u0026#34;) # courier.deliver() # super(JejuCourier, courier).deliver() python은 모든 게 객체이기 때문에, class도 객체다. 그리고, class로부터 만들어지는 instance도 객체다. 각각의 객체엔 type(class)이란 항목이 있다. type(class)이란 항목엔 instance를 만든 class 객체를 가리키고 있다. 예를 들어서, A라는 class가 있고, a라는 instance가 있다면, A class도 객체가 있고, a도 객체 인 것이다. 객체인 A class와 a에는 객체이기 때문에 type(class)이란 항목이 존재한다. a객체의 type(class)에는 A class객체를 가리킨다. 그러면 A class객체의 type(class)이란 항목은 무엇을 가리키고 있을까? A class 그자체도 객체이기 때문에, class의 부모 class를 type(class)으로 가리키고 있을 것이다.\n위에서 type에 대해 설명한 것은 super()를 설명하기 위함이다. 우선 super는 내부적으로는 class로 정의되어 있다. init()만 가지고 있는 class다. super()는 type의 class의 init()를 호출하여 객체를 만든다. 소스를 보면서 설명해보자.\npython interpreter는 Courier, JejuCourier라는 class 정의를 보고, class 객체를 만든다. class 객체엔 name이란 항목, type이란 항목, value라는 항목이 설정된다. name에는 class의 이름이 들어가고, type에는 Courier의 경우는 object, JejuCourier에는 Courier가 들어간다. value에는 body부분이 들어가게 된다. class객체를 만들때, body부분은 실행하지 않는다. 즉 body에선 수많은 객체 생성을 할텐데, class객체는 body 전체만 가리키는 포인터만 가질뿐이다. class객체로 부터 instance객체를 만들고 instance 객체에서 body부분을 실행할 때 처리되는 것이다.\npython interpreter는 아래를 읽고 실행한다.\ncourier = JejuCourier(\u0026#34;김기사\u0026#34;, 15) = 은 객체를 만드는 명령어다. 객체를 만들고, name은 courier로 지정하고. type은 JejuCourier로 한느 객체를 만든다. 그리고 JejuCourier라는 class객체의 __init__함수를 호출한다. 인자는 지금 만든 courier객체, \u0026ldquo;김기사\u0026rdquo;, 15값을 stack 넣어 전달한다. courier라는 객체는 단순하다. 왜냐면, courier객체는 JejuCourier를 type으로 갖기 때문에 JejuCourier의 method를 그대로 상속해서 사용한다. type이라는 것은 부모 class로 보면 되기 때문이다.\n[JejuCourier의 __init__함수]\ndef __init__(self, name: str, ticket: int): print(\u0026#34;생성자juju\u0026#34;) super() super().__init__(name) self.ticket = ticket print문을 출력하고, super()라는 부분이 나온다. self는 courier라는 객체를 나타낸다면, super()는 현재 수행되는 class객체인 JejuCourier객체의 type, 즉 부모 class를 생성하는 것이다. 부모 class의 __init__을 호출해서 부모의 class의 instance객체를 만든다. 물론 그전에 부모 class객체는 만들어져 있는 상황이다. 예를 들어, JejuCourier()를 호출한다면, JejuCourier class객체는 이미 만들어져 있고, JejuCourier class객체의 init()를 호출해서 instance객체를 name없이 만드는것과 같다. 즉 저기서 super()는 부모인 Courier의 _init__메소드를 호출해서 instance객체를 만드는 것이다. 그런데 super()를 실행하면, Courier의 init()이 일치하는게 없다. Courier의 init(self, name:str)의 형태이기 때문에, 부모인 object의 init()가 호출될 것이다. Courier의 init(self, name :str)을 호출하기 위해서는 명시적으로 호출해야 한다. 즉, super()._init(name)으로 호출해야 한다. 그런데 여기서 질문, Courier의 init메소드의 인자 self는 무엇으로 초기화 되는가? 그리고 만일 super(name)으로 Courier의 _init__을 호출 할 수 있는가? 어떻게 self가 초기화 되는가? 자식객체가 type의 method를 호출할때는 자기자신이 인자로 전달된다. 그러면 super(name)도, super()._init(name)이 수행되듯이 수행되어야 할 것이다. 그런데 수행되지 않는다. 이것은 정말 이상한데, super라는게 부모 class를 가리키고, super()를 하면 instance를 만들고 인자 없는 init()을 호출하는 과정이다. super(name)하면, 부모 class에대한 instance를 만들고, init(self, name:str)을 호출해야 맞는데 호출 되지 않는다. super()는 Courier()를 실행하고, 그다음 init()를 호출하는건, JejuCourier()를 실행했을 때, JejuCourier instance를 만든후 __init__메소드를 수행하는것과 동일한데, 이상하게 안된다.\n그리고, 맨 마지막의 실행문을 보자.\nsuper(JejuCourier, courier).deliver() 이것은 어떻게 해석 할 것인가? 이전의 super()는 특정 객체의 method에 있었다. 즉 특정 객체의 method가 호출되어 실행되기 때문에 그 context에서는 super가 가르키는게 특정 class객체임을 알 수 있었다. 하지만, 여기서 super는 어떤 class객체를 가리키는가? 이게 module하고 관련있는것 같다. 즉 class내가 아닌 밖에서 사용되는 function도 module하고 어떤 관계가 있어 보인다.여기서는 별 다른 설명이 없다.\noverloading과 overriding overloading과 overriding은 모두 부모와 같은 이름의 함수를 뜻한다. overloading은 argument가 다른 함수다. 즉 다른 함수라고 봐도 된다. 하지만, overriding은 동일한 함수를 재정의 하는것이다. 단어만 보면 overwrite하고 비슷하다. 위 코드에서 보면, deliver는 overriding한것이고 __init__은 overloading한 함수다.\nstatic \u0026amp; class method 우선 예제를 보자.\nclass Number: Constant = 10 @staticmethod def static_factory(): obj = Number() obj.value = Number.Constant return obj @classmethod def class_factory(cls): obj = cls() obj.value = cls.Constant return obj number_static = Number.static_factory() number_class = Number.class_factory() print(number_static.value, number_class.value) staticmethod와 classmethod는 이름만 봐선, 우선 class method는 class객체에 포함되는 method고, static method는 일종의 전역함수로 봐도 되지 않을까? 일반 method는 self라는 argument가 있었다. 하지만, class method와 static method에는 self가 있을 필요가 없다.\n사용방법을 보면, 둘다 다음과 같이 호출한다.\nnumber_static = Number.static_factory() number_class = Number.class_factory() static method는 선언만 class안에 선언되었을 뿐이지, 밖에 선언되어도 상관없을 method다. 하지만, python에선 모든것은 객체고 method이기 때문에 안에서 선언되고 접근만 가능할 뿐이여서 class에 포함된 method라고 보기 힘들다. 여튼 코드 해석을 해보자.\npython interpreter는 Number라는 class를 읽고 Number class객체를 만든다. 그리고 다음 code를 실행한다.\nnumber_static = Number.static_factory() = 은 객체를 만든다. number_static이란 name을 갖고, Number.static_factory()함수를 호출 결과의 type과 value를 가질 것이다. static_factory()는 외부 함수로 봐도 된다. 여튼 여기서는 Number의 instance를 만들어서, return한다. 따라서 Number라는 type이 지정되는 객체가 만들어진다.\n두번 째로, 다음 코드를 보자.\nnumber_class = Number.class_factory() 여기서는 Number의 instance를 만들지는 않는다. 제일 처음에 python interpreter가 Number라는 class객체를 만들었기 때문에, Number class객체의 class method인 class_factory()를 접근한다.\n@classmethod def class_factory(cls): obj = cls() obj.value = cls.Constant return obj 여기서 눈여겨 봐야 할것은 cls이다. 우리가 객체를 생성해서 객체에서 method를 호출할 때는 객체.method() 형태로 method를 호출한다. 이 때, method는 class객체에 있기 때문에, 객체가 인자로 넘어가서 실행된다. 근데 여기서는 class method는 class에 정의되어 있다. 그리고 class객체 자기자신이 인자로 넘어간다는게 좀 다르다. cls는 Number class객체의 이름이 넘어간다. 그리고 그 이름으로 Number instance를 만들어서 return하는 구조다.\n위의 두 함수 모두, class의 instance를 만들고, instance의 method를 호출하는 방식과는 다르다. instance는 내부적으로 만들어져 return 하는 형태다. factory design pattern을 사용하기 때문이다.\n또 한가지 static method와 class method 모두 decoration을 사용하고 class객체에서 호출 가능하다는 공통점이 있지만, 둘 사이의 커다란 차이점은, class method는 상속이 되지만, static method는 상속이 되지 않는다는 것이다.\nAbstraction (visiblity) Abstraction으로 알고 있던 용어를 여기서는 visiblity라고 부른다. 다른 class에서 객체 내부 요소를 감추는 캡슐화 작업이라고 한다. java에서 private이나 protected로 설정했던거라고 보면 된다. 즉 내가 김기사라는 instance를 만들었을때, instance라고 해서 자신의 member attribute를 다 접근할 수 없게 만들었다. class에서 정의된 방식으로만 접근할 수 있게 할 수 있는데, 예를들면, set과 get이라는 method에서만 직접적 처리가 가능하게 했다. instance는 이 method를 호출해서 해당 변수에 접근이 가능하다. 이것을 capsule화라고 한다. java에서는 private과 protected라는 keyword로 제공했지만, python에서는 private이나 protected라는 keyword는 없다고 한다. 다만, __로 시작하면 private이라고 하고, _라고 하면 protected라고 일종의 규약처럼 사용되는데, 문법적 요소는 없다고 한다.\n예를 들어 보자.\nclass TestClass(object): def __init__(self): self.attr = 1 self._attr = 2 self.__attr =3 instance = TestClass() print(dir(instance)) print(instance.attr) print(instance._attr) # print(instance.__attr) dir은 instance가 가진 모든 attribute를 보여준다고 한다. 여기보면, _attr과 attr은 보이지만, __attr은 보이지 않는다. 강사는 mangling이 적용되었다고 말한다. mangling은 __가 앞에 붙어 있으면 이름이 _TestClass__attr로 변경된다. mangling이 되면, 객체에서 직접적으로 접근할 수 없게 된다. 즉, private한 효과가 있다. 위에서 직접 접근을 시도했지만, 에러가 발생되는 것을 볼 수 있다. 굳이 접근할려고 하면, instance._TestClass__attr로 접근할 수 있다. mangling된 이름으로 접근하면 된다. protected는 별다른 처리를 하진 않는다. 여기서 __로 시작하는것을 dunder method나 magic method로 보면 안된다. dunder method는 __로 시작하고 __로 끝날때만을 의미한다. __는 attribute와 function에 적용되고 mangling하는 특징을 갖는다.\nabstraction (visibility2) java같은 oop언어에서는 private을 사용하고, setter, getter 메소드를 정의해서 사용하는 경우가 많다. python에서는 명시적인 private과 protected keyword를 제공하지 않는다고 했다. 어떻게 보면, python에서는 기존의 oop언어가 member variable을 private으로 감추고, setter와 getter를 사용하는것이 쓸모 없다고 생각했을 수도 있다. 그래서 그냥 member variable에 값을 넣고 꺼내면 되지 않냐? 이런식의 주장을 하는 것 같기도 한다. 그렇지만, 직접적으로 그렇게 사용하진 않는다. python도 java처럼 setter와 getter를 사용한다. 하지만, 마치 직접 변수를 접근하는 것처럼 눈속임을 한다. 이때 사용되는게 @property와 @name.setter를 사용한다. 이것을 사용하면, python이 원래 의도했던, 마치 instance에서 setter getter라는 method도움없이 직접 입력하는 것과 같은 착시효과를 준다.\n예를 들어보자.\nclass Circle(object): PI = 3.141592 def __init__(self, radius=3.): self.radius = radius def get_area(self): return Circle.PI * self.radius ** 2 def set_area(self, value): self.radius = (value / Circle.PI) ** .5 circle = Circle(5.) print(circle.get_area()) circle.set_area(10) print(circle.radius) 위에는 일반적으로 coding할 때의 예다. radius라는 attribute가 있고, get_area, set_area함수에서 해당 radius에 접근해서 area계산값을 return한다. 그리고 instance에서 radius값을 직접 출력해 보기도 한다. 만일 radius가 private하다면, 아래의\nprint(circle.radius) 는 수행 될 수 없다. get함수를 써야, OOP의 개념을 살린 coding이라고 말할 수 있을것이다. 그런데 python에는 애초부터 private한 keyword가 없기 때문에 굳이 get함수를 사용할 필요는 없다. 다만 oop형태로 set과 get method를 만들지만, 직접 사용하는 것처럼 만들 수 있다. 아래의 예를 보자.\nclass Circle(object): PI = 3.141592 def __init__(self, radius = 3.): self.radius = radius @property def area(self): return Circle.PI * self.radius **2 @area.setter def area(self,value): self.radius = (value /Circle.PI) ** .5 circle = Circle(5.) print(circle.area) circle.area = 10. print(circle.radius) 여기에서 보면, @property와 @name.setter라는 decorator가 추가되었다. 이것은 setter, getter method를 마치 변수처럼 만들어준다. @property를 해주면, method가 변수처럼 되어 버린다. 위의 예에서는 마치 getter럼 정의된 area란 method에 @property가 있다. 따라서 아래와 같이 출력이 가능하다.\nprint(circle.area) area가 변수처럼 보이지만, area는 함수다. @property처럼 보여라하는 decorator가 붙어서 property처럼 처리한다.\n다음은 setter method처럼 정의된 함수에 decorator를 붙였다.\n@area.setter def area(self,value): self.radius = (value /Circle.PI) ** .5 그리고 다음과 같이 사용한다.\ncircle.area = 10. 보기에는 area변수에 10.0을 assign한것 처럼 보이지만, 실은 area라는 함수다.\nmagic method (dunder method) 파이썬에는 magic method를 많이 제공한다. 위에서 봤듯이 magic method는 __를 prefix와 postfix에 사용한다. 그리고 대부분이 object 객체에 있는 함수들이다. 이것은 built-in function들로 불린다.\nindexing method\nclass DoubleMapper: def __init__(self): self.mapping = {} def __getitem__(self, index): return self.mapping.get(index, index * 2) def __setitem__(self, index, item): self.mapping[index] = item mapper = DoubleMapper() print(mapper[10], mapper[1,2]) mapper[10] = 15 print(mapper[10], mapper[1,2]) [ ] 를 재정의 한 코드라고 강사는 말한다. __getitem__과 __setitem__을 class에 정의하게 된다면,\nmapper[10] = 5 이런 statement의 경우 __setitem__이 호출되고,\na = mapper[20] 이런 statement의 경우 __getitem__이 호출 된다고 한다. 이제 코드를 분석해 보자.\nprint(mapper[10], mapper[1,2]) 여기서, mapper[10]과 mapper[1,2]는 __getitem__을 호출한다. 처음은 10이라는 값을 넘기고, 두번째는 (1,2)라는 tuple값을 넘기는 것이다. 두 번째의 경우가 좀 이해하기 힘들긴 하다. 여튼 저런 값은 tuple값으로 생각하면 된다.\ndef __getitem__(self, index): return self.mapping.get(index, index * 2) 첫번째는 10이란 index를 __getitem__에 넘겼다. 여기서 get이란 함수가 좀 특이한데, 만일 index값이 없다면, 2를 곱해서 return한다는 뜻이다. 10이란 index에 값이 없기때문에, 20일 return된다. 마찬가지로 (1,2)라는 index가 존재하지 않기 때문에 2를 곱해서 (1,2,1,2)를 return한다고 한다. 즉 이제는 index가 10이거나 (1,2)에 대해선 값이 존재한다.\n이제 __setitem__을 수행하는 코드를 보자.\nmapper[10] = 15 이 코드는 class의 __setitem__을 호출한다.\ndef __setitem__(self, index, item): self.mapping[index] = item mapper객체의 index가 10인 값은 15로 저장되게 된다. 이렇게 해서 mapper객체의 값들은 {10:15, (1,2):(1,2,1,2)} 이렇게 유지된다.\n이렇게 setitem__과 __getitem__을 사용한다면, index관련한 처리를 재정의가 가능하다. dictionary와 tuple array, list같은 index를 사용한 연산에서 index의 기능을 재정의하는게 가능하다. 위에서도 index를 사용해서 값을 return받거나, index에 값을 삽입하는 것을 __getitem, __setitem__을 재정의하면 해당 method가 호출되는 것을 볼 수 있다.\n이런 형태가 pandas나 tensorflow에서 많이 보이는데, 안에 구조를 보면 setitem과 getitem을 재정의해서 사용하는 경우가 많다고 한다. tensor class가 이런 형태라고 한다.\nlength method\n예제를 먼저 보자.\nclass Dataset: def __init__(self, data, times =3): self.data = data self.times = times def __len__(self): return len(self.data) * self.times def __getitem__(self, index): if index \u0026gt; len(self): raise IndexError() return self.data[index % len(self.data)] dataset = Dataset([10,2,5,2], times=5) print(len(dataset)) 코드를 분석하자.\ndataset = Dataset([10,2,5,2], times=5) 이 부분은 dataset이라는 객체를 만든 것이다.\nprint(len(dataset)) 여기서, len(dataset) 이 부분이 해석하기가 좀 어려운데, dataset._len_()이 아니라 len(dataset)의 형태이기 때문이다. 두개가 형태만 다를뿐 동일한 것같다. 여튼, dunder method의 경우, len(dataset)형태로 많이 사용되어진다는 게 특이하다. 그리고 len(dataset)은 Dataset class의 len()를 호출한다고 보면 된다. 그리고 object 객체에 미리 정의되어 있다.\ngetitem()는 dataset[2], dataset[10] 처럼 index를 사용해서 값을 가져오는 명령에서는 __getitem__이 정의되어 있다면 호출된다. 연산자 재정의와 유사하다고 했다. code를 보면 다음과 같이 되어 있다.\ndef __getitem__(self, index): if index \u0026gt; len(self): raise IndexError() return self.data[index % len(self.data)] pass받은 index값이 원래 dataset이 가진 객체의 len()보다 작다면 에러가 나는데, len()는 객체가 가진 data의 길이다. 즉 index가 가진 data보다 큰 값으로 접근하면 에러가 발생된다는 얘기다.\ntyping magic method\nclass Courier: def __init__(self, name: str, address: str): self.name = name self.address = address def __str__(self): return self.address + \u0026#39;담당\u0026#39; + self.name courier = Courier(\u0026#34;김기사\u0026#34;, \u0026#34;경기도 성남\u0026#34;) text = str(courier) print(courier) 여기서도, str(courier)과 같은 형태가 나온다. courier.str()의 형태가 아니다. 이것은 object에 정의된 dunder method라고 바로 추측한다. 물론 위에선 재정의한 것이다. object에서 dunder method로 정의하는덴 그만한 이유가 있다. str이다. str은 int float와 같은 type이다. str(courier)라는 형태는 좀 이상해 보이지 않는가? 보통은 형변환시 사용되는 방법이다. str클래스가 있고, 생성자에 객체를 전달해서 str객체로 형변환한다고 생각한다. 또다른 예로, int객체 3이 str생성자에 전달되어 str(3)은 str 객체로 변환된다고 생각한다. 하지만, 이것은 int 클래스에 정의된 str dunder method의 호출이다. python에선 그렇다. int라는 class에 str__메소드가 정의되어 있는것이다. 우리가 형변환이라고 부르는 int(courier)이나, float(courier), bool(courier) 모두 class의 dunder method로 정의되어 있다는 것이다. __str dunder method를 정의해서 편리하게 쓰는 경우는 객체를 print할 때다. __str__메소드가 리턴하는 값이 출력된다.\ncomparison operator magic method\nclass Courier: def __init__(self, name: str, cid: int): self.name = name self.cid = cid def __lt__(self, other): return self.cid \u0026lt; other.cid couriers = [ Courier(\u0026#34;김기사\u0026#34;, 56), Courier(\u0026#34;박기사\u0026#34;, 72), Courier(\u0026#34;정기사\u0026#34;, 62) ] print(dir(Courier)) print(*[courier.name for courier in sorted(couriers)]) 여기서 눈여겨 볼 것은 list comprehension에서 sorted(couriers) 문장이다.\nprint(*[courier.name for courier in sorted(couriers)]) 이전에도 보았듯이 couriers.sorted()의 객체 method가 아닌, sorted(couriers)형태가 나온다. 이것은 sorted가 dunder method임을 말하고, class에 정의되어 있다. couriers객체의 type은 list이다. 즉 list에 sorted__()가 정의 되어 있을 것이다. sorted()의 내부 동작은 정확히 모르지만, 객체들의 lt()를 사용해서 크기 비교를 하는것 같다. 예를 들면, a \u0026lt; b, a\u0026gt; c, 혹은 if a == b 와 같이 많은 비교를 할 것이다. sorted가 아니더라도, 객체를 비교하는 연산을 사용하는 경우는 많다. 이때, class에서 lt()를 정의하고 있다면, a \u0026lt; b라는 일견 평범한 연산은, a._lt_(b)로 해석될 수 있는 것이다. 즉 python에서는 모든 것은 객체고, 모든 operator는 method이기 때문이다. 마찬가지로 __le, gq, ge, __ne__등 많은 것이 존재한다.\n연산자 재정의에 대해서.\n1\u0026gt;2, 1\u0026lt;3, 1 ==3 같은 logic operator ||, \u0026amp;\u0026amp;, ! 같은 관계연산자. +, , / ,*, % 같은 arithematic operator = assign operator len함수 같은것들. 이런 연산자들은 3\u0026gt;4, 1+4, a ** b 이런식으로 사용하는게 너무나 자연스럽게 생각하지만, 객체지향 언어에선 당연하다거나 자연스럽다고 생각하면 안된다. 왜냐하면, 객체 지향언어에서는 객체.method의 형태로 함수나 operator를 사용하지, 수학이나 c언어에서 사용하듯이 사용하는 저 방식은 매우 낯선것이기 때문이다. python에선 모든것은 객체고 모든 function은 method이다. 따라서 저 operators들은 class에 정의된 method이다. 우리가 class를 만들때마다 저런 operator를 모두 method로 만들어줘야 한다. 근데, Object에 이미 만들어져 있기 때문에, 자동으로 상속된다. 우리가 만든 dunder method는 모두 재정의한 것이다. overloading을 했던가 혹은 overriding을 한것이다.\n근데 한가지 궁금한 게 생겼다. 위에서 설명한 dunder method들, len, comparison 연산자들은 모두 객체에서 정의된 그대로 호출 할수 있었다.\na.__len__() 그런데 실제 사용할 때는\nlen(a) 와 같이 사용한다. 어떻게 해서 이렇게 사용할 수 있는것인가? 그리고, 위의 경우는 이름이 비슷하기라도 하다. 전혀 다른것들이 있다. 아래를 보면 \u0026lt; 심볼은 실제 lt()를 호출 한다. 이것은 어떻게 가능한 것인가? 여기에도 mangling이 되는 것인가? 그렇지는 않다. 왜냐면 dunder method는 직접 호출이 가능하기 때문이다.\na \u0026lt; b def __lt__(self,...): self.a \u0026lt; other.a 또 재밌는건, lt() method로 선언한 내부에는 \u0026lt;,\u0026gt;와같은 기호를 그대로 쓴다는 것이다. 그럴바에는 lt()를 만들 필요가 있었는지 모르겠다. 사용할때도 \u0026lt;,\u0026gt;같은 기호를 쓰고, 내부적으로도 사용한다면, 굳이 __lt__라는 이름뿐인 함수를 왜 정의하는지 모르겠다.\narithmetic operator : magic method\nclass MyComplex: def __init__(self, real, imaginary): self.real = real self.imaginary = imaginary def __str__(self): return str(self.real) + \u0026#39;+\u0026#39; + str(self.imaginary) + \u0026#39;j\u0026#39; def __add__(self, other): return MyComplex( self.real + other.real, self.imaginary + other.imaginary ) a = MyComplex(3, -5) b = MyComplex(-6,7) print(a + b) 어떤 class를 만들었을때, class로 만든 instance가 + 연산을 할 수 있게 하려면, class에 add()가 있어야 한다. 물론 object에도 정의되어 있다. overloading이나 overriding으로 재정의할려면 위와같이 add()를 재정의한다. str()도 재정의해서 print문에 사용할 수 있다. sub(), mul()도 존재한다.\niadd()도 존재한다. 이것은 = 을 사용해서 객체를 만드는 대신 +=을 사용해서 객체를 새롭게 생성하지 않는다고 한다. 왜냐면, +=는 연산자이기 때문이다.\nCallable : magic method\nclass AdditionNumber(object): def __init__(self, number: int): self.number = number def __call__(self, number: int): return number + self.number addition_5 = AdditionNumber(5) print(addition_5(10)) 이건 또 뭐야? 할정도로 이상한 모양이다.\nprint(addition_5(10)) addtion_5는 instance다. AdditionNumber(5)로 부터 만들어진 instance다. 그런데 instance에 (10)을 붙였다. 이것은 syntax error가 날 만도 하다. 근데 정상 동작이 된다. 어떤 이유에서일까? addition5자체는 instance객체의 이름이다. ()는 call method를 의미한다고 한다. object객체에 정의된 built-in function이기도 하다. 따라서, addition5._call_(10)을 addition5(10)으로 사용한다는 건데 그러면, ()와 __call__간의 mapping은 어디에 정의 되어 있는가?\nfor : magic method iterable\nseq = [1,2,3,4,5] for elem in seq: print(elem) 위와 같은 for문은 다음과 같은 형태라고 한다.\nseq = list([1,2,3,4,5]) iterable = iter(seq) while True: try: elem = next(iterable) except StopIteration: break print(elem) python에서 for문은 다른언어와 다르게 iterable객체에서 값을 가져와서 처리하게 되어있다. 즉 유한한 값을 반복한다. 그래서 구조도 좀 다르다. for in이 같이 쓰인다. in 다음에는 collection이 들어가는데, 이 collection은 iter()를 사용해서 iterable객체가 된다. iterable객체에는 start,end, cur이라는 내부변수가 있다. next()가 있어서 cur이 가리키는 값을 return한다. return한 값은 변수와 binding되고, 다음 명령어가 수행된다.\ncontext manager: magic method\nclass Courier: def __init__(self,name: str): self.name = name def __enter__(self): self.parcels = [] return self def __exit__(self,exec_type,exec_value, trace): for parcel in self.parcels: print(parcel, \u0026#34;배달 실패\u0026#34;) # parcel.clear() courier = Courier(\u0026#34;김기사\u0026#34;) with courier: courier.parcels.append(\u0026#34;소포\u0026#34;) with courier as c: c.parcels.append(\u0026#34;소포\u0026#34;) with로 시작되는 구문이 있다. 생소하다. as도 생소하다. 우선 with 다음에는 객체가 온다. 그리고 block이 정해진다. 해당 객체가 block에서 사용될때, class의 enter()가 실행되고, block을 빠져나올때, exit가 수행된다. as는 객체의 이름을 block에서 c라고 사용하겠다는 뜻이다. exit는 error나 exception이 발생되도 실행이 되게 되어 있다. 그래서 error의 정보를 나타내기 위해서 exec_type, exc_value같은 인수를 제공한다.\nwith as가 가장 많이 사용되는 경우는,\nwith fopen(\u0026#34;test.txt\u0026#34;) as fd 과 같이 file을 열때, context를 유지해야할 때 많이 사용한다고 한다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary3_about_class\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/python_summary5_loop\/": {
        "title": "python_summary5 loop",
        "tags": [],
        "content": "Condition \u0026amp; Loop 조건문은 if else, 반복문은 while-for 들여 쓰기: space 4칸, tab을 써도 된다. Conditional Statement if문 사용법1 - if,elif,else 사용법 if를 사용해서 원하는 조건을 만족하면 수행하게 한다.\nexample 1\nscore = 80 if score \u0026gt; 60: print (\u0026#34;Over 60\u0026#34;) if score \u0026gt; 70: print(\u0026#34;Over 70\u0026#34;) if score \u0026gt; 80: print(\u0026#34;Over 80\u0026#34;) 위에서 보듯이 조건에 맞으면, 출력을 한다. example 2\nexample1에서 보면, 3가지 case가 있다. 이 중에 맞는 경우가 2가지가 있다. 이럴 때, 만족하는 모든 case를 출력하지 않고 하나를 만족하면 수행을 하지 않게 하고 싶다면, elif를 사용한다. score = 80 if score \u0026gt; 60: print (\u0026#34;Over 60\u0026#34;) elif score \u0026gt; 70: print(\u0026#34;Over 70\u0026#34;) elif score \u0026gt; 80: print(\u0026#34;Over 80\u0026#34;) example 3\n만일 모든 조건을 만족하지 않을 때, 조건을 만족하지 않습니다.라는 메시지를 내보낼려면 어떻게 해야 하는가? 이 때, else를 사용한다. score = 10 if score \u0026gt; 60: print (\u0026#34;Over 60\u0026#34;) elif score \u0026gt; 70: print(\u0026#34;Over 70\u0026#34;) elif score \u0026gt; 80: print(\u0026#34;Over 80\u0026#34;) else: print(\u0026#34;wrong value\u0026#34;) if문 사용법2 - false에 해당하는 것들 false에 해당하는 값들. if False: print(\u0026#34;This sentence does not show\u0026#34;) if \u0026#34;\u0026#34;: print(\u0026#34;Empty is False\u0026#34;) if 0: print(\u0026#34;0 is False\u0026#34;) if None: print(\u0026#34;None is also False\u0026#34;) if문 사용법3 - 비교연산자와 논리연산자의 사용 example\na,b = 5,8 if a == 5 and b ==6: print (\u0026#34;This is False\u0026#34;) if not a \u0026lt; b \u0026lt; 9: print(\u0026#34;This is False\u0026#34;) if a + 3 == b: print(\u0026#34;This is True\u0026#34;) 여기서, a,b = 5,8을 보는 순간, tuple의 unpacking임에 익숙해 져야 한다. 생소하게 바라보면 안된다. ternary operator 사용법 [value1] if [Condition] else [value2] 형태. if else문인데, 생소하다. condition이 참이면 value1을 거짓이면 value2를 반환 연산자이다.라고 강사가 말했는데, 왜 연산자인지 모르겠다. 연산자 운선순위에서 가장 아래에 위치한다. 햇갈리지 않게 하기 위해서 괄호를 사용한다. value = 32 \u0026#34;odd\u0026#34; if value % 2 else \u0026#34;even\u0026#34; 연산자라 다른 연산자와 같이 사용될 수 있다고 한다. value =32 print((\u0026#34;odd\u0026#34; if value % 2 else \u0026#34;even\u0026#34;) + \u0026#34;_number\u0026#34;) Loop loop의 기본 생각은 연산을 100번 200번 적용하는 방법이다. 함수를 100번 호출하겠다. 200번 호출하겠다. 같은 의미다. 이럴때 loop를 사용한다.\nwhile while 사용법\n기본 모양\n​- while \u0026lt;조건\u0026gt;: 명령1 명령2 example\n조건을 만족하는 동안 수행한다. i = 1 while i \u0026lt; 4: print(i) i = i+1 for 기본개념\n대용량 data인 list나 array를 처리하는 방법이다. 반복을 사용하는데, c나 java와 달리, 객체에서 값을 꺼내서 반복한다. 객체의 index가 아닌 값을 꺼낸다. 그래서 range라는 객체가 있다. range객체는 값을 index형태로 만들어내기 때문에 for-loop에 많이 사용된다.\nenumerate의 사용\nfor는 객체로부터 객체를 꺼내기 때문에 index처리를 할때 enumerate를 사용해서 index를 꺼낸다. dictionary의 경우는 key:value로 되어 있기 때문에 enumerate로 index를 꺼낼수 없다. list를 사용하거나 string을 사용할때 enumerate를 사용하면 유용하다.\nlist iterator\nexample1: for loop은 객체에서 값을 꺼내서 연산을 한다. 객체에서 값을 꺼내기 위해서 객체가 값을 저장하고 내부적으로 다음 원소를 가리킬 수 있는 객체여야 한다. iterable한 객체여야 하는데, 그것이 list같은 객체다.\nfor i in [0,1,2,3,4]: print(i) 0 1 2 3 4 example2\nfor i in [0,1,2,3,4]: if i % 2: print(i, \u0026#34;is odd\u0026#34;) (1, \u0026#39;is odd\u0026#39;) (3, \u0026#39;is odd\u0026#39;) example3: for loop을 돌리면 iterable객체에서 값을 꺼내오지 index를 가져오지 않는다. index가 필요할때는 enumerate를 사용한다.\na = [5,3,2] for i,v in enumerate(a): print(i,v) (0, 5) (1, 3) (2, 2) range iterator\nrange는 내부적으로 generator를 사용한다. generator는 함수다. 함수를 사용해서 next item을 return하는 방식이라서 list처럼 모든 원소에 해당하는 객체를 생성해서 사용하는것 보다 memory낭비가 적다. range의 형태는 다음과 같다. stop-1에서 종료된다.\n(1) range(stop) (2) range(start,stop) (3) range(start,stop,step) 내부적으로는 stop에 도달하면 exception이 발생해서 loop를 끝낸다.\nexample1 for i in range(5): print(i,\u0026#34;번째\u0026#34;) example2 for i in range(1,6): print(i,\u0026#34;번째\u0026#34;) example3 for i in range(1,10,2): print(i,\u0026#34;번째\u0026#34;) string iterator, dictionary\nfor-loop가 객체에서 값을 꺼내기 때문에 값을 저장하는 객체들은 for-loop과 같이 사용할 수 있다. string, dictionary가 대표적이다.\nstring\nfor c in \u0026#34;This is text\u0026#34;: print(c) T h i s i s t e x t dictionary\nfor key in {\u0026#34;text\u0026#34;:1, \u0026#34;word\u0026#34;:2}: print(key) text word dictionary에 enumerate\nfor key,value in enumerate({\u0026#34;text\u0026#34;:1, \u0026#34;word\u0026#34;:2}): print(key,value) 0 text 1 word for key,value in {\u0026#34;text\u0026#34;:1, \u0026#34;word\u0026#34;:2}.values(): print(key) example5\nfor key in {\u0026#34;text\u0026#34;:1, \u0026#34;word\u0026#34;:2}.items(): print(key) dictionary를 list로 바꾸는 이유는 in하고 같이 쓰일 때이다. in은 for와 같이 쓰이기 때문에, dictionary를 list형태로 바꿔야 한다. keys(),values()는 자주 변환되는 형태다. 그런데 items()는 어디에 쓰일지 궁금하다. key와 value를 tuple형태의 item list가 어디에 쓰일지도 궁금하다. 이것을 강사가 설명한다. example6에 작성했다. example 6\nfor key, value in {\u0026#34;a\u0026#34;:1, \u0026#34;b\u0026#34;:2}.items(): print(key,value) items()가 반환하는 tuple list를 어떻게 사용하는지 궁금했다. tuple list의 형태로 되어 있는것을 꺼내서 쓸때는 unpacking한다. tuple이기때문이다. tuple을 사용하는 방식은 unpacking이기 때문이다. 그래서 위의 key, value in dictionary 형태로 사용된다. break \u0026amp; continue break\nbreak를 사용하면, 여러개의 loop로 둘러싸여 있더라도 가장 바깥쪽의 loop를 벗어날 수 있다. 강사 자료 오타. range문의 수정. for i in range(1,100): if i % 17 == 0: break print(i) continue\ncontinue문은 loop의 처음으로 되돌아간다. example for i in range(100): if i % 17: continue print(i) loop에서 else\npython의 loop에 있는 특별한 기능\nelse를 loop와 같이 사용할 수 있다. 반복문이 끝났을 때 실행되는 block으로 보면된다.\nexample\nfor i in range(10): print(i) else: print(\u0026#34;loop complete with break\u0026#34;) 0-9까지 loop를 돌고 \u0026ldquo;loop complete with break\u0026quot;를 출력한다. example2\nfor i in range(10): print(i) if i \u0026gt; 5: break else: print(\u0026#34;loop complete without break\u0026#34;) else는 for block안에 있진 않다. 그래서 break문으로 for loop를 벗어난다면, else블럭이 실행되야 한다고 생각하지만, 실행되지 않는다. 이걸로 알 수 있는건 for block과 else블럭은 연관되어 있다고 볼 수 있다. ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary5_loop\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/python_summary0_about_python\/": {
        "title": "python_summary0-About Python",
        "tags": [],
        "content": "programming이란 절차지향 언어 \u0026amp; 함수형언어 초창기 programming은 computer가 가진 계산능력을 사용하는데 focus를 두었다. 엄청나게 많은 data를 program에 입력하면, 함수를 이용해 간단히 처리할 수 있다. 이것이 program을 사용하는 이유이자 각광받은 이유다. 그래서 초창기 언어들은 현실세계의 data를 programming 세계의 data로 변환하고 그 대량의 data를 함수를 사용해서 간단히 해결했다. 인간이 하면 오랜 시간이 걸릴 수 있는 데이터 처리를 너무나도 간단하게 해결했다. 여기에서 bit operator에 예제 를 살펴봐라.\n절차지향 언어와 함수형 언어는 수학처럼 모두 함수의 강력한 힘을 사용한다. 그리고 현실세계의 문제를 풀기 위해서, 문제의 data를 primitive data로 나타낸다. 수학과 비슷하다. 문제에 사용되는 data를 수로 나타내서 인간이 하지 못하는 대용량의 데이터 처리와 많은 계산들을 가능하게 해준거처럼 primitive data로 표현해서 계산을 한다. 예를 들어서, 한반 학생들의 몸무게를 다 더한다고 할때, 언어별로 data를 어떻게 표현하는지 보자. oop에서는 학생들을 객체로 simulate한다. 반면 절차지향언어와 functional language는 학생의 몸무게를 그냥 숫자로 나타내면 되는 것이다. 수학도 마찬가지다. 숫자만 보면 이것이 학생의 몸무게를 나타내는지, 무엇을 나타내는지 잘 모른다. 그러나 계산은 간단하다. 그러면 절차지향언어와 functional language로 무엇을 기준으로 나누어진건가? 절차지향의 언어는 속도를 위해서 computer라는 전자기 device에 맞춰서 만들어졌고, functional language는 인간의 생각, 수학적 방식을 그대로 사용하게 만들어졌다. focus하는 대상이 다른것이다.\n객체지향 언어 위에서 설명이 있긴 한데, programming은 현실세계의 문제를 해결하기 위해서, data를 언어내에서 표현해야 하는데, 숫자나 primitive data로 간략하게 나타냈었다. 기존의 수학이나 절차형,functional language에서 숫자나 primitive data로 나타냈는데, 그것은 많은것을 생략한 형태다. 하지만 현실세계의 data를 단순한 programming 내의 숫자나 primitive data로 나타내는건, 단순화해서 계산을 쉽게 하기 위함이다. 그런데 현실 세계의 문제를 너무 쉽게 얘기하는건 아닐까? 현실 세계의 data는 매우 복잡하다. 단순한 숫자,문자,비트로 표현하기에는 한계가 있다. 계산만 생각해서 단순하게 표현하지 않고 현실의 data와 비슷하게 simulate하려는 시도가 일어났다. 왜냐면 program이 계산만을 programming이 하는게 아니기 때문이다. 시스템을 만들때도 programming이 사용된다. 은행시스템, 기업의 인사관리 시스템\u0026hellip;이와 같은 경우는 대용량의 data처리뿐만 아니라 어떤 구조를 표현하고 구조간의 관계를 나타내야한다. 따라서 현실 세계의 data를 구체적으로 simulate할 필요가 있다. 그래서 structure이라는 구조화된 data가 나왔고, 여기서 진화해서 구조화된 data를 처리하는, 즉, 구조에 맞춰 처리하는 method가 생겼다. 이런 형태는 class형태로 만들어진다. class를 사용하는 programming언어를 oop라고 했다. oop에선 세상의 모든것은 객체로 표현될 수 있다는 철학을 가지고 있다. 세상의 모든것을 객체로 표현한다는 것은 세상을 simulation할 수 있다는 말이다. 그리고 세상을 simulation하면, 세상의 모든 문제를 해결하는데 programming언어를 사용할 수 있다는 것이다. 세상의 모든 문제는 대용량의 data를 어떻게 처리하느냐?만 있는 것이 아니다. 인간이 어려워 하는 대용량 데이터의 계산 문제뿐 아니라 모든 형태의 문제를 현실과 똑같이 simulation해서 현실 문제를 해결하는데 사용 될 수 있다는 것이다.\npython이란? python은 함수형언어가 아니라, 객체 지향 언어 다. python은 모든 것을 객체로 바라본다. 따라서 우리도, python 코드의 모든것을 객체로 생각하고, 객체로 해석해야 한다.\npython의 개발 환경 python을 사용하려면 setting이 필요하다. computer에 전원을 넣고 바로 python 코드를 작성하고 실행하는 그림을 상상하지 말자. 코딩하는 방법은 여러가지다. 코딩할 수 있는 다양한 editor가 존재하고, 그 많은 editor에서 선택을 해야한다. 나는 emacs를 선택했다. emacs를 선택해서 끝나는게 아니다. 다양한 방법이 존재한다. elpy를 사용해서 코딩할수도 있고, lsp로 코딩할수도 있고, jupyter notebook으로 코딩할수도 있고, google colab과 연결해서 사용할 수도 있다. 짜증나지만, 많은 방법이 있다. 여튼 중요한건 난 emacs를 사용한다는 것이고 emacs를 사용한다는 것은, everything is possbile 이다. 한계는 없다.\nemacs 설정 python code를 작성하는 editor로 emacs를 사용한다. emacs에서 python을 작성하기위한 setting이 필요하다. lsp를 사용해서 속시원하게 사용하는게 추천되지만, 나는 2014년 맥북 사용자다. 분수에 맞게 코딩을 하자. jupyter notebook이나 google colab을 사용해서 ipython interpreter(kernel)을 이용하려면 다음 설정을 참고하자. anaconda로 작성하려면 여기(from here) 를 참조한다. 그래도 지금 대세인 lsp를 사용하겠다고 한다면 여기(from here) 을 참조해라.\npython으로 프로그램 짜는법 일상생활의 문제들을 python으로 해결할 때 고려해야 할게 있다. 함수형으로 문제를 해결할 것인가? 아니면 oop로 문제를 해결할 것인가?인데, 이것은 문제를 보면 감이 잡힌다. 문제의 data를 확인해보자. 우리가 계산하려고 하는 data가 primitive data로 표현이 가능할 경우와 그렇지 않고 data를 구조화해야(simulate) 할지를 확인하자. 예를 들어서 30명의 고객들이 있고 고객들이 가진 은행계좌가 3개가 있고,각각의 고객들이 가진 재산을 합산해서 보여줘라 같은 문제의 경우 oop형태로 만들 필요가 없다. 여기서 data는 고객들의 은행계좌에 있는 돈들이고 그 돈들의 합이기 때문에, primitive data로 표현이 되기 때문이다. 그런데 고객과 은행계좌를 객체로 만들고 고객의 이름, 고객의 나이, 은행의 이름, 은행의 위치같은 모든 정보가 필요한 경우가 있을 수 있다. 은행과 고객의 정보를 출력한다던지\u0026hellip;이런 경우는 data를 객체로 simulate해야 한다. 그래서 oop로 짜야 한다. coding test에서 다루는 문제들은 대부분 oop문제가 아니다. primitive한 데이터 처리고, 이를 어떻게 효율적으로 처리하냐?는 알고리즘 문제이기 때문이다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary0_about_python\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/sop_idea1\/": {
        "title": "sop idea1",
        "tags": [],
        "content": "답이 1개가 아닌 최적화 문제 해결에 A.I의 사용이 흥미로웠다. discrete한 small data에 대해선 dp를 사용했지만, neural network은 거의 continuous한 big data에 대해서 최적화된 답을 내놓는다. 그런데 지금의 NLP는 reasoning을 사용하지 않고 attention model은 일종의 빈도수로 true statement를 만들어낸다. 지금의 방식은 수정이 필요해 보인다. 그래서 과거의 reasoning방식을 추가하는 연구를 하고 싶다.\nproject: project를 위해서 읽은 논문, project에 어떻게 적용. SOTA논문, novelty..\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/sop_idea1\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/emacs_org_babel_python\/": {
        "title": "[emacs] org-babel -python",
        "tags": [],
        "content": "setting emacs init file (org-babel-do-load-languages \u0026#39;org-babel-load-languages \u0026#39;((python . t))) default usage 다음과 같이 src code block을 만든다. 코드를 입력한다.\n#+BEGIN_SRC python\na = 3\n#+END_SRC\n그리고 C-c c 를 눌러서 실행한다. 그러면 None이라는 결과가 나온다. org mode에서 code block은 함수와 같다. code block은 python 함수이고 함수를 실행하면 None이다. a값을 출력할 수 있을까?\na=3 return a return문을 사용하면 함수의 결과가 return되고 return된 값을 출력한다. 또 다른 예를 보자.\n#+BEGIN_SRC python\na = 3\nprint(a)\n#+END_SRC\nreturn문을 사용하지 않고 print()를 사용해서 출력하려고 한다. 그런데 a값은 출력되지 않는다. 왜냐면 print()는 IO를 사용할뿐 함수의 return값이 아니기 때문이다. 즉 print를 실행한다고 해서 함수가 종료되지 않는다. print는 함수의 return값이 아니다. print문의 출력결과를 보기 위해선 다음과 같이 해야 한다.\n#+BEGIN_SRC python :results output\na = 3\nprint(a)\n#+END_SRC\n:results 라는 argument에 output이라는 값을 줘야 한다. python에 보면 default argument 라고 있다. 동일하다. :result는 default argument이고, :result value 에서 value가 :result의 값이다. value mode라고 말하는데, value mode는 return을 통해서 결과값을 출력할 수 있다. print와 같이 I/O를 사용해서 출력하기 위해선, output mode를 사용해야 한다.\nsession session은 code block을 연결시켜준다. code block이 2개있다고 할때, 2개는 모두 독립적이다. 2개의 code block의 실행은 새로운 python interpreter에 의해서 evaluate되기 때문에 연관관계가 없다. 그런데 한개의 python interpreter를 사용한다면 source code block에서 함수를 정의한 후 다른 source code block에서 함수를 호출하는게 가능해 진다. 그런데 이 기능을 이용하려는 것은 아니고, session을 사용하면, 위에서 return을 통해서 마지막 값을 출력하는 것을 간단히 할 수 있다.\n#+BEGIN_SRC python :session\na = 3\n#+END_SRC\n위와 같이 하면 return문 없이도 a값이 출력된다.\nexports code block을 html로 변환시에 code는 출력이 되지만, 실행결과인 result는 출력되지 않는다. 이것은 :exports code로 되어 있기 때문이다. :exports라는 default argument에는 code와 results, both의 값을 가질수 있는데, code로 세팅되어 있다. 그래서 보통 both를 해서 사용한다.\n요약 일반적인 code block은 다음과 같이 사용한다.\n#+BEGIN_SRC python :results output :exports both\n#+END_SRC\n나는 이것을 yasnippet에 추가했다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_org_babel_python\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/emacs_python_lsp_setting\/": {
        "title": "[emacs] python lsp setting",
        "tags": [],
        "content": "lsp lsp는 server client구조다.\neglot emacs python client를 말한다.\npyls(server) 이게 가장 오래된 방식이다. google에서 만들었다. 그런데 지금은 관리되지 않는다. depreciated되었다고 한다. https://emacs-lsp.github.io/lsp-mode/page/lsp-pyls/ 그래서 pyright를 사용한다. pyright는 ms에서 만들었다.\nDOING pyright 설치 create env $ conda create -n pyright_env python=3.11 RET activate env $ conda activate pyright_env install pyright on pyright env $ conda install -c conda-forge pyright RET ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_python_lsp_setting\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/python_summary2_assignment_and_variables\/": {
        "title": "python_summary2-assignment and variables",
        "tags": [],
        "content": "variable \u0026amp; operator 변수 개념 python에서의 변수를 lisp에선 symbol이라고 부르고, 일상생활에서는 name이라고 말한다. 일상생활에서 name은 중요하지 않다. 본질이 중요하다. 어떻게 부르던 본질은 변하지 않기 때문이다. 그러나, logic과 computer science는 말장난이기 때문에 name은 그 무엇보다도 중요하다. 그래서 변수, symbol, reference 등등 다양하게 부른다. 다르게 부르는 이유는 다르기 때문이다. 언어가 다르고 쓰임새가 다르다. 하지만, 여기서 우리가 알아야 하는것은 name이 본질을 가리키는 것이 아니라, 가리키는것 자체가 본질이라는 것이다. logic과 cs에서는 그렇다. symbol이던 변수던 모든것을 가리킬수 있다. 그것이 class가 되었던, macro가 되었던, primitive datatype이 되었던, function이 되었던 method가 되었던 모든것을 가리킨다. 이것이 본질이다. first order logic의 Frege가 말한 concept라는것은 어떻게 보면 가리키는 것이 본질이라는 것을 말하는지도 모르겠다.\npython의 변수를 다루기 전에 lisp에서 변수에 해당하는 symbol을 살펴보자. lisp에서 모든 symbol은 동일한 형태의 structure를 갖는다. 그림을 보자.\nFigure 1: the structure of symbol\nsymbol의 이름은 unique하다. python에서 symbol은 변수라고 부르는데, 대부분의 사람들은 대략적으로 다음과 같은 구조를 가지고 있을거라고 생각한다. 예를 들어서\na = 3 위의 문장을 python interpreter가 해석하면 아래와 같은 모양일 것이라고 생각한다.\nFigure 2: python symbol\n그러나 위 모양은 assignment가 적용되기 전의 모습이고 적용된 이후의 모습은 아래와 같다고 생각한다.\nFigure 3: python symbol2\n어떤 객체의 name에 변수명이 삽입된 형태가 아닐까 한다. 음\u0026hellip;python에서는 모든게 객체다. 예외가 있다면, python interpreter를 위한 axiom같은 built-in functions과 operators들뿐이다. 따라서 a라는 변수는 class여야 한다. 그런데 a는 class가 아니다. 예전에는 Symbol이라는 class가 있었으나, 지금은 존재하지 않는다. 변수가 symbol이라는 class로 존재한다고 가정하자. 그러면 그 class의 instance를 만들거나 literal object가 있을것이다. 마치 Int라는 class가 있어서 3이란 literal object가 있듯이 말이다. 이것은 코드로도 보일 수 있다.\na 위 코드의 실행결과는 무엇일까? 실행되지 않는 에러가 난다.\nTraceback (most recent call last):\nFile \u0026ldquo;\u0026lt;stdin\u0026gt;\u0026rdquo;, line 1, in \u0026lt;module\u0026gt;\nNameError: name \u0026lsquo;a\u0026rsquo; is not defined\na 라는 name, symbol은 정의되지 않았다고 한다. 위 그림처럼 name이 어떤 객체의 name속성으로 들어가서 객체의 일부분이 되어야 하는데 그렇지 않다는 얘기다. 그러면 assignment로 정의가 되어서 하나의 객체에 변수가 포함된것을 코드로 확인할 수 있는가? 확인할 수 있다.\na = 3 print(id(a)) print(id(3)) #+RESULTS:\n140712462129520\n140712462129520\n위와 같이 a의 address와 3의 address가 같다는것을 알수 있다. python에서 변수는 assignment를 통해서 객체에 이름을 붙인다고 생각하면 된다. 이름없는 객체에 이름을 붙이거나, 이름있는 객체에 이름을 바꾸는 것이다. 참고로 여기서 보여진 python의 변수와 object와의 관계는 내 뇌피셜이다. 반면 lisp은 gentle common lisp책을 참조했다.\n옆길로 많이 샛지만, python의 변수나 lisp의 symbol이나, \u0026quot;이름으로 모든것을 가리킬수 있다는게 중요하다.\u0026quot; 이름으로 객체도, class도 function도 method도 모든 것을 가리킬수 있다. 그게 본질이다. 여튼 그러면 이름과 구조를 연결해서 가리킬 수 있는 assignment에 대해서 알아보자. assignment는 python에서 객체가 아닌 변수, 객체가 아니라서 대접받지 못하는, 대접받는게 아니라 객체가 아니기 때문에 python에서 아예 사용할 수 없는 변수를 assignment를 해서 객체에 삽입한다.\n변경 사항 \u0026lt;2023-06-11 Sun\u0026gt;\n위에서 python의 변수와 객체의 관계를 2개의 그림으로 표시했었다. before \u0026amp; after인데, assignment가 수행되었을 때 하나의 객체에 변수가 name으로 추가된다는 설명을 했었는데, 그건 아닌거 같다. 왜냐면 여러개의 변수가 하나의 객체를 가리키는 경우가 많은데 예를 들면 primitive data들은 거의 모두 동일한 객체에 대해서 여러 변수들이 가리킬 수 있다. 나는 객체가 name list가 있다고 했는데, symbol table이 있기때문에 객체가 name list를 가질 필요가 없다. 예를 들어서 symbol table에 a:3, b:3, c:3이 있으면 되는것이지, 3이라는 객체에 name list [a,b,c]를 유지할 필요가 없기 때문이다. 내가 lisp의 symbol 구조와 python은 비슷할 거라고 생각하고 추측했기 때문이다. 정정하면 python의 assignment는 before의 그림으로 설명이 된다.\npython assignment operator 변수와 assignment의 개념 python에서 모든 것은 객체다. 그런데 예외가 있다. \u0026quot;operators와 built-in functions, 그리고 지금껏 말했던 변수는 객체가 아니다.\u0026quot; python interpreter(cpython)는 c로 작성되었고 그 중 일부는 class가 없다. c의 것을 그대로 wrapping해서 사용한다. 그래서 operator들은 중위연산 표기법을 쓴다. 아무래도 그 유산인듯하다. 여튼 \u0026quot;assignment는 위에서도 정의했듯이 객체를 생성하고 객체에 이름을 붙이는 operator다.\u0026quot; assignment문장을 python interpreter는 evaluate하는데, eval()를 봐도 알겠지만, 문자열을 입력으로 받는다. 입력으로 받은 문자열을 value로 return하는게 아니라 객체를 생성하거나 이미 있는 객체로 부터 value를 가져오는 것이다. 그리고 객체를 생성한다는 말은 객체의 생성자를 실행한다.\nassignment는 lvalue와 rvalue를 =기호를 사용해서 다음과 같이 표현한다.\nlvalue(symbol) = rvalue python interpreter는 = 이라는 문자를 보고 assignment로 알고 여러가지 처리과정을 거친다. 객체에 이름을 붙인다는 것은 code의 어디서나 참조할 수 있게 한다는 말인데, 그렇게 하기 위해서 symbol table이라는 dictionary를 사용한다. 이름과 객체의 주소를 mapping해서 symbol table에 저장하면, code의 어느 위치에서도 해당 symbol을 access해서 사용하는 것이 가능하다.\na = 3 b = [1,2,3] print(b) python interpreter가 assignment operator를 보고 해석하는 과정은 복잡하다. symbol table과 cache, string interning같은 개념에 대한 이해가 필요하기 때문이다.\n우선 interpreter는 rvalue를 처리한다. 3이 있는데, 이것은 Int 객체다. 언뜻 생각하기에 literal value라서 3으로 해석되고 객체 생성은 안할꺼 같지만, 객체 생성을 하는게 assignment operator의 동작방식이다. function이 주어지면 function객체를 생성하고, class가 주어지면 객체를 생성하는게 assignment의 역할이다. 그래야만, 객체가 생성되면서 생성자 함수가 실행되면서 method나 field에 접근이 가능하기 때문이다. 그런데 literal value는 좀 특이하다. oop언어에서 literal value는 value인 동시에 객체다. functional language에서는 literal value는 value인 동시에 function이다. 이것은 church numeral을 참조하기로 한다. rvalue는 interpreter가 해석한 후 해당하는 객체를 생성한다. 그런데, primitive한 data type을 갖는 literal 객체를 매번 생성하는건 비효율적이다. 그래서 java에서는 primitive한 data type의 객체이거나 string의 경우 pool을 만든다. 속도 때문이다. python도 그럴까? python은 일부 primitve data type객체의 경우 pool 대신에 cache에 이미 만들어진 객체를 저장한다. 예를 들면 -5~255사이의 정수 객체들은 cache에 이미 만들어져 있다. string의 경우 재사용을 위해서 string pool과 같은 string interning을 사용한다. 다시 rvalue를 어떻게 처리하는지 보자. python은 3을 보고 3을 값으로 하는 Int객체를 만든다. 3은 Int객체를 만들필요 없이 cache에서 가져와서 사용한다. 만일 500이라면 int class 생성자를 호출해서 500을 value로 설정하는 객체가 만들어졌을 것이다. 작은 정수들은 이미 cache에 있다. 그래서 cache에 있는 객체 3을 가져온다. 그리고 evaluate해서 3이란 값을 얻는다. 그런 후에 a라는 symbol과 Int객체 3의 value인 3을 mapping해서 a:3을 symbol table에 등록한다. 참고로 symbol table은 locals()와 globals()로 확인이 가능하다. 반면에 cache에 저장된 값들은 확인할 수 없다. cpython의 소스코드를 확인해야 한다. 여튼 요약하면 rvalue를 보고 cache나 heap에서 객체를 꺼내거나 생성한 후, lvalue와 함께 symbol table에 등록하면 interpretion이 끝난것이다.\n참고로 symbol table은 dictionary다. key와 value를 가지고 있다. dictionary의 key에는 심볼을 value에는 객체를 evaluate한 결과를 mapping해서 넣는다. primitive data type 객체와 string,list같은 것들은 evaluate하면 value가 나오지만, 그렇지 않은 객체들은 address가 evaluate의 결과값이 된다. \u0026lt;2023-06-11 Sun\u0026gt;\n이전 그림에서 객체는 value라는 항목이 있다고 얘기했는데, 그래서 일반 객체는, value항목에 address가 있고, primitive data들은 value항목에 value가 있다고 설명하기도 했는데, 객체에 value항목이 있는지는 모른다. lisp에 기반한 내 뇌피셜이다.\nassignment를 이해하기 위해선 cache, symbol table개념을 이해해야 하는데, 아래는 symbol table을 확인하는 예제다.\nclass Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return self.name # Person 클래스의 객체를 생성하고 값을 설정합니다. person = Person(\u0026#34;John\u0026#34;, 25) person.name = \u0026#34;Jane\u0026#34; person.age = 30 a = 3 # 객체의 속성 값을 출력합니다. print(person) print(locals()) #+RESULTS:\nJane\n{\u0026rsquo;name\u0026rsquo;: \u0026lsquo;main\u0026rsquo;, \u0026lsquo;doc\u0026rsquo;: None, \u0026lsquo;package\u0026rsquo;: None, \u0026lsquo;loader\u0026rsquo;: \u0026lt;class \u0026lsquo;frozen_importlib.BuiltinImporter\u0026rsquo;\u0026gt;, \u0026lsquo;spec\u0026rsquo;: None, \u0026lsquo;annotations\u0026rsquo;: {}, \u0026lsquo;builtins\u0026rsquo;: \u0026lt;module \u0026lsquo;builtins\u0026rsquo; (built-in)\u0026gt;, \u0026lsquo;file\u0026rsquo;: \u0026lsquo;\u0026lt;stdin\u0026gt;\u0026rsquo;, \u0026lsquo;cached\u0026rsquo;: None, \u0026lsquo;Person\u0026rsquo;: \u0026lt;class \u0026lsquo;main.Person\u0026rsquo;\u0026gt;, \u0026lsquo;person\u0026rsquo;: \u0026lt;_main.Person object at 0x7fd4312f57f0\u0026gt;, \u0026lsquo;a\u0026rsquo;: 3}\nlocals()는 local symbol table을 보여주는 함수다. global symbol table은 globals()가 제공된다. 위에서 보듯이 primitive type인 a의 경우는 값 3이 mapping되고 person이라는 class는 객체를 evaluate한 address값이 symbol table에 기록된다.\n변수와 function assignment 개념 변수는 function도 생성하고 name으로 가리킬수 있다.\ndef foo(): print(\u0026#34;foo\u0026#34;) print(locals()) #+RESULTS:\n{\u0026rsquo;name\u0026rsquo;: \u0026lsquo;main\u0026rsquo;, \u0026lsquo;doc\u0026rsquo;: None, \u0026lsquo;package\u0026rsquo;: None, \u0026lsquo;loader\u0026rsquo;: \u0026lt;class \u0026lsquo;_frozen_importlib.BuiltinImporter\u0026rsquo;\u0026gt;, \u0026lsquo;spec\u0026rsquo;: None, \u0026lsquo;annotations\u0026rsquo;: {}, \u0026lsquo;builtins\u0026rsquo;: \u0026lt;module \u0026lsquo;builtins\u0026rsquo; (built-in)\u0026gt;, \u0026lsquo;file\u0026rsquo;: \u0026lsquo;\u0026lt;stdin\u0026gt;\u0026rsquo;, \u0026lsquo;cached\u0026rsquo;: None, \u0026lsquo;foo\u0026rsquo;: \u0026lt;function foo at 0x7f87b6dd50d0\u0026gt;}\ninterpreter가 assignment를 보고 symbol table에 기록하듯이 function definition을 보고 symbol table에 기록한다. foo: function의 address로 저장한다. 여기서 function은 lambda function이다. lambda function도 python에는 heap에 저장되는 객체다. python은 모든게 객체이기 때문이다. 객체의 type은 function이란 type을 갖는다. 객체에는 모든 method와 field를 dir()로 확인할 수 있다. 그리고 foo라는 이름으로 dir()에 있는 method와 field를 접근할 수 있다.\n예를 들어서 lambda function을 보자.\nadd = lambda x, y: x + y print(type(add)) # \u0026lt;class \u0026#39;function\u0026#39;\u0026gt; print(dir(add)) 변수와 assignment의 예 1 (1) a = 15 (2) b = a (3) b print(b) (1)의 경우, 간단히 말하면, interpreter는 15를 evaluate해서 cache에서 15라는 값을 가져온다. 15라는 값이 -5~255사이이기 때문에 int객체를 cache에서 가져온다. 그리고 symbol table에 a:15를 기록한다.(2)의 경우 a라는 symbol에 해당하는 값을 symbol table에서 가져온다. 가져온 15는 그 자체가 value이면서 객체다. 15라는 value가 객체인것은 method를 실행할 수도 있고, memory에 위치한 주소도 갖고 있기 때문이다.\nprint(dir(15)) print((15).to_bytes(2,byteorder=\u0026#34;big\u0026#34;)) print(id(15)) [\u0026#39;__abs__\u0026#39;, \u0026#39;__add__\u0026#39;, \u0026#39;__and__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__cmp__\u0026#39;, \u0026#39;__coerce__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__div__\u0026#39;, \u0026#39;__divmod__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__float__\u0026#39;, \u0026#39;__floordiv__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__getnewargs__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__hex__\u0026#39;, \u0026#39;__index__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__int__\u0026#39;, \u0026#39;__invert__\u0026#39;, \u0026#39;__long__\u0026#39;, \u0026#39;__lshift__\u0026#39;, \u0026#39;__mod__\u0026#39;, \u0026#39;__mul__\u0026#39;, \u0026#39;__neg__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__nonzero__\u0026#39;, \u0026#39;__oct__\u0026#39;, \u0026#39;__or__\u0026#39;, \u0026#39;__pos__\u0026#39;, \u0026#39;__pow__\u0026#39;, \u0026#39;__radd__\u0026#39;, \u0026#39;__rand__\u0026#39;, \u0026#39;__rdiv__\u0026#39;, \u0026#39;__rdivmod__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__rfloordiv__\u0026#39;, \u0026#39;__rlshift__\u0026#39;, \u0026#39;__rmod__\u0026#39;, \u0026#39;__rmul__\u0026#39;, \u0026#39;__ror__\u0026#39;, \u0026#39;__rpow__\u0026#39;, \u0026#39;__rrshift__\u0026#39;, \u0026#39;__rshift__\u0026#39;, \u0026#39;__rsub__\u0026#39;, \u0026#39;__rtruediv__\u0026#39;, \u0026#39;__rxor__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__sub__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__truediv__\u0026#39;, \u0026#39;__trunc__\u0026#39;, \u0026#39;__xor__\u0026#39;, \u0026#39;bit_length\u0026#39;, \u0026#39;conjugate\u0026#39;, \u0026#39;denominator\u0026#39;, \u0026#39;imag\u0026#39;, \u0026#39;numerator\u0026#39;, \u0026#39;real\u0026#39;] 따라서 b와 15를 mapping해서 b:15를 symbol table에 기록한다. (3)의 경우는 evaluate하면 symbol table에서 b를 찾아서 가져온다. 15를 가져오지만, 그 값은 쓰여지지 않는다. 이후 print를 해서 그 값을 출력하면 15가 나온다. 좀더 확실한 확인은 locals(),dirs() 혹은 globals() 그리고 id()를 사용해서 확인할 수 있다.\n변수와 assignment의 예 2 (mutable vs immutable) (1) a = 1 (2) b = 1 (3) c = 1 (1)은 1을 evaluate하면 객체 1을 cache에서 가져온다. 그리고 a:1을 symbol table에 기록한다. (2)는 동일한과정으로 b:1을 기록한다. (3)은 c:1을 기록한다.\nassignment는 객체를 만든다. (1),(2),(3)의 1이라는 객체는 매번 생성되는 것인가? 아니다. cache에서 만든 객체를 가져온다. (1)에서도 가져온 객체를 사용하고 (2)번도 가져온 객체를 사용한다. (3)번도\u0026hellip; 그래서 3개의 1은 모두 동일한 객체다.\na = 1 b = 1 c = 1 print(id(a)) print(id(b)) print(id(c)) 140651367798776 140651367798776 140651367798776 반면에 아래의 예를 보자.\n(1) a = [1,2,3] (2) b = [1,2,3] (3) c = [1,2,3] (1)의 경우 list 객체를 생성해서 symbol table에 등록한다. (2)의 경우 동일한 값이다. 그러면 이전에 만들어진 객체를 재사용할 수 있을까? 안된다. 객체가 symbol table에 있는데도 불구하고 객체를 새로 만든다. (3)도 새로 만든다. id()로 주소를 찍으면 모두 다르다.\na = [1,2,3] b = [1,2,3] c = [1,2,3] print(id(a)) print(id(b)) print(id(c)) 4333367376 4333453824 4333527480 매번 새로운 객체를 만든다.\n변수와 assignment의 예 3 a = b = 2 뒤에서부터 처리한다. 2라는 객체는 -5~255사이이기 때문에 cache에서 Int객체를 가져온다. b:2를 symbol table에 기록한다. 그 다음 a = b assignment를 수행한다. symbol table에 기록된 b를 가져온다. b의 값은 2라는 객체다. 따라서 a:2를 symbol table에 기록한다.\nliteral object에 대해서 python에서 literal value는 값이면서 객체다. 즉 3이나 5도 값이면서 객체다. literal value면서 literal object이다. 그렇기 때문에 아래와 같이 method호출이 가능하다. oop언어는 value가 객체고 functional language는 value가 function이다. lambda\u0026hellip;\n4.0.real or (4).real 위에서 보듯이 literal value는 객체이기 때문에 method호출이 가능하다. 4.0은 float객체고 real이란 float의 method다. ruby에서도 이렇게 하지만, 기존언어에서는 보기 힘들다. primitive data type의 객체들은 모두 literal object라고 할 수 있다. interpreter가 literal object를 evaluate하면 value가 나오는데 그 value는 객체다. 그러면 일반 object를 evaluate하면 무엇이 나오는가? 객체의 address가 나온다. 아래는 그 예다.\na = 3 class Person: def __init__(self, name, age): self.name = name self.age = age p = Person(\u0026#34;holy\u0026#34;,20) print(a) print(p) print(eval(\u0026#39;a\u0026#39;)) print(eval(\u0026#39;p\u0026#39;)) 3 \u0026lt;__main__.Person instance at 0x1049d6368\u0026gt; 3 \u0026lt;__main__.Person instance at 0x1049d6368\u0026gt; 객체를 evaluate했을때, literal object와 일반 object의 차이를 설명하는 예제다. 원래 의도는 evaluate의 결과를 비교하는 것이다. 그런데 print()로 출력하는것과 evaluate의 결과는 다른거 아니냐고 말할 수 있다. print()는 인자로 주어지는 객체의 \u0026lsquo;str\u0026rsquo; method를 호출하는것이지 evaluate한 결과를 보여주는게 아니지 않은가? 그래서 eval()도 사용해서 결과를 출력했다. 동일한 결과를 보여준다. \u0026lsquo;str\u0026lsquo;을 재정의 하지 않는 이상 eval의 결과와 같다.\nreturn하는 assignment := (1) print((a = 2) == 2) (2) print((a := 2) == 2) (1)의 경우 python interpreter는 a=2를 수행한다. 2라는 int객체를 cache에서 가져와서 a:2를 symbol table에 저장한다. 그 다음 \u0026ldquo;\\=== 2\u0026rdquo; 를 수행해야 하는데, 비교할 대상이 없다. 에러가 난다. 왜냐면 interpreter는 symbol table에 저장만 하고 다음 instruction으로 넘어가기 때문이다. (2)를 보자. interpreter는 \u0026ldquo;(a := 2)\u0026ldquo;를 수행한다. 2라는 Int객체를 가져오고 a:2를 symbol table에 저장한다. 그런 다음 a가 남는다. 그 다음 instruction은 (a)==2가 된다. \u0026ldquo;(a) = 2\u0026quot;를 수행하게 된다. interpeter는 a를 evaluate한다. 즉 value를 꺼낸다. 2 = 2가 되어 True를 갖는다.\n여기까지 정리\u0026lt;2023-06-14 Wed\u0026gt; 아래는 예전에 쓴거라서 다시 review를 해야 한다.\nprimitive data types python에서 primitive datatype의 객체는 속도를 위해서 미리 cache에 객체를 만들어 놓았다. 그리고 oop언어에서 primitive data 객체는 값이다. 이런 primitive data type은 다음과 같은 것이 있다.\npython numerals type int,float,complex double은 없다. float가 double과 같다고 보면 된다. 다음은 numeral type의 예다.\nint: 1,2,3 float: 1.7, -5.7, 4.67e-3, 3e5 complex: 1+8j, 1.6+8j literal object는 바로 만들수 있다. 하지만 symbol이 없기때문에 참조할 수는 없다.\nstring python에는 char type이 없다. 문자들은 string type의 객체일 뿐이다.\nboolean boolean literal object는 True,False인데 대문자를 사용한다는것에 유의하자.\nTrue, False None 다른 언어에는 없는 None이라는 객체가 있다.\nNone 연산자 (operator) python의 모든 것은 객체라고 했다. operator도 객체일까? +,-,/ 같은 것을 보면 함수같다. 그런데 oop언어에 함수는 없다. method만 있을뿐이다. 그럼 method일까? 사용법을 보면 method형태가 아니다. method라면 객체.method형태로 사용할 것이다. 그럼 객체일까? 객체라면 +.abs()같은 method를 호출할수 있어야 하는데, 그런 것을 본적이 없다. operator는 과연 무엇일까? 내가 알고 있는 python의 모든 것은 객체란 말은 틀린것일까? 한가지 추론을 해본다. 연산자는 최상위 class인 Object의 method가 아닐까?\n\u0026lt;2023-06-11 Sun\u0026gt;\n이것에 대한 얘기를 위해서 한적이 있다. python은 built-in functions과 operator, 그리고 symbol은 객체가 아니다. 이것들은 python interpreter에 제공되는 구조와 기능이고, c++에서 사용되는것을 wrapping한 것이다. 아래에서는 operator 얘기도 하지만, python의 구조에 대한 고민을 담고 있기때문에 수정하거나 갱신하지 않았다. 왜?라는 질문을 하고 고민을 하고 나중에는 답을 구하고 이런 과정이 계속되는데, 나중에 구한 답만을 기록한다면 고민을 하게된 과정이나, 고민을 해결하려 추론했던 과정들이 묻히는거 같아서 지우고 다시 쓰지 않았다.\npython에서는 class선언 없이 코딩을 하곤한다. 예를 들어서, 아래 코드만 봐도, print()를 바로 호출한다. shell에서 interactive한 python을 실행할때 class를 정의할 수도 있지만, 그렇게 하지 않는다. file로 작성해서 python으로 실행할때도 class선언 없이 할수 있다. 그러면 의문이 들 수 있다. entry point가 없는 것인가? oop의 경우, 대표격 언어인 java를 보자. java에서는 class를 만들고 class에 public static void main()를 entry point로 해서 코드를 작성한다. c언어도 void main()로 entry point를 만들고 그 안에서 코딩을 한다. 그런데 entry point가 없다는게 신기하다. python이 oop언어라면, 아마도 print(3+4)를 둘러싸는 class가 있고, 그 class내의 entry point()가 있지 않을까 하고 생각한다. 다만 생략된 거 아닐까? 좀 찾아봤더니, 그렇다. 생략되었다. 아래의 print함수를 실행 시킬때는 python temp.py처럼 파일명으로 실행되고, python은 main라는 이름을 python에게 전달한다. 전달된 이름은 \u0026lsquo;name\u0026lsquo;이라는 private member변수를 세팅한다. 그리고 temp.py내에서는 if name == main 아래에 print(3+4)가 있는 것이다.\nprint(3+4); 위의 코드는 아래 코드처럼 되어 있는 것이다.\nclass temp{ if __name__ == \u0026#34;main\u0026#34;: print(3+4); } 그런데 이것과 연산자와 무슨 상관이 있는가?라고 말할 수 있다. print()에 보면 3+4에 + operator가 쓰였다. 이것이 어떤 syntax에러도 없이 수행되는 이유는, 숨겨져 있는 temp라는 class가 있고, 이 class는 Object라는 최상위 class를 상속받는다. 즉 +라는 operator는 Object class에서 정의된 method이기 때문에, 사용할 수 있는 것이다. 그래서 \u0026quot;내 생각은 + operator는 최상위 class Object의 method다.\u0026quot;\n그런데 위의 추론도 문제가 있다. + operator가 Object의 method이고 숨겨져 있는 temp라는 class가 Object를 상속하기 때문에 + method를 사용할 수 있다. 그런데 method의 인자가 3,4이다. 어떤 method가 이렇게 중위표기법으로 구현되는가? method의 중위 표기법 이상하지 않은가? temp가 Object를 상속받기 때문에 + method를 사용한다기 보다, 3이라는 literal 객체가 Object를 상속받기때문에 + method를 사용할 수 있었고, 원래 표기법은 3.+(4)인데 저렇게 쓴게 아닐까? 지금까지는 100% 정확하게 operator가 무엇인지는 모르겠다. python에서는 모든게 객체라고 했는데, operator처럼 그 존재가 정확히 모르는것 중에 built-in function이란게 있다. built-in function도 Object의 method인가?\ngpt chat에 물어보면 operator와 built-in function은 python interpreter에 의해 제공되는 pre-builtin된 함수라고 한다. python interpreter는 python언어로만 작성되지 않았다. cpython이라고 해서 내부는 c,c++로 된 함수와 변수를 사용해서 만들어진다. python의 operator와 built-in function들(id,hash같은 함수), primitive data type은 c,c++에서 정의된것을 wrapping해서 사용된다. python의 모든것은 객체라고 말할때, 이말은 python으로 만들어지는 모든게 객체일뿐 interpreter에 미리 정의된것은 객체가 아닐 수 있는 것이다.\n참고로 위에서 __name__은 object의 private field고, underbar가 한개인 것은 protected field이다. 그리고 python의 모든것이 객체라고 했는데, 참고자료가 있어서 attach했다. (참조:https://www.pythonmorsels.com/everything-is-an-object/#manually-calling-dunder-methods ),\n연산자의 종류 arithematic operator\n+(덧셈) -(뻴셈) *(곱셈) **(거듭제곱) /(몫) //(몫,정수), %(나머지) bit operator\n\u0026amp; (AND) | (OR) ~(NOT) ^ (XOR) \u0026lt;\u0026lt;, \u0026gt;\u0026gt;(SHIFT) 있다, 없다, 맞다, 틀리다의 정보는 bit로 나타낼 수 있다. 이런 정보는 bit 1개로 되어 있지 않다. byte,kbyte,극단적으로 GByte까지 엄청난 정보를 표현할 수 있다. 예를 들어서, 만명의 사람들을 일렬로 나열해서 코에 점이 있다 없다를 bit로 나타냈다고 하자.그리고 A라고 하자. 여기에는 사람을 나타내는 index정보와 점이 있다, 없다를 나타내는 정보를 표현한다. 동일한 만명인 사람들에게서 한국사람이냐 아니냐로 정보를 bit로 나타내고 B라고 하자. 한국사람이며 코에 점이 있는 사람을 알려면 and연산을 하면된다. 간단히 계산할 수 있다. 이것이 연산자의 힘이다. 한국사람이거나 코에 점이 있는 사람을 알고 싶다. 이것을 일일이 사람들을 확인할 필요가 없다. or연산을 하면 된다. 코에 점이 있는 사람들을 A라고 표시했는데, ~A라고 하면, 콤에 점이 없는 사람들을 표현할 수 있다. 몇명 인지는 1의 수를 세면 된다. XOR은 한국사람이면서 코에 점이 없거나, 코에 점이 있으면서 한국사람이 아닌 사람을 1로 표시한다. Nand, Nor도 상황에 맞게 사용할 수 있다. and or not xor은 있다,없다, 맞다,틀리다로 나타내는 명제를 수천개 수만개가 있어도 나열한 후 계산하면 된다. 근데, 실수로 수만개의 data의 이런 정보를 mega byte로 나타냈다고 하자. 그런데, 갑자기 한개의 bit를 추가해야 한다면? A에서 한칸 shift하면 된다. shift라는 것은 데이터의 삽입을 하기 위해서 사용된 연산인데, 10진수의 계산을 2진수로 변환후 shift연산을 하면 곱셈과 나눗셈을 기계적으로 더빠르게 할 수 있다. 그래서 shift는 원래의 의도인 data로서의 비트가 아니라 기계적 계산을 위한 연산자로 볼 수 있다. and or not같은 logical operator를 predicate logic에 한정지어서 말했는데, 실은 first order logic 참,거짓,있냐? 없냐의 명제가 아닌 first order statement를 계산할 수 있긴 하다. 물론, programmming language자체가 first order logic이고, 세상의 모든 knowledge는 first order logic으로 처리할 수 있기 때문에, logical operator는 중요하긴 하다. 얘기가 옆길로 빠져서\u0026hellip;쓸데 없는 소리를 많이 했다.\n연산자 축약\n아래는 연산자 축약이라고 부르는데, 연산자 축약이란 말도 첨들어보지만, 코드는 익숙하기 때문에 용어는 그냥 넘어가자. 여튼 (1)하고 (2)가 같다는 것은 누구나 알 수 있다. (1)을 (2)로도 변환할 수 있고 (2)를 (1)로도 변환할수 있다고 알고 있다. 그런데 두 개의 연산은 python에서는 다르다고 한다.\n(1) a += 1 , (2) a = a + 1 기본적으로 (1)은 a가 가르키는 symbol table의 객체를 update하는 명령어? or 문장 이라면, (2)는 a가 가르키는 객체를 새로운 객체로 replace 문장이다. +=이란 기호는 assignment와는 다른 동작을 취한다는 것이다. (1)이 a가 참조하는 객체의 값을 update한다고 했는데, 만일 update할 객체가 immutable이라면 update가 되지 않고 생성이 된다. 즉 primitive data type의 객체를 참조하는 변수라면 (1)과 (2)는 같은 것이다.\u0026quot; (1)은 (2)와 같이 동작한다. primitive data type의 객체들은 immutable하기 때문에 (1)과 (2)를 구별할 필요가 없다.\n다음 예제를 보자.\na = 3 b = a a +=1 print(locals()) {\u0026#39;a\u0026#39;: 4, \u0026#39;b\u0026#39;: 3, \u0026#39;__builtins__\u0026#39;: \u0026lt;module \u0026#39;__builtin__\u0026#39; (built-in)\u0026gt;, \u0026#39;__file__\u0026#39;: \u0026#39;\u0026lt;stdin\u0026gt;\u0026#39;, \u0026#39;__package__\u0026#39;: None, \u0026#39;__name__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__doc__\u0026#39;: None} a = 3은 assignment이기 때문에 새로운 객체를 생성하거나 update한다. 그리고 symbol table에 등록한다. 따라서 Int 객체 3을 생성하고 symbol table에 a:3을 등록한다. 그 다음, b = a를 수행 한다. a를 symbol table에서 가져오고 그 값을 b와 mapping해서 symbol table에 저장한다. b: 3이 등록된다. b= a에서 a를 interpreter가 evaluate하는데, symbol table에 a와 mapping된 객체에서 value를 가져온다. 근데 그 value라는게 일반적인 객체에서는 address다. 그런데 primitive data type의 객체들은 address가 아니 value를 따로 가져온다. primitive data type에서는 value의 값은 곧 address다. value와 address는 같다. 따라서, 역으로 symbol table에 저장할때 변수와 값을 저장하는데, primitive data type이 객체는 변수와 객체 주소를 저장하는데, 변수와 값을 저장한다. 이것은 변수와 객체 주소를 저장하는 것과 같은 의미다. 그 다음을 보자. a +=1을 하면 a가 가르키는(참조하는) 객체를 update한다.그런데 primitive data type이다. 이것은 a = a+1과 같다. interpreter는 rvalue의 a를 symbol table에서 가져온다. 가져온 객체는 3이란 값을 갖는 객체다. 그 객체에 1이란 값을 갖는 객체를 더한다. 객체와 객체를 더하면 append되거나 합쳐지는게 아니라, 새로운 객체를 만든다. primitive data type의 객체의 특징이다. immutable객체라 그렇다. 새로운 객체를 만들고 이전의 객체들로 부터 value를 더해서 4라는 value를 새로운 객체에 설정한다. 그런 다음 a:4를 symbol table에 등록한다. symbol table에는 이미 a:3이 있지만, 덮어써진다. key가 같기 때문이다. 따라서 symbol table에는 a:4만 있다. a:3을 a:4로 replace했다. 이것이 out-place다. 새롭게 만든다. 즉, 3이란 객체와 1이란 객체를 더할때, 3이란 객체에 값이 4로 update되는게 아니다.\n여기서 왜 b=a라는 문장은 왜 있는가? 위에서 test하는 것은 객체를 udpate하는 명령어 +=을 실행했을 때, a가 참조하는 객체가 변경되고, 그 객체를 참조하는 다른 변수(b)에도 영향을 미친다는 것을 보여주기 위해서다.\n위에서 update 명령어를 수행했지만, 결과는 update되지 않았다. primitive data type 객체라서 그렇다. 다른 예를 보자.\na = 3 b = a a = a + 1 print(locals()) {\u0026#39;a\u0026#39;: 4, \u0026#39;b\u0026#39;: 3, \u0026#39;__builtins__\u0026#39;: \u0026lt;module \u0026#39;__builtin__\u0026#39; (built-in)\u0026gt;, \u0026#39;__file__\u0026#39;: \u0026#39;\u0026lt;stdin\u0026gt;\u0026#39;, \u0026#39;__package__\u0026#39;: None, \u0026#39;__name__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__doc__\u0026#39;: None} 이것은 일반적인 assignment를 수행한다. a = a + 1에서 rvalue를 계산해보자. a가 참조하는 객체 3을 가지고 와서 객체 1과 더한다. primitive 객체의 연산은 새로운 객체를 만들어낸다. 객체1에 있는 value를 객체 3의 value에 더하지 않는다. 객체 3을 update하지 않는다. 순차적으로 따라가면 다음과 같다.\na=3을 interpreter가 보고 a:3을 symbol table에 등록한다. 그 다음 b = a 에서 symbol table에서 a에 mapping된 객체 3을 가져온다. 그리고 b:3을 symbol table에 저장한다. a = a +1을 interpreter는 symbol table에서 a에 mapping된 3이란 객체를 가져온다. a = 3 + 1이 된다. 3과 1은 Int객체다. 객체를 더하는건데, 3이란 객체에 있는 3이란 value에 1이란 value를 더해서 4라는 값을 3이란 객체에 update하지 않는다. primitive data type이고 immutable하기 때문에 객체와 객체의 덧셈은 새로운 객체를 만든다. 따라서 4라는 값을 갖는 객체가 만들어지고, a:4를 symbol table에 등록한다. symbol table에 있는 a:3은 a:4로 덮어 써진다. 그리고 b가 가리키는 객체3은 변하지 않는다.\n또 다른 예를 보자. 아래는 list 객체다. mutable한 객체다. mutable한 객체는 update문장에서는 객체를 update를 한다.\na = [1,2,3] b = a a += [4] print(id(b)) print(id(a)) print(locals()) 4441288784 4441288784 {\u0026#39;a\u0026#39;: [1, 2, 3, 4], \u0026#39;b\u0026#39;: [1, 2, 3, 4], \u0026#39;__builtins__\u0026#39;: \u0026lt;module \u0026#39;__builtin__\u0026#39; (built-in)\u0026gt;, \u0026#39;__file__\u0026#39;: \u0026#39;\u0026lt;stdin\u0026gt;\u0026#39;, \u0026#39;__package__\u0026#39;: None, \u0026#39;__name__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__doc__\u0026#39;: None} 여기서 interpreter는 a = [1,2,3]에서 [1,2,3]이라는 객체를 생성하고 a:[1,2,3]을 symbol table에 등록한다. 그 다음, b = a를 보고, a를 symbol테이블에서 꺼낸 객체 [1,2,3]을 b와 함께 symbol table에 등록시킨다. 그 다음 a += [4]를 수행한다. update 문장이다. a가 참조하는 [1,2,3]이라는 객체를 꺼내와서 update를 한다. 즉 + [4]를 하면 [1,2,3]에 append되어서 [1,2,3,4]라는 객체로 수정된다.\n다른 예를 보자. 이 경우는 assignment 문장이다. assignment는 update를 하지 않고 새로 생성한다.\na = [1,2,3] b = a a = a + [4] print(id(b)) print(id(a)) print(locals()) 4520849488 4521009592 {\u0026#39;a\u0026#39;: [1, 2, 3, 4], \u0026#39;b\u0026#39;: [1, 2, 3], \u0026#39;__builtins__\u0026#39;: \u0026lt;module \u0026#39;__builtin__\u0026#39; (built-in)\u0026gt;, \u0026#39;__file__\u0026#39;: \u0026#39;\u0026lt;stdin\u0026gt;\u0026#39;, \u0026#39;__package__\u0026#39;: None, \u0026#39;__name__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__doc__\u0026#39;: None} a = a + [4]에서 interpreter는 rvalue의 type에 해당하는 list 객체를 새로 생성한다. 그리고 a +[4]를 계산하여 새로운 객체에 [1,2,3,4]를 넣는다.\n정리하면, +=, -=과 같은 update operator는 assignment operator와 arithmetic operator가 합친 형태다. assignment operator와 동일한 동작이라고 생각하기 쉬우나,다른 연산이라는 것을 기억해 두자. 연산자 축약이 축약하지 않은것과의 차이는 immutable 객체가 아닌 mutable객체에서 차이를확실하게 알수있다.\nin-place:\nout-place:\n(1)의 경우는 out-place로 a라는 새로운 symbol과 무조건 새로운 객체를 만든다. 반면에 (2)는 in-place라고 해서 새로운 객체를 무조건 만들지는 않고 update할수 있는 객체라면 update를 하고 아니면 안한다고 한다. 이것은 mutable과 immutable하고도 연관이 있는듯 하다. python은 oop언어라서 모든게 객체다. 그중 primitive data type이라는게 있는데, primitive data type으로 만든 객체는 immutable하다. 즉 수정이 안된다. update가 안된다는 말이다. (1)번이야 무조건 객체를 만드니 객체를 새로 생성할지 안할지 고민할 필요가 없지만, (2)의 경우는 mutable과 immutable을 따지기 때문에 알 필요가 있다. a += 1에서 +=을 하나의 operator로 보자. lvalue에 해당하는 a를 symbol table에서 찾는다. 만일 a=3이라는 식이 위에 있어서 a가 3이라는 int 객체를 가리키고 있는 상황이라고 하자. 여기서 symbol table에서 찾은 lvalue a는 int type의 객체(value 3을 가진)를 가리킨다. primitive type이다. 따라서 update는 불가능하고 새로운 객체를 만들기 위해서 rvalue를 본다. rvalue의 값을 보고 새로운 int객체를 만들게 된다. 결론적으로 (1),(2)는 모두 새로운 객체를 생성하고 symbol이 가리키는 모습이다. 그런데, 지금까지 설명한 게 맞는지 안맞는지를 확인할 수는 없을까?\na = 3 print(id(a)) a = a+ 1 print(id(a)) a = 3 print(id(a)) a += 1 print(id(a)) id()를 사용하면 object의 address를 알수 있다. 그러나 위의 경우는 primitive data type을 a가 가리키기 때문에 매번 새로운 객체를 생성한다. 그래서 다른 id값이 나온다.\n참고로 비트 연산자들도 연산자 축약을 사용할 수 있다. 아래는 xor연산자를 보여준다.\na = 7 (1) a = a ^ 4 (2) a ^= 4 비교 연산자\n(1) x \u0026lt; y (2) x \u0026gt; y (3) x \u0026lt;= y (4) x \u0026gt;= y (5) x == y : x,y value가 같다. (6) x is y : x,y 주소가 같다. (7) x != y : x, y value가 다르다. (8) x is not y: x,y 주소가 다르다. (9) x in X : x가 X에 포함된다. (10) x not in X : x가 X에 포함되지 않는다. 여기서 기억해야 할것은 (6)과 (7)이다. ==의 경우 python interpreter는 evaluate하는데, 즉 객체의 value를 꺼낸다. 그리고 is의 경우 python interpreter가 꺼내는 것은 객체의 주소다.\nprimitive 객체들의 value를 꺼내면 3,3.0,True, \u0026ldquo;abc\u0026quot;와 같은 value가 나온다. 반면 primitive 객체가 아닌것들의 value를 꺼내면 address가 나온다. 따라서 primitive 객체들을 비교하는 경우, (5)를 쓰고, 아닌것들은 (6)을 사용하면 된다. 그런데 primitive data의 evaluate하면 value가 나온다고 했는데, 이 객체의 value들은 address라고 봐도 된다. 왜냐면 primitive data type의 일부 객체들은 객체들은 java에서 처럼 constant pool, string pool과 같은 cache,혹은 string interning방식으로 미리 저장되어 있다. 이 cache의 값들은 unique한 value들은 unique한 address를 갖는다. 따라서 pool에 객체를 저장할때 return되는것은 주소가 아니라 value가 return된다. 어차피 unique하기때문에 상관없다. 3이라는 객체가 pool에 저장될때 return값은 3이다. 주소는 unique한 정보를 담고 있다. value도 unique하다면 주소를 사용하나 value를 사용하나 동일하다. 예를 들어 보자. 값비교에는 == 기호로된 operator가 사용되고, address비교에는 is라는 문자열로된 operator가 사용된다.\nx= 3 y=3 print(id(x)) print(id(y)) print(x == y) print(x is y) x = 3을 interpreter가 해석하면, rvalue인 Int 3객체를 constant pool에서 생성한다. 만일 constant pool에 해당 객체가 있다면 그 값만 return할 것이다. 지금은 pool에 없기때문에 pool에 생성한다. 그리고 생성된 객체를 constant pool에 넣고 주소를 return받는다. 그러면 x:주소를 symbol table에 저장한다. constant pool에서는 주소와 value가 unique하기때문에 주소나 값이나 동일하다. 그리고 y=3을 실행한다. interpreter는 Int객체 3을 생성하고, constant pool에 저장할려고 한다. 근데 constant pool에 이미 있기 때문에 pool에 있는 주소를 return한다. 주소와 값이 같기 때문에 값을 그대로 return하고 symbol table에 y:3을 저장한다. 따라서 id()로 본 주소는 동일한 값이다. value도 물론 동일하다. 이제 또 다른 예로, list객체를 보자. primitive data type 객체가 아니다. 이런 객체들은 pool이 아닌 heap에 저장된다.\na = [1,2] b = [1,2] print(id(a)) print(id(b)) print(a == b) print(a is b) 4370853968 4370940416 True False interpreter는 [1,2]라는 list객체를 생성하고 heap넣는다. heap이나 pool에 저장되면 주소가 return된다. 그리고 symbol table에\nboolean operator\noperand가 boolean type일때 수행한다. bit operator는 operand가 arithematic이다. not AND OR operator priority\n기본적으로 산술연산자 \u0026gt; bit연산자 \u0026gt; 비교연산자 \u0026gt; 논리연산자의 순이다. mutable vs immutable primitive data type은 값을 변경할 수 없는 immutable이다. example1\nexample\n(1) a = 10 (2) b = a (3) a += 1 (4) a, b, a is b python interpreter는 a = 10을 본다. 우선, lvalue인 a에 대해서 symbol table에서 확인한다. 없다. 그리고 rvalue를 본다. int type이란 것을 알기에 int객체를 만들고, name과 value를 설정한다. python interpreter는 b = a를 본다. lvalue인 b가 symbol table에 있는지 확인한다. 없다. rvalue인 a를 본다. symbol table에 있다. 해당 객체의 type정보만 가지고 온다. int다. 이제 객체를 만든다. b라는 이름과 a라는 값을 갖는 객체를 만들었다. python interpreter는 a += 1을 본다. lvalue인 a를 symbol table에서 찾는다. a는 10의 값을 가지고 있는 immutable한 객체다. rvalue를 본다. a가 가진 값과 1을 더해 11이란 값을 만든다. 이제 객체를 만들어야 하는데, lvalue가 immutable하기 때문에 update할 수 없다. 새로운 객체를 만든다.a라는 새로운 객체를 만든다. 그러면 기존 a객체가 갱신된다. 여기서 확인해야 할 것은 b의 value다. b의 value는 a인것인가? 아니면, a가 가진 값인가? 지금 봤을때는 a가 가진 address인거 같다. 그래서 (3)까지 출력했을 때, a값은 새로운 객체의 11값을 가지고, b의 경우는 옛날 객체인 a의 값인 10을 갖는다. 새로운 a객체를 가르키지 않는다. 그리고 a is b는 false다. is라는 함수는 a와 b의 값을 가져오기 때문이다. example2\n(1) a = [1,2,3] (2) b = a (3) a += [4] (4) a, b, a is b python interpreter는 a = [1,2,3]을 본다. lvalue를 보고 symbol table에서 a를 찾는다. a는 없다. rvalue를 본다. [1,2,3]이다. eval할 필요가 없다. 이제 객체를 만든다, name,value를 연결한다. python interpreter는 b = a를 본다. lvalue의 b를 symbol table에서 찾는다. 없다. rvalue의 a의 type을 확인한다. list다. list객체를 만들고,이름과 value를 연결한다. 여기서 list객체를 만드는지는 잘 모르겠다. python interpreter는 a += [4]를 본다. lvalue인 a를 본다. symbol table에 있다. type을 보니 list다. 즉 mutable하다. rvalue를 본다.a +[4]를 계산하자. a의 value인 [1,2,3]의 append를 사용해서 [4]를 추가한다. [1,2,3,4]의 값이 나왔다. 이제 여기서 객체를 만드는것이 아닌 a객체의 value를 update한다. a의 값은 [1,2,3,4]이고, b도 [1,2,3,4]이다. a is b는 True가 된다. example3\na = [1,2,3,4] b = a a = a + [5] a,b, a si b In-place operator에 대해서 a +=1과 a= a+1의 차이: assignment와 operator의 차이 python에서 모든 것은 객체다. 그리고 모든 function은 어떤 객체의 method다. 그런데, 위에서 봤던 operator들은 method의 모양을 하고 있지 않다. 그럼 operator라는 것은 무엇인가? 본질은 method다. 즉, member method이다. 이것은 여기 에서 확인할 수있다. 이제 a += 1과 a = a+1에 대해 말해보자. a += 1에서 +=는 operator임을 알수 있다. member function, 즉 method라는것은 해당 객체의 값을 변경, update를 한다. 그런데 a 객체는 immutable이다. integer literal이기 때문에 값을 변경하지 못한다. 그래서 새로운 객체를 만들어낸다. 만일 a가 list와 같은 mutable한 객체라면, 그 값은 변경이 될 것이다. 그리고 a = a + 1의 경우는 assignment다. 즉, 새로운 객체를 만들어 내는 것이다.\nexamples\nexample1\na = 10 b = a a += 1 print(a) print(b) print(a is b) example2\na = 10 b = a a = a + 1 print(a) print(b) print(a is b) example2\na = [1,2,3,4] b = a a += [5] print(a) print(b) print(a is b) example2\na = [1,2,3,4] b = a a = a + [5] print(a) print(b) print(a is b) == 과 is ==는 값을 비교, is는 객체의 이름(주소)를 비교\nexample1\n아래는 False가 나와야 정답인데, 이상하게 True가 나온다. a = 13453436 b = 13453436 print (a is b) 아래는 True가 나온다. a = 13453436 b = 13453436 print (a == b) example2\n이것도 제대로된 결과가 나오지 않는다. True,True,False,True가 정답이라고 한다. print(b is \u0026rsquo;long-long-text\u0026rsquo;) 이 왜 false가 나오는지 모르겠다. a = \u0026#39;text\u0026#39; b = \u0026#39;long-long-text\u0026#39; print(a is \u0026#39;text\u0026#39;) print(a == \u0026#39;text\u0026#39;) print(b is \u0026#39;long-long-text\u0026#39;) print(b == \u0026#39;long-long-text\u0026#39;) example3\na = True print(a is True) example4\na = None print(a is None) Dynamic typing type을 명시하지 않고, assign할 때, rvalue를 보고 type이 정해진다. implicit type conversion bool -\u0026gt; int -\u0026gt; float -\u0026gt; complex bool type은 int type으로 conversion이 가능하고, int는 float로 conversion이 가능하다.\na = True a = a + 2 print(a) a = a + 1.5 print(a) python interpreter가 a = True를 보고, Boolean 객체를 만들고, 객체에 a라는 이름과 True라는 값을 맵핑한다.\npython이 a = a + 2를 본다. lvalue인 a를 symbol table에서 찾는다. 있다. rvalue를 계산한다. a의 value는 True이고, 2라는 값이 넘어온다. 이때 boolean객체의 overriding된 + method가 True와 2라는 값을 더해서 어떤일을 하는지는 정확히 모르겠다. 여튼 더하면 3이란 값이 계산되고, assign을 적용해서, int객체를 만들고 a의 이름과 3이란 값을 갖게 된다.\npython interpreter가 a = a + 1.5를 보고 위의 과정과 비슷한 과정을 거치게 된다.\nexample2 형변환이 안된다.\na = 1 a + None a + \u0026#39;text\u0026#39; explicit type conversion complex를 float로, float를 int로, int를 str로 형변환을 할수 있다. 이것은 강제 형변환을 해야 한다. example a = 12345 float(a) complex(a) str(a) bool(a) bool의 경우는 none,[],{} 등은 false값을 갖는다. 형변환의 또다른 예 print(int(75.75)) print(str(75.75)) print(bool(\u0026#39;True\u0026#39;)) 소수점 처리 방식 소수점 버림: int(75.75) 소수점 반올림: round(75.75), object의 method. 소수점 올림: math.ceil type checking 객체에는 type이라는 항목을 가지고 있어서 built-in function인 type()를 사용해서 객체의 type을 return받을 수 있다.\na = 123 print(type(a)) print(isinstance(a,float)) \u0026lt;type \u0026#39;int\u0026#39;\u0026gt; False 123을 interpreter는 문자열을 읽고 cache에서 123이라는 Int객체를 가져온다. 그리고 symbol table에 a:123을 기록한다. type(a)는 interpreter가 a라는 객체를 symbol table에서 꺼내서 객체의 type인 int를 return받는다. isinstance()는 인자로 객체와 type을 받는다. 객체로 받은 a는 int고 type은 float다. 따라서 False값이 나온다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary2_assignment_and_variables\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/emacs_anaconda_settings\/": {
        "title": "[emacs] anaconda settings",
        "tags": [],
        "content": "system 설정 emacs에서 anaconda를 사용하기 위해선, mac에 anaconda를 설치한다. 여기(from here) 에서 다운받아서 설치하면 된다.\nvirtual environment 개요 시스템에 하나의 python만 있으면 불편하다. 하나의 python에 여러 package들이 설치된 후 project를 만들게 되는데, 매번 새로운 project를 만들때마다 project에 맞는 package를 설치해야 하는데, 기존 설치된 package때문에 충돌도 일어날 수 있다. 따라서 project에 필요한 python과 package들을 묶은 환경이 필요하다. project기준으로 봐야 한다. 기본적으로 anaconda을 설치하면 default 환경은 base다.\nFigure 1: 기본환경\n가상환경 만들기 가상환경을 만들려면, shell에서 conda명령어를 이용한다.\n$ conda create -n [가상환경이름] $ conda create -n [가상환경이름] python=3.7 가상환경 선택하기(활성화하기,비활성화하기) $ conda activate [가상환경이름] $ conda deactivate 가상환경 정보보기 현재 선택된 가상환경 목록 보기\n$ conda info 가상환경 목록보기 $ conda info --envs 가상환경 삭제하기 $ conda remove --name [가상환경이름] anaconda emacs 설정 anaconda mode setting (use-package anaconda-mode :ensure t ) create new .py file C-x C-f HolaWorld.py RET Add the code print (\u0026#34;Hola World from Emacs\u0026#34;) running it C-c C-p C-c C-c output\nFigure 2: anaconda2\nconda emacs설정 conda mode setting (use-package conda :ensure t :init (setq conda-anaconda-home \u0026#34;/Users/holy/opt/anaconda3\u0026#34;) (setq conda-env-home-directory \u0026#34;/Users/holy/opt/anaconda3/envs\u0026#34;) :config (conda-env-autoactivate-mode t)) check env list M-x conda-env-list RET activate env M-x conda-activate RET company 설정 complete anything. 자동완성 기능\ncompany setting (use-package company-anaconda :ensure t :config (eval-after-load \u0026#34;company\u0026#34; \u0026#39;(add-to-list \u0026#39;company-backends \u0026#39;(company-anaconda :with company-capf)))) ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_anaconda_settings\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/hugo_korean_encoding_problem\/": {
        "title": "hugo korean encoding problem",
        "tags": [],
        "content": "org-roam과 한글 org-roam에서 title을 한글로 하면 한글명의 org파일이 만들어지고, ox-hugo를 실행하면 contents/posts에 md파일이 만들어진다. 이 상태에서 hugo를 사용해서 md파일을 html로 만들게 된다. md파일을 전처리 하는 과정에서 title이름의 폴더를 만들고 index.html을 만들게 된다. 따라서 title을 한글로 만들면, public폴더에는 한글 폴더가 있게 된다.\nhugo의 문제 한글 폴더가 있다는게 development환경에서는 문제가 되지 않는다. 그런데 production환경에서는 한글폴더를 읽지 못하는 문제가 있다. config.toml에 다음과 같이 설정을 했지만, 해결하지 못했다.\nlanguageCode = \u0026#34;ko\u0026#34; hasCJKLanguage = true 해결책 그럼 어떻게 할것인가? 그냥 org-roam에서 title을 작성할때, 영어로 쓰자. 고칠려고 애는 쓸만큼 썼다. 5시간동안 했는데 해결책을 못찾았다. 너무 시간을 쏟을 필요가 없다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/hugo_korean_encoding_problem\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/python_summary1\/": {
        "title": "python_summary1-import and module",
        "tags": [],
        "content": "import python code의 첫줄에 가장 많이 볼 수 있는 것은 import문이다. 어떤 code를 보더라도 첫줄에 아래와 같은 import로 시작하는 문장을 볼 수 있다. 형태는 다음과 같다.\nimport [module] import [package] 예를 들면 다음과 같다.\nimport numpy as np 사람들은 말한다. numpy라는 module을 가져와서 np로 이름을 바꿔서 쓴다고 한다. python은 축약적이기 때문에 숨겨져 있는것을 볼 수 있어야 한다. import는 파일을 load한다. load한다는 말은 문자열로된 파일을 읽고 단어별로 list에 넣은 다음, 각각의 단어를 해석해서 객체를 만드는 작업이다. 즉 위와 같이 load한다는 말은 많은과정이 함축되어 있는 것이다. python에서 .py로 끝나는 파일은 module 이라고 하고, module을 모은 directory를 package 라고 하는데, import는 module과 package를 load한다. 위에서 load를 정의했듯이 import는 module과 package를 모두 읽을수 있다. 디렉토리에 있는 파일들이나, 파일 하나도 모두 utf-8로된 문자열로 되어 있다. 그래서 parsing해서 객체를 만드는 것이다. .py로 시작되는 파일(module)은 보이지 않는 class로 둘러싸여 있다고 생각하자. 예를 들어서, test.py에 아래와 같은 코드가 있다면,\ndef test(): return 3+4 class test2(name): __init__(self,name): self.name = name 파일명에 해당하는 class로 둘러싸여 있다고 생각하면 된다. 아래를 보자.\nclass test:\ndef test():\nreturn 3+4\nclass test2(name):\ninit(self,name):\nself.name = name\n즉, class안에는 class도 있고 function도 define되어 있는 것이다.\n요약하면, import문은 객체생성!이라고 생각하면 된다. 객체 생성이 갑툭튀같은 느낌이 들면, import에 적힌 module이나 package들은 text파일이고, 이 text파일을 읽어서 객체를 만드는 과정이라고 풀어서 이해하면 된다. 예를 들어, import numpy는 numpy라는 객체를 생성해서 numpy.random 이런 식으로 사용할 수 있다. import numpy as np는 numpy라는 객체를 생성하고 np: numpy라는 symbol table에 등록 한다. 그래서 np.random식으로 사용할 수 있다.\nimport 사용시 궁금한것들 python에서 programming은 객체를 생성하고, 객체에 있는 data를 method로 처리하는것이다. oop언어나 functional language나 처리방법은 같다. programming이라는 것은 data를 처리하는 것이다. 예를 들어,1000만명의 몸무게를 적은 data가 있다고 하자. 그런데 실수로 100kg을 더해서 기록했다. 50kg인 사람은 150kg으로 적었다. programming 언어를 사용하면 함수나 method를 사용해서 1000개의 data에 -100kg을 빼는것은 한큐에 처리가 가능하다. 그만큼 function이나 method가 강력한 것이다. 따라서 python에서 객체를 생성하면, 객체에 있는 method가 궁금하다. 어떤 method가 있을까? 이것을 확인할수 있는게 dir()다.\na = 3 print(dir(a)) [\u0026#39;__abs__\u0026#39;, \u0026#39;__add__\u0026#39;, \u0026#39;__and__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__cmp__\u0026#39;, \u0026#39;__coerce__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__div__\u0026#39;, \u0026#39;__divmod__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__float__\u0026#39;, \u0026#39;__floordiv__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__getnewargs__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__hex__\u0026#39;, \u0026#39;__index__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__int__\u0026#39;, \u0026#39;__invert__\u0026#39;, \u0026#39;__long__\u0026#39;, \u0026#39;__lshift__\u0026#39;, \u0026#39;__mod__\u0026#39;, \u0026#39;__mul__\u0026#39;, \u0026#39;__neg__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__nonzero__\u0026#39;, \u0026#39;__oct__\u0026#39;, \u0026#39;__or__\u0026#39;, \u0026#39;__pos__\u0026#39;, \u0026#39;__pow__\u0026#39;, \u0026#39;__radd__\u0026#39;, \u0026#39;__rand__\u0026#39;, \u0026#39;__rdiv__\u0026#39;, \u0026#39;__rdivmod__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__rfloordiv__\u0026#39;, \u0026#39;__rlshift__\u0026#39;, \u0026#39;__rmod__\u0026#39;, \u0026#39;__rmul__\u0026#39;, \u0026#39;__ror__\u0026#39;, \u0026#39;__rpow__\u0026#39;, \u0026#39;__rrshift__\u0026#39;, \u0026#39;__rshift__\u0026#39;, \u0026#39;__rsub__\u0026#39;, \u0026#39;__rtruediv__\u0026#39;, \u0026#39;__rxor__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__sub__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__truediv__\u0026#39;, \u0026#39;__trunc__\u0026#39;, \u0026#39;__xor__\u0026#39;, \u0026#39;bit_length\u0026#39;, \u0026#39;conjugate\u0026#39;, \u0026#39;denominator\u0026#39;, \u0026#39;imag\u0026#39;, \u0026#39;numerator\u0026#39;, \u0026#39;real\u0026#39;] 위에서 보면 객체의 사용되는 method들을 dir()로 확인할 수 있다. 객체를 생성하는 방식은 python에서는 import로 만들거나 assignment로 만드는데. 둘다 dirs()로 확인할 수 있다. import로 만드는 객체에 대한 예시는 아래와 같다. 그리고 assignment에 대한 자세한 설명은 여기 에 있다.\nimport numpy as np print(dir(np)) print(np.__file__) [\u0026#39;ALLOW_THREADS\u0026#39;, \u0026#39;BUFSIZE\u0026#39;, \u0026#39;CLIP\u0026#39;, \u0026#39;ComplexWarning\u0026#39;, \u0026#39;DataSource\u0026#39;, \u0026#39;ERR_CALL\u0026#39;, \u0026#39;ERR_DEFAULT\u0026#39;, \u0026#39;ERR_DEFAULT2\u0026#39;, \u0026#39;ERR_IGNORE\u0026#39;, \u0026#39;ERR_LOG\u0026#39;, \u0026#39;ERR_PRINT\u0026#39;, \u0026#39;ERR_RAISE\u0026#39;, \u0026#39;ERR_WARN\u0026#39;, \u0026#39;FLOATING_POINT_SUPPORT\u0026#39;, \u0026#39;FPE_DIVIDEBYZERO\u0026#39;, \u0026#39;FPE_INVALID\u0026#39;, \u0026#39;FPE_OVERFLOW\u0026#39;, \u0026#39;FPE_UNDERFLOW\u0026#39;, \u0026#39;False_\u0026#39;, \u0026#39;Inf\u0026#39;, \u0026#39;Infinity\u0026#39;, \u0026#39;MAXDIMS\u0026#39;, \u0026#39;MachAr\u0026#39;, \u0026#39;ModuleDeprecationWarning\u0026#39;, \u0026#39;NAN\u0026#39;, \u0026#39;NINF\u0026#39;, \u0026#39;NZERO\u0026#39;, \u0026#39;NaN\u0026#39;, \u0026#39;NanWarning\u0026#39;, \u0026#39;PINF\u0026#39;, \u0026#39;PZERO\u0026#39;, \u0026#39;PackageLoader\u0026#39;, \u0026#39;RAISE\u0026#39;, \u0026#39;RankWarning\u0026#39;, \u0026#39;SHIFT_DIVIDEBYZERO\u0026#39;, \u0026#39;SHIFT_INVALID\u0026#39;, \u0026#39;SHIFT_OVERFLOW\u0026#39;, \u0026#39;SHIFT_UNDERFLOW\u0026#39;, \u0026#39;ScalarType\u0026#39;, \u0026#39;Tester\u0026#39;, \u0026#39;True_\u0026#39;, \u0026#39;UFUNC_BUFSIZE_DEFAULT\u0026#39;, \u0026#39;UFUNC_PYVALS_NAME\u0026#39;, \u0026#39;WRAP\u0026#39;, \u0026#39;__NUMPY_SETUP__\u0026#39;, \u0026#39;__all__\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;__config__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__file__\u0026#39;, \u0026#39;__git_revision__\u0026#39;, \u0026#39;__name__\u0026#39;, \u0026#39;__package__\u0026#39;, \u0026#39;__path__\u0026#39;, \u0026#39;__version__\u0026#39;, \u0026#39;_import_tools\u0026#39;, \u0026#39;_mat\u0026#39;, \u0026#39;abs\u0026#39;, \u0026#39;absolute\u0026#39;, \u0026#39;absolute_import\u0026#39;, \u0026#39;add\u0026#39;, \u0026#39;add_docstring\u0026#39;, \u0026#39;add_newdoc\u0026#39;, \u0026#39;add_newdoc_ufunc\u0026#39;, \u0026#39;add_newdocs\u0026#39;, \u0026#39;alen\u0026#39;, \u0026#39;all\u0026#39;, \u0026#39;allclose\u0026#39;, \u0026#39;alltrue\u0026#39;, \u0026#39;alterdot\u0026#39;, \u0026#39;amax\u0026#39;, \u0026#39;amin\u0026#39;, \u0026#39;angle\u0026#39;, \u0026#39;any\u0026#39;, \u0026#39;append\u0026#39;, \u0026#39;apply_along_axis\u0026#39;, \u0026#39;apply_over_axes\u0026#39;, \u0026#39;arange\u0026#39;, \u0026#39;arccos\u0026#39;, \u0026#39;arccosh\u0026#39;, \u0026#39;arcsin\u0026#39;, \u0026#39;arcsinh\u0026#39;, \u0026#39;arctan\u0026#39;, \u0026#39;arctan2\u0026#39;, \u0026#39;arctanh\u0026#39;, \u0026#39;argmax\u0026#39;, \u0026#39;argmin\u0026#39;, \u0026#39;argpartition\u0026#39;, \u0026#39;argsort\u0026#39;, \u0026#39;argwhere\u0026#39;, \u0026#39;around\u0026#39;, \u0026#39;array\u0026#39;, \u0026#39;array2string\u0026#39;, \u0026#39;array_equal\u0026#39;, \u0026#39;array_equiv\u0026#39;, \u0026#39;array_repr\u0026#39;, \u0026#39;array_split\u0026#39;, \u0026#39;array_str\u0026#39;, \u0026#39;asanyarray\u0026#39;, \u0026#39;asarray\u0026#39;, \u0026#39;asarray_chkfinite\u0026#39;, \u0026#39;ascontiguousarray\u0026#39;, \u0026#39;asfarray\u0026#39;, \u0026#39;asfortranarray\u0026#39;, \u0026#39;asmatrix\u0026#39;, \u0026#39;asscalar\u0026#39;, \u0026#39;atleast_1d\u0026#39;, \u0026#39;atleast_2d\u0026#39;, \u0026#39;atleast_3d\u0026#39;, \u0026#39;average\u0026#39;, \u0026#39;bartlett\u0026#39;, \u0026#39;base_repr\u0026#39;, \u0026#39;bench\u0026#39;, \u0026#39;binary_repr\u0026#39;, \u0026#39;bincount\u0026#39;, \u0026#39;bitwise_and\u0026#39;, \u0026#39;bitwise_not\u0026#39;, \u0026#39;bitwise_or\u0026#39;, \u0026#39;bitwise_xor\u0026#39;, \u0026#39;blackman\u0026#39;, \u0026#39;bmat\u0026#39;, \u0026#39;bool\u0026#39;, \u0026#39;bool8\u0026#39;, \u0026#39;bool_\u0026#39;, \u0026#39;broadcast\u0026#39;, \u0026#39;broadcast_arrays\u0026#39;, \u0026#39;busday_count\u0026#39;, \u0026#39;busday_offset\u0026#39;, \u0026#39;busdaycalendar\u0026#39;, \u0026#39;byte\u0026#39;, \u0026#39;byte_bounds\u0026#39;, \u0026#39;bytes_\u0026#39;, \u0026#39;c_\u0026#39;, \u0026#39;can_cast\u0026#39;, \u0026#39;cast\u0026#39;, \u0026#39;cdouble\u0026#39;, \u0026#39;ceil\u0026#39;, \u0026#39;cfloat\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;character\u0026#39;, \u0026#39;chararray\u0026#39;, \u0026#39;choose\u0026#39;, \u0026#39;clip\u0026#39;, \u0026#39;clongdouble\u0026#39;, \u0026#39;clongfloat\u0026#39;, \u0026#39;column_stack\u0026#39;, \u0026#39;common_type\u0026#39;, \u0026#39;compare_chararrays\u0026#39;, \u0026#39;compat\u0026#39;, \u0026#39;complex\u0026#39;, \u0026#39;complex128\u0026#39;, \u0026#39;complex256\u0026#39;, \u0026#39;complex64\u0026#39;, \u0026#39;complex_\u0026#39;, \u0026#39;complexfloating\u0026#39;, \u0026#39;compress\u0026#39;, \u0026#39;concatenate\u0026#39;, \u0026#39;conj\u0026#39;, \u0026#39;conjugate\u0026#39;, \u0026#39;convolve\u0026#39;, \u0026#39;copy\u0026#39;, \u0026#39;copysign\u0026#39;, \u0026#39;copyto\u0026#39;, \u0026#39;core\u0026#39;, \u0026#39;corrcoef\u0026#39;, \u0026#39;correlate\u0026#39;, \u0026#39;cos\u0026#39;, \u0026#39;cosh\u0026#39;, \u0026#39;count_nonzero\u0026#39;, \u0026#39;cov\u0026#39;, \u0026#39;cross\u0026#39;, \u0026#39;csingle\u0026#39;, \u0026#39;ctypeslib\u0026#39;, \u0026#39;cumprod\u0026#39;, \u0026#39;cumproduct\u0026#39;, \u0026#39;cumsum\u0026#39;, \u0026#39;datetime64\u0026#39;, \u0026#39;datetime_as_string\u0026#39;, \u0026#39;datetime_data\u0026#39;, \u0026#39;deg2rad\u0026#39;, \u0026#39;degrees\u0026#39;, \u0026#39;delete\u0026#39;, \u0026#39;deprecate\u0026#39;, \u0026#39;deprecate_with_doc\u0026#39;, \u0026#39;diag\u0026#39;, \u0026#39;diag_indices\u0026#39;, \u0026#39;diag_indices_from\u0026#39;, \u0026#39;diagflat\u0026#39;, \u0026#39;diagonal\u0026#39;, \u0026#39;diff\u0026#39;, \u0026#39;digitize\u0026#39;, \u0026#39;disp\u0026#39;, \u0026#39;divide\u0026#39;, \u0026#39;division\u0026#39;, \u0026#39;dot\u0026#39;, \u0026#39;double\u0026#39;, \u0026#39;dsplit\u0026#39;, \u0026#39;dstack\u0026#39;, \u0026#39;dtype\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ediff1d\u0026#39;, \u0026#39;einsum\u0026#39;, \u0026#39;emath\u0026#39;, \u0026#39;empty\u0026#39;, \u0026#39;empty_like\u0026#39;, \u0026#39;equal\u0026#39;, \u0026#39;errstate\u0026#39;, \u0026#39;euler_gamma\u0026#39;, \u0026#39;exp\u0026#39;, \u0026#39;exp2\u0026#39;, \u0026#39;expand_dims\u0026#39;, \u0026#39;expm1\u0026#39;, \u0026#39;extract\u0026#39;, \u0026#39;eye\u0026#39;, \u0026#39;fabs\u0026#39;, \u0026#39;fastCopyAndTranspose\u0026#39;, \u0026#39;fft\u0026#39;, \u0026#39;fill_diagonal\u0026#39;, \u0026#39;find_common_type\u0026#39;, \u0026#39;finfo\u0026#39;, \u0026#39;fix\u0026#39;, \u0026#39;flatiter\u0026#39;, \u0026#39;flatnonzero\u0026#39;, \u0026#39;flexible\u0026#39;, \u0026#39;fliplr\u0026#39;, \u0026#39;flipud\u0026#39;, \u0026#39;float\u0026#39;, \u0026#39;float128\u0026#39;, \u0026#39;float16\u0026#39;, \u0026#39;float32\u0026#39;, \u0026#39;float64\u0026#39;, \u0026#39;float_\u0026#39;, \u0026#39;floating\u0026#39;, \u0026#39;floor\u0026#39;, \u0026#39;floor_divide\u0026#39;, \u0026#39;fmax\u0026#39;, \u0026#39;fmin\u0026#39;, \u0026#39;fmod\u0026#39;, \u0026#39;format_parser\u0026#39;, \u0026#39;frexp\u0026#39;, \u0026#39;frombuffer\u0026#39;, \u0026#39;fromfile\u0026#39;, \u0026#39;fromfunction\u0026#39;, \u0026#39;fromiter\u0026#39;, \u0026#39;frompyfunc\u0026#39;, \u0026#39;fromregex\u0026#39;, \u0026#39;fromstring\u0026#39;, \u0026#39;full\u0026#39;, \u0026#39;full_like\u0026#39;, \u0026#39;fv\u0026#39;, \u0026#39;generic\u0026#39;, \u0026#39;genfromtxt\u0026#39;, \u0026#39;get_array_wrap\u0026#39;, \u0026#39;get_include\u0026#39;, \u0026#39;get_numarray_include\u0026#39;, \u0026#39;get_printoptions\u0026#39;, \u0026#39;getbuffer\u0026#39;, \u0026#39;getbufsize\u0026#39;, \u0026#39;geterr\u0026#39;, \u0026#39;geterrcall\u0026#39;, \u0026#39;geterrobj\u0026#39;, \u0026#39;gradient\u0026#39;, \u0026#39;greater\u0026#39;, \u0026#39;greater_equal\u0026#39;, \u0026#39;half\u0026#39;, \u0026#39;hamming\u0026#39;, \u0026#39;hanning\u0026#39;, \u0026#39;histogram\u0026#39;, \u0026#39;histogram2d\u0026#39;, \u0026#39;histogramdd\u0026#39;, \u0026#39;hsplit\u0026#39;, \u0026#39;hstack\u0026#39;, \u0026#39;hypot\u0026#39;, \u0026#39;i0\u0026#39;, \u0026#39;identity\u0026#39;, \u0026#39;iinfo\u0026#39;, \u0026#39;imag\u0026#39;, \u0026#39;in1d\u0026#39;, \u0026#39;index_exp\u0026#39;, \u0026#39;indices\u0026#39;, \u0026#39;inexact\u0026#39;, \u0026#39;inf\u0026#39;, \u0026#39;info\u0026#39;, \u0026#39;infty\u0026#39;, \u0026#39;inner\u0026#39;, \u0026#39;insert\u0026#39;, \u0026#39;int\u0026#39;, \u0026#39;int0\u0026#39;, \u0026#39;int16\u0026#39;, \u0026#39;int32\u0026#39;, \u0026#39;int64\u0026#39;, \u0026#39;int8\u0026#39;, \u0026#39;int_\u0026#39;, \u0026#39;int_asbuffer\u0026#39;, \u0026#39;intc\u0026#39;, \u0026#39;integer\u0026#39;, \u0026#39;interp\u0026#39;, \u0026#39;intersect1d\u0026#39;, \u0026#39;intp\u0026#39;, \u0026#39;invert\u0026#39;, \u0026#39;ipmt\u0026#39;, \u0026#39;irr\u0026#39;, \u0026#39;is_busday\u0026#39;, \u0026#39;isclose\u0026#39;, \u0026#39;iscomplex\u0026#39;, \u0026#39;iscomplexobj\u0026#39;, \u0026#39;isfinite\u0026#39;, \u0026#39;isfortran\u0026#39;, \u0026#39;isinf\u0026#39;, \u0026#39;isnan\u0026#39;, \u0026#39;isneginf\u0026#39;, \u0026#39;isposinf\u0026#39;, \u0026#39;isreal\u0026#39;, \u0026#39;isrealobj\u0026#39;, \u0026#39;isscalar\u0026#39;, \u0026#39;issctype\u0026#39;, \u0026#39;issubclass_\u0026#39;, \u0026#39;issubdtype\u0026#39;, \u0026#39;issubsctype\u0026#39;, \u0026#39;iterable\u0026#39;, \u0026#39;ix_\u0026#39;, \u0026#39;kaiser\u0026#39;, \u0026#39;kron\u0026#39;, \u0026#39;ldexp\u0026#39;, \u0026#39;left_shift\u0026#39;, \u0026#39;less\u0026#39;, \u0026#39;less_equal\u0026#39;, \u0026#39;lexsort\u0026#39;, \u0026#39;lib\u0026#39;, \u0026#39;linalg\u0026#39;, \u0026#39;linspace\u0026#39;, \u0026#39;little_endian\u0026#39;, \u0026#39;load\u0026#39;, \u0026#39;loads\u0026#39;, \u0026#39;loadtxt\u0026#39;, \u0026#39;log\u0026#39;, \u0026#39;log10\u0026#39;, \u0026#39;log1p\u0026#39;, \u0026#39;log2\u0026#39;, \u0026#39;logaddexp\u0026#39;, \u0026#39;logaddexp2\u0026#39;, \u0026#39;logical_and\u0026#39;, \u0026#39;logical_not\u0026#39;, \u0026#39;logical_or\u0026#39;, \u0026#39;logical_xor\u0026#39;, \u0026#39;logspace\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;longcomplex\u0026#39;, \u0026#39;longdouble\u0026#39;, \u0026#39;longfloat\u0026#39;, \u0026#39;longlong\u0026#39;, \u0026#39;lookfor\u0026#39;, \u0026#39;ma\u0026#39;, \u0026#39;mafromtxt\u0026#39;, \u0026#39;mask_indices\u0026#39;, \u0026#39;mat\u0026#39;, \u0026#39;math\u0026#39;, \u0026#39;matrix\u0026#39;, \u0026#39;matrixlib\u0026#39;, \u0026#39;max\u0026#39;, \u0026#39;maximum\u0026#39;, \u0026#39;maximum_sctype\u0026#39;, \u0026#39;may_share_memory\u0026#39;, \u0026#39;mean\u0026#39;, \u0026#39;median\u0026#39;, \u0026#39;memmap\u0026#39;, \u0026#39;meshgrid\u0026#39;, \u0026#39;mgrid\u0026#39;, \u0026#39;min\u0026#39;, \u0026#39;min_scalar_type\u0026#39;, \u0026#39;minimum\u0026#39;, \u0026#39;mintypecode\u0026#39;, \u0026#39;mirr\u0026#39;, \u0026#39;mod\u0026#39;, \u0026#39;modf\u0026#39;, \u0026#39;msort\u0026#39;, \u0026#39;multiply\u0026#39;, \u0026#39;nan\u0026#39;, \u0026#39;nan_to_num\u0026#39;, \u0026#39;nanargmax\u0026#39;, \u0026#39;nanargmin\u0026#39;, \u0026#39;nanmax\u0026#39;, \u0026#39;nanmean\u0026#39;, \u0026#39;nanmin\u0026#39;, \u0026#39;nanstd\u0026#39;, \u0026#39;nansum\u0026#39;, \u0026#39;nanvar\u0026#39;, \u0026#39;nbytes\u0026#39;, \u0026#39;ndarray\u0026#39;, \u0026#39;ndenumerate\u0026#39;, \u0026#39;ndfromtxt\u0026#39;, \u0026#39;ndim\u0026#39;, \u0026#39;ndindex\u0026#39;, \u0026#39;nditer\u0026#39;, \u0026#39;negative\u0026#39;, \u0026#39;nested_iters\u0026#39;, \u0026#39;newaxis\u0026#39;, \u0026#39;newbuffer\u0026#39;, \u0026#39;nextafter\u0026#39;, \u0026#39;nonzero\u0026#39;, \u0026#39;not_equal\u0026#39;, \u0026#39;nper\u0026#39;, \u0026#39;npv\u0026#39;, \u0026#39;number\u0026#39;, \u0026#39;obj2sctype\u0026#39;, \u0026#39;object\u0026#39;, \u0026#39;object0\u0026#39;, \u0026#39;object_\u0026#39;, \u0026#39;ogrid\u0026#39;, \u0026#39;ones\u0026#39;, \u0026#39;ones_like\u0026#39;, \u0026#39;outer\u0026#39;, \u0026#39;packbits\u0026#39;, \u0026#39;pad\u0026#39;, \u0026#39;partition\u0026#39;, \u0026#39;percentile\u0026#39;, \u0026#39;pi\u0026#39;, \u0026#39;piecewise\u0026#39;, \u0026#39;pkgload\u0026#39;, \u0026#39;place\u0026#39;, \u0026#39;pmt\u0026#39;, \u0026#39;poly\u0026#39;, \u0026#39;poly1d\u0026#39;, \u0026#39;polyadd\u0026#39;, \u0026#39;polyder\u0026#39;, \u0026#39;polydiv\u0026#39;, \u0026#39;polyfit\u0026#39;, \u0026#39;polyint\u0026#39;, \u0026#39;polymul\u0026#39;, \u0026#39;polynomial\u0026#39;, \u0026#39;polysub\u0026#39;, \u0026#39;polyval\u0026#39;, \u0026#39;power\u0026#39;, \u0026#39;ppmt\u0026#39;, \u0026#39;print_function\u0026#39;, \u0026#39;prod\u0026#39;, \u0026#39;product\u0026#39;, \u0026#39;promote_types\u0026#39;, \u0026#39;ptp\u0026#39;, \u0026#39;put\u0026#39;, \u0026#39;putmask\u0026#39;, \u0026#39;pv\u0026#39;, \u0026#39;r_\u0026#39;, \u0026#39;rad2deg\u0026#39;, \u0026#39;radians\u0026#39;, \u0026#39;random\u0026#39;, \u0026#39;rank\u0026#39;, \u0026#39;rate\u0026#39;, \u0026#39;ravel\u0026#39;, \u0026#39;ravel_multi_index\u0026#39;, \u0026#39;real\u0026#39;, \u0026#39;real_if_close\u0026#39;, \u0026#39;rec\u0026#39;, \u0026#39;recarray\u0026#39;, \u0026#39;recfromcsv\u0026#39;, \u0026#39;recfromtxt\u0026#39;, \u0026#39;reciprocal\u0026#39;, \u0026#39;record\u0026#39;, \u0026#39;remainder\u0026#39;, \u0026#39;repeat\u0026#39;, \u0026#39;require\u0026#39;, \u0026#39;reshape\u0026#39;, \u0026#39;resize\u0026#39;, \u0026#39;restoredot\u0026#39;, \u0026#39;result_type\u0026#39;, \u0026#39;right_shift\u0026#39;, \u0026#39;rint\u0026#39;, \u0026#39;roll\u0026#39;, \u0026#39;rollaxis\u0026#39;, \u0026#39;roots\u0026#39;, \u0026#39;rot90\u0026#39;, \u0026#39;round\u0026#39;, \u0026#39;round_\u0026#39;, \u0026#39;row_stack\u0026#39;, \u0026#39;s_\u0026#39;, \u0026#39;safe_eval\u0026#39;, \u0026#39;save\u0026#39;, \u0026#39;savetxt\u0026#39;, \u0026#39;savez\u0026#39;, \u0026#39;savez_compressed\u0026#39;, \u0026#39;sctype2char\u0026#39;, \u0026#39;sctypeDict\u0026#39;, \u0026#39;sctypeNA\u0026#39;, \u0026#39;sctypes\u0026#39;, \u0026#39;searchsorted\u0026#39;, \u0026#39;select\u0026#39;, \u0026#39;set_numeric_ops\u0026#39;, \u0026#39;set_printoptions\u0026#39;, \u0026#39;set_string_function\u0026#39;, \u0026#39;setbufsize\u0026#39;, \u0026#39;setdiff1d\u0026#39;, \u0026#39;seterr\u0026#39;, \u0026#39;seterrcall\u0026#39;, \u0026#39;seterrobj\u0026#39;, \u0026#39;setxor1d\u0026#39;, \u0026#39;shape\u0026#39;, \u0026#39;short\u0026#39;, \u0026#39;show_config\u0026#39;, \u0026#39;sign\u0026#39;, \u0026#39;signbit\u0026#39;, \u0026#39;signedinteger\u0026#39;, \u0026#39;sin\u0026#39;, \u0026#39;sinc\u0026#39;, \u0026#39;single\u0026#39;, \u0026#39;singlecomplex\u0026#39;, \u0026#39;sinh\u0026#39;, \u0026#39;size\u0026#39;, \u0026#39;sometrue\u0026#39;, \u0026#39;sort\u0026#39;, \u0026#39;sort_complex\u0026#39;, \u0026#39;source\u0026#39;, \u0026#39;spacing\u0026#39;, \u0026#39;split\u0026#39;, \u0026#39;sqrt\u0026#39;, \u0026#39;square\u0026#39;, \u0026#39;squeeze\u0026#39;, \u0026#39;std\u0026#39;, \u0026#39;str\u0026#39;, \u0026#39;str_\u0026#39;, \u0026#39;string0\u0026#39;, \u0026#39;string_\u0026#39;, \u0026#39;subtract\u0026#39;, \u0026#39;sum\u0026#39;, \u0026#39;swapaxes\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;take\u0026#39;, \u0026#39;tan\u0026#39;, \u0026#39;tanh\u0026#39;, \u0026#39;tensordot\u0026#39;, \u0026#39;test\u0026#39;, \u0026#39;testing\u0026#39;, \u0026#39;tile\u0026#39;, \u0026#39;timedelta64\u0026#39;, \u0026#39;trace\u0026#39;, \u0026#39;transpose\u0026#39;, \u0026#39;trapz\u0026#39;, \u0026#39;tri\u0026#39;, \u0026#39;tril\u0026#39;, \u0026#39;tril_indices\u0026#39;, \u0026#39;tril_indices_from\u0026#39;, \u0026#39;trim_zeros\u0026#39;, \u0026#39;triu\u0026#39;, \u0026#39;triu_indices\u0026#39;, \u0026#39;triu_indices_from\u0026#39;, \u0026#39;true_divide\u0026#39;, \u0026#39;trunc\u0026#39;, \u0026#39;typeDict\u0026#39;, \u0026#39;typeNA\u0026#39;, \u0026#39;typecodes\u0026#39;, \u0026#39;typename\u0026#39;, \u0026#39;ubyte\u0026#39;, \u0026#39;ufunc\u0026#39;, \u0026#39;uint\u0026#39;, \u0026#39;uint0\u0026#39;, \u0026#39;uint16\u0026#39;, \u0026#39;uint32\u0026#39;, \u0026#39;uint64\u0026#39;, \u0026#39;uint8\u0026#39;, \u0026#39;uintc\u0026#39;, \u0026#39;uintp\u0026#39;, \u0026#39;ulonglong\u0026#39;, \u0026#39;unicode\u0026#39;, \u0026#39;unicode0\u0026#39;, \u0026#39;unicode_\u0026#39;, \u0026#39;union1d\u0026#39;, \u0026#39;unique\u0026#39;, \u0026#39;unpackbits\u0026#39;, \u0026#39;unravel_index\u0026#39;, \u0026#39;unsignedinteger\u0026#39;, \u0026#39;unwrap\u0026#39;, \u0026#39;ushort\u0026#39;, \u0026#39;vander\u0026#39;, \u0026#39;var\u0026#39;, \u0026#39;vdot\u0026#39;, \u0026#39;vectorize\u0026#39;, \u0026#39;version\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;void0\u0026#39;, \u0026#39;vsplit\u0026#39;, \u0026#39;vstack\u0026#39;, \u0026#39;warnings\u0026#39;, \u0026#39;where\u0026#39;, \u0026#39;who\u0026#39;, \u0026#39;zeros\u0026#39;, \u0026#39;zeros_like\u0026#39;] /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/__init__.pyc from import는 package나 module에 있는 것들을 모두 객체 생성한다. 즉 import numpy라고 하면 numpy라는 객체가 생성되고 그 내부에는 수많은 객체도 생성이된다. 이것은 memory낭비다. 그래서 from을 사용한다. from의 사용방법은 다음과 같다.\nfrom [module] import [변수,클래스,함수] module에 있는 모든 객체를 생성하지 않고, 일부만 객체를 생성해서 사용한다. from을 사용하면, module을 객체로 만드는게 아니다. 따라서 import로 만들어지는 객체를 그대로 code내에서 사용할 수 있다. 예를들면, pi,sqrt method를 그대로 사용할 수 있다.\nfrom math import pi,sqrt pi sqrt(3.0) ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary1\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/test_page1\/": {
        "title": "test_page1",
        "tags": [],
        "content": "test this is test\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/test_page1\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/emacs_jupyter_noteboo_settings\/": {
        "title": "[emacs] jupyter notebook settings",
        "tags": [],
        "content": "python, ipython, jupyter notebook, google colab이란? python의 동작방식 python은 interpreter와 compiler 두가지 모드가 있다. interpreter는 REPL(Read Evaluate Print Loop)로 동작한다. shell에서 typing한 code가 interpreter의 입력이 되고, 입력된 code는 실행되서 결과를 다시 shell로 보낸다.\nFigure 1: python 동작구조\nshell과 python은 local system에서 수행된다.\nipython과 ipython notebook python이 개발된 이후에 ipython이란것도 비슷한 시기에 개발되었다. ipython은 interactire python이라는 뜻인데, interactive는 주고 받는다는 뜻이다. code를 python한테 주면 실행하고 그 결과를 다시 받는 구조는 python의 interpreter의 동작방식과 다르지 않다. 차이가 있다면 socket을 사용해서 원격에 있는 python interpreter와 주고 받을 수 있다는 것이다. 그리고 입력방식도 차이가 있다. shell에서 입력받는 code가 아니라, cell이라는 단위로 입력 받는다. 이렇게 한 이유는 literate programming을 하기 위해서이다. literate programming은 org모드에서 code-babel을 생각하면 된다. 그래서 notebook파일을 제공한다. notebook 파일은 json구조로 되어 있어서, web page처럼 browser에서 읽을 수 있다. code가 입력되는 cell과 text를 입력하는 cell이 web page에 있다고 봐도 된다. org 파일의 웹버전 같은 느낌이다.\n여튼 요약하면 browser에서 notebook을 열고 notebook에 code를 cell단위로 입력하고 원격에 있는 server에 연결해서 python을 실행시키는 구조다. jupyter나 google colab이나 동일한 방식이다. colab은 server가 google cloud에 있다. gpu가 있는 compute engine을 사용할 수 있다. client는 local의 browser이지만, notebook은 google drive에 있는 notebook을 사용한다. 반면 jupyter는 open source이고 범용적이라서 default로 local의 server와 local의 file system에 notebook을 사용한다. client로 browser를 이용하는건 동일하다.\n아래는 좀더 jupyter와 colab에 대해 적었는데, 동어반복 수준이다.\njupyter와 jupyter notebook jupyter는 project이름이다. jupyter라는 project가 뭔지는 jupyter 홈페이지에 나와 있다.\nProject Jupyter is a non-profit, open-source project, born out of the IPython Project in 2014 as it evolved to support interactive data science and scientific computing across all programming languages. Jupyter will always be 100% open-source software, free for all to use and released under the liberal terms of the modified BSD license. 요약하면 jupyter와 jupyter notebook은 ipython이 python에 대한 interpreter만 사용하는 것에 문제가 있다고 생각함. 여러 언어를 지원하기로 함. jupyter는 ruby나 R도 사용가능 하다. 인터페이스만 제공하는 형태로 변경한 것이다. 인터페이스를 kernel이라고 부른다. jupyter notebook도 server client 구조로 되어 있다. browser가 client가 되어서 browser내에서 code cell을 입력하거나 notebook을 만들고, 각 cell을 ipython(kernel)의 입력으로 보내고, 실행한 결과를 다시 browser에게 보내게 된다. 위에서도 말했듯이 server client의 구조를 갖고, 원격에 서버가 있을수도 있고 local에 서버가 있을수도 있다. 구조는 다음과 같다.\nFigure 2: jupyter working\nGoogle colab google colab도 jupyter의 구조와 동일한 형태다. 그런데 programming언어는 python언어 하나만 사용 가능하다. google의 cloud와 gpu를 사용할 수 있다. 이말은 사용되는 notebook들이 local이 아닌 cloud에 저장되어 있고, python code를 실행하는 ipython(kernel)도 원격에 있으며, gpu를 사용할수 있다는 것이다. jupyter의 server가 jupyter server(hub)라는 이름으로 따로 있듯이, colab도 google colab server가 있다고 생각하면 된다. server가 따로 있다는 것은 python code를 실행할수 있는 kernel이 server에 있다는 말이다. 그리고,\n요약 말을 복잡하게 했는데, python과 달리, ipython, jupyter notebook, google colab은 아래 그림을 보면 직관적으로 이해할 수 있다. 우선 python을 보면 다음과 같다. shell에서 명령을 내리면 local에 있는 python interpreter가 실행해서 결과값을 보여준다.\nFigure 3: python\nFigure 4: jupyter notebook explorer\nbrowser에서 notebook을 선택할 수 있다.\nFigure 5: jupyter notebook\nnotebook을 선택하면 위와 같이 code와 text가 섞여있는 문서가 나온다. 실행할 수 있는 code block을 cell이라고 부르며 cell을 실행하면 결과가 표시되는 문서다. python에서는 shell에서 code를 실행하고 실행결과도 shell에서 확인하지만, ipython계열은 browser에서 notebook의 cell을 실행하고 실행결과를 notebook에서 확인 한다. browser가 shell의 역할을 대신하는 것이다. python에서 shell은 local에 있는 python interpreter과 통신하지만, browser를 사용하는 ipython계열에서는 실제 실행되는 python interpreter(kernel)은 원격에 있을수 있다. colab은 GCE라는 원격 server에 python interpreter가 있다. 그래서 GCE라는 원격 server가 gpu가 있으면 gpu를 사용할수 있는것이다. 그런데 가만 보면, notebook이라는게 emacs의 org파일과 동일한 형태다. code와 text가 섞여있고, code를 실행할수도 있다. 이런 것을 literate programming이라고 한다. emacs가 browser를 대신해서 client역할을 할수 있어보인다. emacs에서 notebook list를 보여주고, notebook을 선택해서 code를 실행하고 결과도 확인할 수 있을꺼 같다. 또한 org와 비슷하다고 했으니, org문서를 .ipynb로 변환하거나 .ipytnb를 org로 변환하는게 가능해 보인다.\nemacs에서 notebook 사용 jupyter나 colab은 server\u0026amp;client구조고, browser가 client역할 을 한다. 원격에 있는 server에 접속해서 server가 가진 notebook list를 가져오고 notebook에 있는 code를 원격 server에 보내고, server가 실행한 결과를 browser에서 보여주는 것들은 emacs에서도 가능하다. 즉 emacs가 client역할 을 하는 것이다. emacs에서 원격서버에 접속해서 notebook list를 가져오고 code를 원격에 보내고 결과를 emacs buffer에 보여주는 것이 가능하다. 이것을 가능케하는게 ein이라는 package 이다. 또한 .ipynb라는 notebook과 org파일들은 구조가 거의 같다. 그래서 org파일을 ipynb로 변환하고 ipynb를 org로 변환할 수 있는데, 이때 ox-ipynb 라는 package를 사용할 수 있다.\nox-, ob- package들 참고로 emacs에서 ox-, ob-라는 prefix를 갖는 package들은 특정 기능을 수행한다. ox-는 org 문서변환을 하는 package들이다. 예를 들어서, ox-latex는 org문서를 latex문서로 변환한다. ox-md도 org문서를 md파일로 변환을 한다. 그리고 ob-로 시작하는 package들은 babel과 관련이 있다. ob- package는 code block에서 실행할 수 있게 해준다. 예를 들어서, ob-ruby는 code block을 실행할 때 ruby interpreter를 사용한다.\nein package ein을 사용하면, browser로 notebook list를 보고 notebook을 실행하듯이 emacs에서 할 수 있다고 보면 된다. 그렇게 하기 위해선, browser가 원격 server와 접속해서 하는것처럼 emacs도 ein을 사용해서 서버에 접속한 후, notebook list를 가져오고, 가져온 notebook을 열어서 code cell을 실행할 수 있다. ein이 설치되어 있다면, .ipynb를 가진 파일을 dired에서 열면, browser처럼 notebook이 emacs에서 보여질것이라고 생각한다. 그런데 아쉽게도 .ipynb파일을 선택해도 notebook이 보여지지 않는다. json 파일이 열린다. ein에서 notebook을 browser럼 보려면, 다음과 같이 해야 보인다.\nM-x ein:run 현재경로 위와 같이 ein:run으로 server에 접속하면, browser처럼 list를 가져오는 화면이 보이고, 그 화면에서 ipynb를 선택하면 browser에서 봤던것처럼 notebook이 보인다. 이것은 emacs에서 .ipynb파일에 대한 mode를 만들어서 ui를 만들지 않는다는것을 의미한다. 즉 emacs는 jupyter server를 실행시키고, 실행된 jupyter와 tramp로 통신하면서 jupyter server가 만든 notebook list화면을 가져와서 그대로 보여줄 뿐이다. notebook을 선택하면 선택된 notebook정보를 server에 보내면 notebook화면을 고스란히 emacs에게 전달해주고 emacs는 보여줄 뿐이다. 따라서 emacs에서 확장자가 .ipynb를 dired모드에서 click한다고 해서 notebook이 보이지 않는다. 이건 좀 실망이긴 하다. inferior mode는 맘에 들지 않기 때문이다.\nFigure 6: ein notebook\n(use-package ein :ensure t) 사용법 jupyter처럼 현재 위치에서 실행 console에서 jupyter notebook하면 현재 경로에 대해서 browser가 notebook list목록을 보여주듯이 ein에서도 그렇게 할 수 있다.\nM-x ein:run google colab 사용하듯이 browser에서 google colab에 url 연결하면, notebook list를 가져온다. emacs에서도 가능할까? google drive나 colab에 연결하려면 oauth로 토큰을 받아서 사용해야 하는데, 이상하게 google의 project설정화면은 hang on상태다.\nM-x ein:notebooklist-login url: https://colab.research.google.com ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/emacs_jupyter_noteboo_settings\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/english1\/": {
        "title": "daily영어(1)-don\u0027t pet my puppy",
        "tags": [],
        "content": "Dear Annie audio-file 1 내 강아지는 비글 라브라도 리트리버의 mix입니다. 1살이며, 강아지가 하는 모든 것을 합니다.\nMy puppy, a beagle/Labrador mix, is 1 year old and does everything puppies do.\n2 그녀는 매력적입니다. 보는 사람들을 멈추게 만드는 매력이 있습니다. 그녀를 보면 내 마음이 녹아내립니다.\nShe\u0026rsquo;s adorbs. She\u0026rsquo;s a traffic-stopper. My heart melts when I see her.\n3 하지만 그녀는 집 안에서 볼일을 보고, 모든 것을 깨물고, 끝없이 에너지를 뿜어내고 있습니다. 강아지는 아직 훈련 중이며 적어도 1년 이상은 훈련을 받을 것입니다.\u0026quot;\nBut she also does her business in the house, chews on everything and has seemingly endless amounts energy. She is still in training and will be in training for another year -at least.\n4 우리가 지금 하고 있는것(애쓰는것)은 강아지가 사람들에게 뛰어 올라붙지 않도록 하는 것입니다. 강아지가 뛰기 시작하면, 강아지가 멈출 때까지 돌아서서 그녀를 무시합니다. 이것을 집에서 할때는 잘 합니다.\nOne of things we\u0026rsquo;re working on is getting her to stop jumping up on people. If she starts to jump, I\u0026rsquo;m supposed to turn around and ignore her until she stops. I do this at home and it works well.\n5 하지만 강아지와 산책을 할 때마다, 낯선 사람들은 그녀가 얼마나 귀여운지 보고 만지고 싶어합니다.\nBut whenever I take her for walks, strangers see what a cutie she is and want to pet her.\n6 그들이 강아지에가 다가가면 강아지는 점프합니다. 그러면, 그들은 내가 싫어하는 그 전형적인 문구를 말합니다: \u0026ldquo;괜찮아요. 괜찮아요\u0026rdquo;.\nWhen they approach her and she jumps, they say that typical phrase I\u0026rsquo;ve come to hate: \u0026ldquo;Oh, It\u0026rsquo;s ok. I don\u0026rsquo;t mind.\u0026rdquo;\n7 이러한 사람들 때문에 내가 매우 좌절합니다. 그리고 나는 \u0026ldquo;하지만 나는 그렇지 않아요!\u0026rdquo; 라고 따지기 시작합니다.\nI get so frustrated with these people. I find myself snapping back at them, \u0026ldquo;But I do!\u0026rdquo;\n8 나는 이렇게 하는 모든 사람에게 인내심을 갖고 대하기 어렵습니다. 이러한 상황이 매번 발생할 때마다, 그것이 강아지의 훈련 과정을 망친다고 생각하기 때문이에요. 이제부터는 낯선 사람들에게 뭐라고 말해야 할지 모르겠습니다.\nI am having trouble being patient with every single person who does this, because I feel as though every time it happen, it ruins the progress of my pup\u0026rsquo;s training. I don\u0026rsquo;t know what to say to strangers anymore.\nDear Puppy 1 이제는 당신이 알파 독이 되어야 합니다.\nIt\u0026rsquo;s time for you to be the alpha dog.\n2 낯선 사람들과의 교류에서 당신의 강아지에 대한 지배력을 확립해야 합니다.\nYou must assert your dominance over your pup\u0026rsquo;s interactions with strangers.\n3 이런 사람들은 분명 강아지를 훈련한 적이 없을 것이다. 단지 강아지를 쓰다듬는 것 가지고 화를 내는 것을 보면 그들은 매우 혼란스러울 것입니다.\nThe people who are doing this have obviously never had to train a dog before, so they\u0026rsquo;re probably really confused when you snap at them - ostensibly just for petting your dog.\n4 문제가 시작되기 전에 주의 신호를 인식하고 문제가 되는 행동을 중단해야 합니다.\nRecognize the warning signs and stop the troublesome behavior before it starts.\n5 당신의 강아지를 끌어안고 싶어하는 낯선 사람이 다가오는 모습을 보면, \u0026ldquo;만져도 괜찮아요. 하지만 강아지가 점프하지 않도록 부탁드릴게요.\nThe next time you see an approaching stranger giving your dog that oh-my-gosh-let-me-hug-you look, say, \u0026ldquo;You can pet her, but she\u0026rsquo;s in training, so please don\u0026rsquo;t let her jump.\n6 점프를 하면, 등을 보여주세요\u0026rdquo; 라고 말해보세요. 당신이 능동적이고 주도적으로 상황을 미리 통제하는 지도자 역할을 수행해야 합니다.\nIf she does, turn your back on her.\u0026rdquo; You have to be proactive and take control of the situation early-like any good leader of the pack.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/english1\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/folding_test\/": {
        "title": "folding test1",
        "tags": [],
        "content": "folding test 아래를 누르세요. folding test2 ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/folding_test\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/folding_test2\/": {
        "title": "folding test2",
        "tags": [],
        "content": "folding test 아래를 누르세요. folding test1 ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/folding_test2\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture10-string\/": {
        "title": "lecture10-String",
        "tags": [],
        "content": "String의 기본 자연어 처리에 있어서 문자열은 매우 중요하다. regular expression이 매우 많이 쓰인다.\nstring의 특징 immutable 이다. 표기법: \u0026lsquo;\u0026rsquo;\u0026rsquo;, \u0026ldquo;\u0026rdquo;\u0026quot;, \u0026ldquo;, \u0026lsquo;를 사용해서 string literal을 표시 가능 여러줄의 string literal은 \u0026ldquo;\u0026rdquo;\u0026rdquo;,\u0026lsquo;\u0026lsquo;\u0026lsquo;을 사용하자. tuple과 string은 둘다 배열이다. 그래서 둘다 immutable하고, indexing이 가능하며, slicing이 가능하다. 이것들이 배열의 특징이기 때문이다. in과 not in이 가능하다. 예를 들어보자. print(\u0026#39;a\u0026#39; in \u0026#39;abc\u0026#39;) print(\u0026#39;asdf\u0026#39; in \u0026#39;asdf_asdf\u0026#39;) python에선 character set으로 unicode로 처리한다. 즉 모든 글자는 4byte를 사용한다. escape문자 escape문자란? escape문자란 벗어난 문자다. 벗어난다는게 무슨 말인가? 원래 용도에서 벗어나 다른용도로 사용된다는 뜻이다. 문자라는것은 문자열에 포함된다. 문자열에 포함되면, 화면에 보여질 수도 있고, file에 text로 저장이 될 수도 있다. 그런데 escape문자는 문자열에 포함되지 않는다. escape문자중에 os나 언어차원에서 공식적으로 정의된 형태의 문자가 있다. \\를 사용하지 않는 문자인데, meta문자라고 부르기도 한다. 따옴표도 meta문자다. 예를 들어보자. python이란 언어에선 문자열을 나타내기 위해서 따옴표같은 문자를 사용한다. 따옴표도 문자이기때문에 문자열에 포함되어야 하지만, 따옴표는 문자열에 포합되지 않는다. 문자열의 시작과 끝을 나타낸다. 문자이지만, 문자열에 포함되지않는 escape문자라서 그렇다. 다시 말해서,문자라는게 문자라는 용도에 벗어나 다른 용도로 정의되어 있다면, escape문자라고 한다. meta문자 이외의 escape문자들은 보통 \\를 붙인다.\nescape문자를 만드는 \\문자가 일반문자에 적용되면 escape문자가 되지만, escape문자에 적용되면 escape문자를 일반 문자로 만들어준다.\nprint(\u0026#34;this is \\\u0026#34; .\u0026#34;) \\ escape 문자도 자기 자신을 escape시켜서 문자열에 포함시킬 수 있다.\nprint(\u0026#34;this escape escape character \\\\\u0026#34;) python 환경에만 이런 문자가 있는건 아니다. os도에도 있고, system에도 있다. 파일을 editor에서 편집한다고 생각하자. 키보드의 문자키를 입력하면, 키보드에선 문자키에 해당하는 code값을 cpu에 보낸다. 문자키에 해당하는 code값이란 unicode와 같은 character set 테이블에 있는 숫자값을 뜻한다. 각각의 character set은 symbol과 숫자값을 가지고 있기 때문이다. cpu에선 입력된 문자 code를 display로 보낸다. 그리고,display에선 code에 일치하는 symbol그림을 화면에 보여준다. font가 있다면 font에 해당하는 symbol그림을 display에서 보여준다. 키보드 문자키로 작성되는 모든 문자들은 기본적으로 화면에 출력이 된다. 파일을 열었을때, 파일에 담긴 문자코드들은 화면에 글자로 보여져야하는 용도인데, escape문자들은 문자열에 포함되지 않은 문자라서 화면에 보여지지 않고 다른 용도로 사용될 수있다. 예를 들어, \\a라는 문자는 bell소리를 낸다. a라고 화면에 보이지 않는다. escape문자이기 때문이다. display device로 가지않고 sound device로 가기 때문이다.\nescape 문자의 예 python에서 사용되는 escape문자는 아래와 같은 예가 있다.\nprint(\u0026#39;\\\\ \u0026#39;) print(\u0026#39;\\\u0026#39; \u0026#39;) print(\u0026#39;\\\u0026#34; \u0026#39;) print(\u0026#39;\\b \u0026#39;) print(\u0026#39;\\n \u0026#39;) print(\u0026#39;\\t \u0026#39;) print(\u0026#39;\\e \u0026#39;) \\\\: back slash\n\\ enter: back slash : 화면에서 다음줄로 넘어가지만, newline이 생기지 않는다. 실제 저장될 때, newline이 없게된다.\n\u0026gt;\u0026gt;\u0026gt; 이렇게 적으면 \\enter \u0026gt;\u0026gt;\u0026gt; 엔터없이 \\enter \u0026gt;\u0026gt;\u0026gt; 여러줄을 적어요. \\enter \u0026gt;\u0026gt;\u0026gt; \u0026#39;이렇게 적으면 엔터없이 여러줄을 적어요\u0026#39; \\b: backspace\n\\n: newline: 문자열에 newline이 있으면, 무조건 newline이 해석되는 게 아니다.\nFigure 1: text eval\nrepl에선 text에 escape문자가 있다고 해서 evaluate되지 않는다. 하지만, 변수에 있는 문자열은 evaluate되기 때문에 newline이 해석된다. 이것은 repr()함수가 동작하기 때문이다. repr()는 built-in function이다. repr()는 escape문자를 그대로 출력한다. 따라서, repr()로 return된 값은 escape문자를 포함한 문자열을 return하기 때문에 print해도 escape문자가 출력된다. repr() 표현된 문자열은 string이 아닌 representation이라고 부른다고 한다. string은 formatting을 할수 있지만, representation은 formatting을 할 수 없다고 한다.\ntext =\u0026#34;This is \\nNewline\u0026#34; print(repr(text)) repr()는 class객체를 출력할 때도 볼 수 있다.\nclass A: pass a = A() print(a) 객체를 출력할때, str()를 overriding해서 string을 출력하게 할수도 있지만, repr()을 overriding해서 위와 같은 문자열을 출력하게 할 수도 있다.\n\\t: tab\n\\e: esc\nraw string repr()가 escape문자를 해석하지 않고 original 그대로 가지고 있다면, raw string도 escape문자를 string literal로 취급하는데, 약간 trick을 사용한다. 즉 escape문자에 \\를 덧붙이면 escape 문자가 출력이 된다. 그래서 마치 escape문자를 문자 그대로 출력하는것 처럼 보이게 만든다. 아래의 예를 보면, repr()에서 escape문자가 포함된 문자를 출력하는것과 raw string으로 표현된 문자열의 출력을 repr()로 보면 original string모습을 확인 할 수 있다.\n참고로 raw string은 r이라는 symbol을 string앞에 붙인다.\nstring = \u0026#34;여기서 \\n은 escape문자다.\u0026#34; print(repr(string)) print(string) raw_string = r\u0026#34;여기서 \\n은 string literal이다.\u0026#34; print(repr(raw_string)) print(raw_string) raw string이 사용되는 경우는 escape문자가 그대로 출력되야 하는 경우에 raw string을 사용하면 편하다. 예를 들어보자.\nlocate = \u0026#34;c:\\\\users\\\\test\u0026#34; print(locate) locate = r\u0026#34;c:\\users\\test\u0026#34; print(locate) 첫번째는 경로 문자열을 그대로 표현해야 한다. string을 사용할 경우, \\을 하나씩 더 붙여야 문자경로명이 표시된다. raw string을 사용할 경우 경로와 같은 escape문자를 그대로 출력해야 할때, 그대로 사용하면 된다. 굳이 원본 text에 \\을 붙일 필요가 없다. 예를 들어, ebook에 \\를 사용한 단어들이 많이 나왔을때, string으로 취급해서 처리할려면, ebook의 모든 \\ 글자를 찾아서 \\를 추가해야만 \\가 출력이 가능하다. 하지만, raw string은 그런 pre-processing을 할 필요가 없다.\nString의 기본 methods 기본 methods len(string) 문자의 길이를 반환한다.\ntext =\u0026#39;this is sentence\u0026#39; print(len(text)) string.upper() 대문자로 변환한다.\ntext = \u0026#34;this is string\u0026#34; print(text.upper()) string.lower() 소문자로 변환한다.\ntext = \u0026#34;this is string\u0026#34; print(text.lower()) string.capitalize() 시작 문자를 대문자로 변환\ntext = \u0026#34;this is string\u0026#34; print(text.capitalize()) string.title() 단어의 시작을 대문자로 변환한다.\ntext = \u0026#34;this is string\u0026#34; print(text.title()) string 공백 제거 methods 크롤링할때 공백을 제거할 일이 많다.\ntext = \u0026#39; 공백이 \\t 있어요. \\t\\n \u0026#39; print(text) print(text.strip()) print(text.rstrip()) print(text.lstrip()) string.strip() 좌우의 공백을 제거한다.\nstring.lstrip() 왼쪽 공백을 제거한다.\nstring.rstrip() 오른쪽 공백 제거한다.\n문자열 check predicate print(\u0026#39;12345\u0026#39;.isdigit()) print(\u0026#39;1.23e-5\u0026#39;.isdigit()) print(\u0026#39;Capitalize\u0026#39;.isupper()) print(\u0026#39;lower_case\u0026#39;.islower()) string.isdigit() string이 0-9사이의 숫자형태인지 확인한다. 위의 예를 보면, e를 사용한 지수형태가 있는데 이것은 digit이 아니다.\nstring.isupper() 모든 문자가 대문자로 이루어져 있는지 확인한다.\nstring.islower() 모든 문자가 소문자로 이루어져 있는지 확인한다.\nString Pattern matching pattern이 문자열에 있는지 궁금할 수도 있고, 있다면 어디에 있는지 알고 싶을 때 pattern matching함수를 사용한다. pattern이 있는지 없는지 여부는 in을 사용해도 된다.\ntext = \u0026#39;abc_text_abc_ee\u0026#39; pattern = \u0026#39;abc\u0026#39; print(text.count(pattern)) print(text.find(pattern)) print(text.rfind(pattern)) print(text.startswith(pattern)) print(text.endswith(pattern)) string.count(pattern) string 문자열내에 pattern의 occurs 반환\nstring.find(pattern) string 문자열 내에서 pattern을 find해서 첫 occur의 index반환\nstring.rfind(pattern) string 문자열 내에서 pattern을 reversed(뒤에서부터) find한 첫 occur의 index반환\nstring.startswith(pattern) string이 pattern으로 시작하는지 확인\nstring.endswith(pattern) string이 pattern으로 끝나는지 확인\nsplit \u0026amp; join 프로그램을 짤 때, 프로그램의 기본 구조가 있다. 파일이나 외부 입력으로 sequence data(유한개)를 입력 받고 for-loop으로 하나하나 꺼내서 if로 처리한다. 이게 기본 구조다. 여기서, 입력으로 받은 sequence가 문자열이고, 우리는 for-loop으로 하나 하나 꺼내서 list에 넣는 처리를 하고 싶다. 어떻게 해야 할까? 이때, split()를 사용하면 for-loop과 if를 사용하지 않아도 된다. python에선 어떻게 하면 이 정형화된 for-loop과 if대신 함수로 간단화 할것인가?에 관심이 많다.\ntext = \u0026#39;한국어 abc 테스트 \\n abc 중 \\t 입니다\u0026#39; print(text.split()) print(text.split(\u0026#39;abc\u0026#39;)) print(\u0026#39; \u0026#39;.join(text.split())) print(\u0026#39;, \u0026#39;.join(str(i) for i in range(10))) string.split() string이 입력으로 들어왔을 때, 단어를 list로 넣는다. white space(space,newline,tab)을 제거후 split한다. for-loop으로 문자 하나하나 꺼내고 if로 white space 확인후 제거후 list에 넣는다. for-loop과 if를 사용하지 않게 해준다.\nstring.split(pattern) split에 인자가 없다면, white space(space,newline,tab)을 기준으로 제거하고 list에 넣는다면, 이것은 인자가 주어진다. 주어진 인자를 제거하고 list에 넣는다.\nstring.join(iterable) for loop와 if로 입력 data를 처리하는게 programming에서 입력데이터를 처리하는 기본 구조라고 했다. if로 조건에 맞는 data를 처리도 해야 한다. join은 split()로 if까지 해서 조건에 맞는 data를 list로 넣었다면, list에 대한 처리까지 한다. list의 item을 꺼내서 string을 덧붙여 최종적으로 string을 만들어 낸다.\nprint(\u0026#39; \u0026#39;.join(text.split())) print(\u0026#39;, \u0026#39;.join(str(i) for i in range(10))) 위의 예에서 보듯이 join은 iterable의 item을 꺼낸 후 뒤에 string에 해당하는 문자열을 붙여서 최종적으로 string을 return한다. 첫번째는 split()에 의해서 white space가 제거된 list에서 space를 item마다 추가한 문자열을 return한다. 여기서 추가된 건 space다. white space가 아니다.\nstring formatting program에서 string을 사용하는것은 string에서 어떤 값을 도출하기 위해서,즉 계산을 위해서 사용될 수도 있으나, 출력을 위해서 사용할 때도 있다. 화면에 출력한다거나, file에 로그기록을 남긴다던가, 이럴때 formatting이 필요하다. 알아보기 쉽게 string을 재작성하는 것이다. string literal을 사용하면 되지, 왜 재 작성이냐? 출력할 string은 string literal이 아닌, 변수,객체값을 표현해야 하기 때문이다. 객체의 값이나 변수의 값을 string에 포함시키기 위해선 재작성및 재처리가 필요하다. 예를 들어, 어떤 변수가 3.141592\u0026hellip; 엄청 긴값을 가지고 있을때, 이것을 그대로 파일에 저장한다거나 화면에 출력한다면 가독성이 떨어지게 된다. 그래서 formatting이 필요하다.\na,b,c = 10,1.725, \u0026#39;sample\u0026#39; print(str(a) + \u0026#34;: \u0026#34; + str(b) + \u0026#34; - \u0026#34; + c) print(\u0026#34;%d: %f - %s\u0026#34; % (a,b,c)) print(\u0026#34;{}: {} - {}\u0026#34;.format(a,b,c)) print(f\u0026#34;{a}: {b} -{c}\u0026#34;) % formatting 문자열에 변수나 객체값을 넣어서 string을 만들려고 하기때문에 변수나 객체를 제공하는 부분과, 변수값이나 객체가 위치할 placeholder를 포함한 string template이 있다. 변수나 객체는 뒤에 % tuple형태로 제공한다. placeholder는 %형태로 되어 있다. 미리 만들어준 string template에 %로 시작하는 placeholder를 넣어둔 꼴이다. placeholder안에서 값들을 formatting한다. formatting은 3-4가지 정도가 있다. 대표적인 padding,precision,datatype을 기술하는 ppd format은 가장 많이 쓰이는 formatting방식이다.\nplaceholder =\u0026gt; %[padding+datatype] placeholder =\u0026gt; %[align + padding + datatype] etc) -,+: align placeholder =\u0026gt; %[align + precision + padding + datatype] etc) -,+: align padding 설정 %-4d: 4칸의 padding을 만들고 값을 앞에서부터 넣는다. %4d: 4칸의 padding을 만들고 값을 뒤에서부터 넣는다. %04d: 4칸의 padding을 만들고 값을 뒤에넣고 빈공간은 0으로 채운다. print(\u0026#34;%d+%d+%d\u0026#34; % (1,10,100)) print(\u0026#34;%4d+%4d+%4d\u0026#34; % (1,10,100)) print(\u0026#39; 1+ 10+ 100\u0026#39;) print(\u0026#34;%-4d+%-4d+%-4d\u0026#34; % (1,10,100)) print(\u0026#34;%04d+%04d+%04d\u0026#34; % (1,10,100)) float를 위한 precision 설정 precision은 .을 붙여준다.\nprint(\u0026#34;%f+%f+%f\u0026#34; %(123.4,12.34,1.234)) print(\u0026#34;%.3f+%.3f+%.3f\u0026#34; %(123.4,12.34,1.234)) print(\u0026#34;%8.3f+%8.3f+%8.3f\u0026#34; %(123.4,12.34,1.234)) print(\u0026#34;%08.3f+%08.3f+%08.3f\u0026#34; %(123.4,12.34,1.234)) [datatype] %datatype a %s string %d int %f float %o octet %x hexa naming placeholder를 나타내는 %와 변수는 1:1 mapping한다고 했다. 이를 명확하게 해줄 수도 있다.\nprint(\u0026#34;%(first)5.2f - %(second)5.2f\u0026#34; % {\u0026#34;first\u0026#34;: 10.2, \u0026#34;second\u0026#34;: 5.62}) format() 함수 객체나 변수의 값을 string으로 만들어 출력한다고 했다. 이때 formatting을 해서 string을 만든다고 했다. format()함수도 formatting하는 함수다. % formatting은 %로 변수값을 제공했다면, format()는 인자에 변수값을 제공한다. 그리고 만들고 싶은 형태의 string format은 미리 만들고, placeholder를 만드는 방식은 % formatting과 다를 바 없다. 다만 placeholder를 포함한 string template이 좀 다르다. %formatting은 placeholder가 %로 시작했다면, format()는 string template안에 들어가는 placeholder가 {}같은 형태다. {}는 변수와 1:1 mapping된다. mapping된 변수에 대한 formatting작업이 일어난다.\npositioning (순서 설정) {}와 변수는 1:1 mapping된다. mapping 순서를 바꿀 수 있다.\na,b,c = 10,1.725,\u0026#39;sample\u0026#39; print(\u0026#34;{}: {} - {}\u0026#34;.format(a,b,c)) print(\u0026#34;{0}: {1} - {2}\u0026#34;.format(a,b,c)) print(\u0026#34;{0}: {2} - {1}\u0026#34;.format(a,b,c)) 순서 설정은 변수와 placeholder가 mapping되는 순서를 바꿔줄 수 있다는 것이다. 마치 index같다. % formatting에는 없는 방법이다.\npadding \u0026amp; precision \u0026amp; datatype 설정 format()함수도 placeholder에서 padding과 float를 위한 precision, datatype을 넣어 줄 수 있다.\nprint(\u0026#34;{0}+{1}+{2}\u0026#34;.format(123.4, 12.34, 1.234)) print(\u0026#34;{0:.3f} + {1:.3f} +{2:.3f}\u0026#34;.format(123.4, 12.34, 1.234)) print(\u0026#34;{:8.3f}+{:8.3f}+{:8.3f}\u0026#34;.format(123.4, 12.34, 1.234)) naming 각각의 placeholder와 각각의 변수들이 1:1 mapping된다고 했다. format()에서는 index를 사용해서 placeholder에서 구분이 가능했다. 그런데 mapping이 많아지면, naming을 쓰는 것이 더 효율적이다. 아래 예를 보면, kwargs형태가 나왔다. format()를 호출할때, parameter가 stack에 쌓아지는데, keyword:value의 형태를 한꺼번에 가져갈때, dictionary를 사용하고, **kwargs로 받는다고 했다. 비슷하게 dictionary를 string template이 받는다고 생각하면 될듯하다. 강사는 unpacking이라고 얘기한다.\nprint(\u0026#34;{first:5.2f} - {second:5.2f}\u0026#34;.format(first=10.2, second=5.62)) print(\u0026#34;{first:5.2f} - {second:5.2f}\u0026#34;.format(**{\u0026#34;first\u0026#34;: 10.2, \u0026#34;second\u0026#34;: 5.62})) f string 가장 많이 사용되는 방식이라고 한다. fstring은 % formatting이나 format()와 가장 큰 차이점은 string template만 존재한다는 것이다. 이전의 2가지 방식은 모두 placeholder가 포함된 string template과, 변수와 객체값을 나타내는 formatting provider가 존재했다. f string에선 string template만 존재한다.\npositioning a,b,c = 10,1.725,\u0026#39;sample\u0026#39; print(f\u0026#34;{a}: {b} - {c}\u0026#34;) print(f\u0026#34;{a}: {c} - {b}\u0026#34;) padding \u0026amp; precision \u0026amp; datatype value = 12.34 print(f\u0026#34;{value*10} +{value} + {value/10}\u0026#34;) print(f\u0026#34;{value*10:.3f} +{value:.3f} + {value/10:.3f}\u0026#34;) print(f\u0026#34;{value*10:8.3f} +{value:8.3f} + {value/10:8.3f}\u0026#34;) Regular Expression pattern을 찾는다는것. pattern이란 무엇인가? 규칙(regular)적인 형태, 반복적인 형태를 pattern이라고 말한다. 문자열뿐만 아니라 우리는 보는 모든것에서 본능적으로 pattern을 인식할 수 있다. 우리가 pattern이라고 생각하는것을 표현할 수 있을까? 표현할 수 있다면 어디에 쓸것인가?\npattern을 표현하는 방법, programming language에서 문자열에 나타내는 pattern을 표현하는 언어가 따로 있다. regular expression이라고 한다. 규칙적인 표현? pattern의 다른말에 불과하다. 즉 pattern을 나타내고자 한다면, regular expression을 사용하면 된다.\npattern을 regular expression으로 나타낸다면, 어디에 사용되는가 사용가치가 있는가?라는 질문이 있을 수 있다. 패턴을 나타내면 검색하는데 사용할 수 있다. 즉 어떤 문자열이 주어졌을때, 어떤 pattern이 있냐 없냐를 검색할 수도 있고, 검색된 내용을 바꿀수도 있다. regular expression이란 tool이 이것을 가능하게 해준다. for-loop과 if를 사용해서 이런 기능을 구현할 수도 있겠지만, regular expression이란 tool을 사용하면, 좀 더 쉽고, 막강하게 처리할 수 있다. 참고로 pattern은 일종의 set으로 봐도 된다. 강사는 실제적인 예로 다음 예를 설명한다.\n야 이거 #%이름#꺼 아니야? #%이름#에게 물어봐 #%이모티콘# 정보보호를 위해서 이름이나, 전화번호,주소, 특정내용은 blind되서 제공된다고 한다. 이런 경우 pattern을 찾고 replace하는 일이 빈번하게 일어난다. 이 경우 find(pattern)로 찾을 수 없다고 한다. find는 명시적인 문자열이여야 하는데,#%\u0026lt;임의의 문자열\u0026gt;#으로 명확하지 않은 pattern은 regular expression을 사용해야 한다고 한다.\nRegular expression 패턴 예시 \\d{3}\\-\\d{4}\\-\\d{4} 010-1234-5678 {1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3} 192.168.0.20 #%[^#]+# #%이모티콘# 정규식을 다룬다는건 양이 많다. 참조 사이트에서 연습을 하길 추천한다. Regular Expression 문법 meta character escape문자의 일종, escape문자는 원래 용도에서 벗어난 문자. 문자의 원래용도는 화면에 출력되거나 문자열에 포함되거나, data로서의 역할이다. meta문자는 \\를 사용하지 않는 escape문자로 보면된다. 다른곳에선, 문법적인 역할이 정해진 문자. pattern을 표현할 때, 사용하는 문자다.라고 정의하기도 한다.\n. ^ $ * + ? { } [ ] \\ | ( ) regular expression에서 위 문자들은 화면에 보이는 문자가 아니다. 특수한 의미를 가진 문자로 용도가 정해져 있다. literal character로 사용하려면 \\를 앞에 붙여 줘야 한다.\n^ meta 문자\n문자를 나타내지 않는다. line의 처음을 나타낸다.\n^a a aa aaa aaaa 1aaa 위에서 보면, 1aaa빼고 다 match된다.\n$ meta 문자\n문자를 나타내지 않는다. line의 끝을 나타낸다.\na$ a aa baa aabb a$는 line의 마지막글자가 a라는 것을 나타낸다. 따라서 aabb는 매치되지 않는다.\n/d meta 문자\n하나의 숫자를 나타내는 pattern이다.\n/w meta 문자\n한 문자를 나타내는 meta문자다. 한문자는 a-z,A-Z,0-9가 될 수 있다.\n/s meta 문자\nspace를 나타내는 meta문자다.\nmeta 문자.\nregular expression에서 []라는 문자를 보면, 다음과 같은 형태로 되어 있다.\n[a-z], [A-Z0-9] [\\d\\s] [ ]는 한 문자를 나타내는 pattern이다. 어떤 문자인지는 [ ] 내부에서 -로 표현한다. [A-Z0-9]는 A~Z이거나 0~9의 범위에 있는 문자를 의미한다. [\\d\\s]는 digit이거나 space이거나라는 범위를 나타낸다.\n[^ ] meta 문자\n^란 문자는 not을 의미한다. 즉 포함되지 않는 문자를 말한다. [^ ] 도 한 문자를 의미한다.\ndot(.) meta 문자\ndot 문자도 하나의 문자를 나타내는 pattern이다. [ ]는 range가 있다. 하지만 dot은 \\n을 제외한 모든 문자를 dot으로 나타낼 수 있다. white space도 포함한다.\n\\s...\\s pattern은 \u0026#34;abcd efg hij klmnop\u0026#34; =\u0026gt; efg, hij ? meta 문자\n[]이나 dot처럼 ?문자도 한문자를 대신하는 pattern이다. 한 문자를 대신하는 pattern이 3개 이지만, 한문자를 cover하는 범위가 각기 다르다. 예를 들어 []의 경우는 안에 range가 있다. 특정 range의 문자만 대신한다. 반면에 dot은 모든 문자1개를 대신할 수 있다. 그런데 ?는 범위가 더 넓다. 1개의 모든문자와 문자가 없는 경우도 대신한다.\n반복횟수 지정({}) meta문자\n이전에는 한개의 문자에 대한 pattern이였다. 한 문자에 대한 pattern은 강력하지 않을 수 있다. 아래에 나오는 반복을 나타내는 pattern과 같이 쓰인다면 강력한 pattern을 만들 수 있다.\n{3} -\u0026gt; 3번 반복 {3,} -\u0026gt; 3번이상 반복하는, 무한 반복을 나타낼수 있다. {2,5} -\u0026gt; 2번이상 반복 5번 이하 반복 되지 않는것. star(*) meta 문자\n문자를 나타내는 meta문자가 아니다. 앞의 문자의 횟수를 나타내는 meta문자다. 0번 이상 무한 반복을 나타내는 pattern이다. 예를 들어서,\nab* pattern은 a,ab, abb, abbb, abbb... 앞의 문자인 b의 0번부터 무한까지의 반복된 문자 pattern을 나타낼 수 있다.\nmeta 문자 +도 문자를 나타내는 meta문자가 아니다. 앞문자의 횟수를 나타내는 meta문자다. 단 1회 이상의 반복을 해야하기 때문에 *와는 다르다.\nab+ pattern은 ab, abb, abbb, abbb... start와 + meta 문자의 문제점\n+와 *를 사용해서 pattern을 만들고, 만든 pattern으로 특정 text를 검색할 때 문제가 생길 수 있다. 우리가 원하는 문자열 검색이 안될 수 있다.\n예를 들어서 #%을 prefix로 갖고, #을 postfix로 갖는 pattern을 만들었다고 하자.\n#%.*# .*는 prefix와 postfix의 문자열이다. 무한개의 가능한 문자열이 들어갈수 있다. prefix와 postfix만 맞으면 된다. 이 pattern으로 아래 text를 검색해 보자.\n#% 테스트입니다.# 정말로 #% test일까요?# 결과는\n#% 테스트입니다.# 정말로 # 우리가 원한 결과는 아래였다.\n#% 테스트입니다.# 많이 다르다. 왜냐하면 *나 +의 앞문자 무한반복 가능한 pattern의 경우, greedy하다. 즉 prefix와 postfix가 일치해도, 남은 text중에 postfix가 일치하면, 더 긴 검색결과를 return하기 때문이다. 이것을 막기위해서 다음과 같은 방식을 사용할 수도 있다.\n#%[^#]+# 즉 prefix와 postfix안에 #이라는 문자가 있는 경우 제외시킨다. 이러면 우리가 원한 결과를 얻을 수 있다. 이 방식 말고도 lazy matching pattern을 사용할 수도 있다. 선호하는 방식은 위의 방법이 더 선호된다고 한다.\nlazy matching pattern\n위에서 +나 *를 사용한 pattern들은 우리가 원했던 의도로 검색이 안됐다. 안된 이유는, 가장 긴 pattern을 찾기 때문이라고 했다. greedy하다. 그래서 검색을 할때 만족하는 가장 긴 pattern이 아닌 가장 짧은 pattern을 검색하게 하려면, lazy하게 만들어야 한다. 게을러지면, 짧아도 만족만 되면 멈추기 때문이다. 그것을 lazy matching pattern이라고 부른다고 한다. 아래와 같은 pattern을 만들었다.\n\u0026lt;.+\u0026gt; prefix인 \u0026lt;과 postfix인 \u0026gt; 사이에, 무한한 문자(.+)가 올수 있는 경우다. 이것은 *와 +를 사용할 때의 문제점을 보여주고자 함이다. 아래의 문자열을 검색해 보자.\nThis is a \u0026lt;div\u0026gt; simple div\u0026lt;/div\u0026gt; test 검색 결과는 다음과 같다.\n\u0026lt;div\u0026gt; simple div\u0026lt;/div\u0026gt; 우리가 원하는 결과는 앞의 \u0026lt;div\u0026gt; 와 뒤의 \u0026lt;div\u0026gt;를 찾고 싶었던 건데, 원하는 결과가 안나왔다. 즉 pattern을 만족하는 가장 긴 문자열을 찾았기 때문이다. 이것을 lazy pattern으로 만든다면, 다음과 같다.\n\u0026lt;.+?\u0026gt; +나 *뒤에 ?를 하면 lazy pattern이 되는 것이다. lazy pattern을 사용하면 원하는 검색결과를 얻을 수 있다고 한다. 하지만, 선호되지 않는다고 한다. 그래서 보통은 다음과 같이 사용한다고 한다.\n\u0026lt;[^\u0026gt;]+\u0026gt; \u0026lt; \u0026gt; 사이에 문자들이 오는데, \u0026gt;을 포함하면 안된다는 뜻이다.\n선택(|) meta 문자\n\u0026lsquo;|\u0026rsquo; meta 문자는 두개의 pattern을 사용할 수 있게 해준다. 예를 들어 보자.\n010-1234-5678 +82-010-1234-1234 +81-42-1234-5678 024-23-4321 위 전화번호중에 010으로 시작하고, +82로 시작하는 전화번호만 검색하려고 한다. 이때 2개의 pattern을 만들고 |을 사용하면 된다.\n(0 | \\+82)\\d{1,2}-\\d{3,4}-\\d{4} Boundary meta 문자들\n\\b : 단어를 찾을 때 사용한다. 단어의 시작점을 의미\n\\babc this is not mabc but abc abc가 검색된다.\n^: 줄이나 문자열의 시작점\n^\\w+ This is sample. I like this. Life is short. 참고로 \\w 는 문자 하나를 나타내는 pattern이다. 각라인의 첫 단어를 검색하게 된다. 아래와 같은 것이 검색된다.\nThis, I, Life $: 줄의 끝에서 찾는다.\n$\\. 이것은 newline 바로 앞 단어에서 찾는다. 예제는 마침표를 찾는 것이다.\ncapturing group\ncapturing group: tomato같은 단어를 찾고 싶다면, one-to-one이란 단어를 찾고 싶다면, abdeab라는 단어를 찾고 싶다면 어떻게 해야할까?\ntomato, one-to-one, abcdebch 위 단어의 공통점은 prefix에 해당하는 문자들과 postfix에 해당하는 문자들이 동일하다는 것이다. 이것을 pattern으로 나타낼 수 있다면, 비슷한 단어들을 검색할 수 있을 것이다. 어떻게 pattern을 만들어야 할까? prefix는 capture하고, postfix는 numeric reference로 참조한다. capturing을 group화 한다고도 많이 말한다.\n우선 capture, numeric reference란 용어와 사용법을 알아야 한다. capture는 group으로 만들어 저장한다. 저장하는 방법과 capture된것을 사용하는 방법은 아래에 있다.\n(\\w)a\\1 hah bong dad bad dab gag gab 우선 pattern분석부터 해보자.\n\\w w는 한 문자다. [a-zA-Z0-9]와 같은 뜻이다. 즉 소문자이거나, 대문자이거나 digit인 한 문자다. 따라서 아래의 text에서 space를 제외한 모든 문자들이 하나 하나 다 선택된다.\nhah bong dad bad dab gag gab (\\w) 이것은 한문자가 선택되는 건 맞는데 capture된다. capture된다는건 기억된다는 것이고 기억하는 이유는 다시 사용하기 위함이다. number reference로 기억했던걸 다시 사용할 수 있다. 우선 한문자를 선택하는 건 변함이 없기 때문에 아래의 text 각각의 문자가 선택된다.\nhah bong dad bad dab gag gab 이제 한문자를 추가한 pattern을 만들자.\n(\\w)a 임의의 문자와 그 뒤에 a가 나오는 pattern을 만들었다. 이 pattern으로 아래의 text를 검색해보자.\nhah bong dad bad dab gag gab ha da ba da ga ga 위의것이 선택된다. 이제 numeral reference를 사용하자. 지금 capturing group은 1개밖에 없다. 따라서 \\1밖에 사용하지 못한다. 여튼 이 패턴을 text에 적용해보자. 즉 검색해보자.\n(\\w)a\\1 hah bong dad bad dab gag gab 결과는 어떻게 될까?\nhah dad gag 위와같이 된다. 작동 원리는 다음과 같다. 임의의 한문자뒤의 a로 된 2개의 문자, 그리고 capturing된 문자가 있는 3개의 문자를 text에서 찾아야한다. text를 보자. 첫 문자 \u0026lsquo;h\u0026rsquo;는 일치한다. 따라서 capturing한다. 이제 뒤의 문자를 보자. \u0026lsquo;a\u0026rsquo;가 있다. ok. 그 다음 문자는 h다. 우리의 pattern을 보면, \u0026lsquo;a\u0026rsquo;다음엔 capturing문자가 와야 한다. 즉,\\1에 의해 \u0026lsquo;h\u0026rsquo;문자가 와야 pass가 된다. \u0026lsquo;h\u0026rsquo;가 있다. 일치한다. 따라서 검색 완료. 그다음 space는 \\w에 해당하지 않기 때문에 pass한다. \u0026lsquo;b\u0026rsquo;는 \\w와 일치한다. 그런데 그 다음 \u0026lsquo;o\u0026rsquo;는 일치하지 않는다. \u0026rsquo;n\u0026rsquo;은 \\w와 일치한다. \u0026lsquo;g\u0026rsquo;가 일치하지 않는다. 그 다음은 space라서 \\w와 일치하지 않는다. d를 본다. \\w와 일치한다. d가 capturing된다. \u0026lsquo;a\u0026rsquo;문자를 본다. 일치한다. \u0026rsquo;d\u0026rsquo;문자가 나왔다. 이것은 capturing된 \u0026rsquo;d\u0026rsquo;와 일치한다. 따라서 검색이 완료된다. 이런식으로 계속 검색을 하는 것이다.\n위에서도 말했지만, prefix와 postfix가 같은 경우, capturing group을 사용하는게 굉장히 유용하다.\ncapturing group이 한개만 사용되는건 아니다. 2개도 사용될 수 있다. 2개가 사용되면, 2개를 기억하게 되고, 기억된 문자를 다시 numeric reference로 참조해서 사용하면 된다.\ncapturing(group) 간단 예제\nimport re m = re.match(\u0026#39;([0-9]+) ([0-9]+)\u0026#39;, \u0026#39;10 295 32 54\u0026#39;) print(m.group(1)) print(m.group(2)) print(m.group()) print(m.group(0)) print(m.groups()) 위의 pattern을 보면 2개의 group이 있다. 첫번째 group에 매치되는 문자열은 group(1)로 출력할 수 있고, 두번째 group에 매치되는 문자열은 group(2)에 출력할 수 있다. group()는 group이 몇개던 matching된 문자열을 return한다. group(0)도 group()과 같은 뜻이다. groups()는 tuple로 return한다.\nnon-capturing group\nnon-capturing group은 group이긴 한데, captuing을 하지 않는다. group()을 사용하는 이유는 우선순위를 갖기 때문이라고 한다. 사용법은 (?:)형태로 사용해야 한다. 자주 사용될지 모르겠다. 여튼 captuing은 하지 않는다. 다음과 같은 text가 있다고 하자. 여기서 010-1234-1234, +82-10-5678-5678과 같은 형태의 전화번호를 검색하고 싶다고 하자. pattern을 만들어야 한다.\n010-1234-1234 010-1234-5678 +82-10-5678-5678 +82-4123-1234 pattern을 어떻게 만들까? 5678로 나온게 뒤에 다시 5678로 나오고 1234로 나온게 뒤에 또 1234가 나온다. 이것은 capturing의 예이다. 우선 capturing만 적용시키면 다음과 같이 쓸수 있다.\n(\\d\\d\\d\\d)-\\1 그런데 반복된다. 반복은 {} meta문자로 나타낼수 있기 때문에,\n(\\d{4})-\\1 로 표현하면 된다. 그다음 해야할 것은 010-1234-1234, +82-10-5678-5678 에서 보면 010이거나 10이다. 즉 3자리의 숫자이거나 2자리의 숫자이다.\n\\d{2,3} 표시하면 된다. 이제 마지막으로 +82이거나 없거나인데, 이때, non-capturing group을 사용할 수 있다.\n(?: ?|\\+82-) 최종 결과 pattern은 다음과 같다.\n(?: ?|\\+82-)\\d{2,3}(\\d{4})-\\1 condition\npostfix 포함 여부\npostfix로 끝나는 단어를 찾는데 편한 방법이 있다고 한다. 예를 들어, 다음과 같은 text가 있다고 하자.\nTourism I don\u0026#39;t like idealism He is socialism 여기서 ism으로 끝나는 단어의 앞부분만 가져오고 싶다면, pattern을 만들어야 한다.\n[^\\s]* 이렇게 하면 ism을 postfix로 갖는 문자열을 검색하는 pattern이 된다. [^\\s]* 는 space가 포함되지 않은 문자열을 의미한다. 즉 단어를 뜻한다. 그런데 강사는 단어를 가져올때, 쉬운 방법이 있다고 한다.\n\\w+ 이게 단어를 가져오는 pattern이라고 한다. w라는게 word를 뜻한다고 한다. \\w는 단하나의 문자이기 때문에 \\w+를 해줘야 단어가 된다.\n여기서, postfix를 추가하기 위해서 ism을 추가한다.\n\\w+ism 이런 pattern을 다음의 text에서 검색한다.\nTourism I don\u0026#39;t like idealism He is socialism 결과는 아래와 같다.\nTourism idealism socialism 여기서, ism이 다 포함된다. 만일 ism을 포함시키지 않을려면 어떻게 해야 하나? 이때 ism 대신 (?=ism)을 사용하면 된다. 즉 ism은 결과에 포함시키지 않겠다는 뜻이다.\n[^\\s]*(?=ism) 이렇게 하면 결과는 다음과 같다.\nTour ideal social prefix 포함 여부\n위에서 했던것과 비슷하다. 예를 들어보자. 다음과 같은 text가 있다고 하자.\nThis is preprocessing function. The word is precompiled function. 여기서 preprocessing, precompiled라는 단어를 검색하고 싶다. 그리고 결과로 pre를 제거한 processing과 compiled를 얻고 싶다고 하자.\npattern을 만들어야 한다. pre로 시작하는 단어이기 때문에 다음과 같이 쓴다.\npre\\w+ 그런데 이 방식은 pre라는 prefix를 포함한다. 따라서 (?\u0026lt;=pre)로 바꿔줘야 한다.\n(?\u0026lt;=pre)\\w+ 이렇게 하면 다음과 같은 결과를 얻게 된다.\nprocessing compiled 주의해야 할것은 prefix경우 (?\u0026lt;=)를 사용하고 postfix의 경우 (?=)를 사용한다는 것이다.\npython에서 regular expression 간단한 사용법 import re text = \u0026#34;\u0026#34;\u0026#34; 010-1234-1234 010-1234-5678 +82-10-5678-5678 +82-4123-1234 \u0026#34;\u0026#34;\u0026#34; pattern = r\u0026#39;(?:0|\\+82-)\\d{1,2}-(\\d{4})-\\1$\u0026#39; for match in re.finditer(pattern,text,re.MULTILINE): print(\u0026#34;전체문자열\u0026#34;,match.group()) print(r\u0026#34;\\1 문자열\u0026#34;, match.group(1)) python에서 정규식은 re package를 사용한다. pattern은 r로 시작하는 문자열로 정의된다. pattern을 통해 text검색하는 함수는 여러개를 제공한다. 위의 예에도 있지만, re패키지에 보면, finditer라는 함수가 있다. 이 함수는 text에 pattern을 적용시켜서 검색을 하는데, iterator형태라서 한번 검색하는게 아니라, text끝까지 반복해서 검색한다. 이 함수의 1번째는 pattern, 두번째는 text, 3번째 인자는 multiline flag이다. text에서 multiline은 flag가 없다면 line으로 인식하지 않기 때문이다. 이 함수에서 match라는 객체를 return한다. 이 객체는 일치하는 문자열을 가지고 있다. 또한 여기선 capturing group을 사용하기 때문에, capturing된 문자열도 가지고 있다. group(0)은 일치하는 문자열이 나오고, group(1)은 capturing group의 값이 나오게 된다.\nMULTILINE option python의 re package를 사용해서 pattern을 text에 적용할 때, option들을 사용할 수 있다. 여러 option들이 있지만, MULTILINE에 대해서만 살펴보자.\nimport re pattern = r\u0026#34;^python\\s\\w+\u0026#34; text = \u0026#34;\u0026#34;\u0026#34;python one life is too short python two you need python python three\u0026#34;\u0026#34;\u0026#34; # match = re.findall(pattern,text,re.MULTILINE) match = re.findall(pattern,text) print (match) MULTILINE이란 option을 추가하지 않으면, python one만 결과로 나온다. pattern을 보면, ^는 문자열의 처음을 나타낸다. 주어진 text는 여러 line으로 이루어져 있음에도, 따옴표때문에 하나의 문자열로 인식되기 때문이다. 여기서 MULTILINE option을 넣어주면, python one, python two, python three의 결과가 나온다. 이것은 하나의 따옴표로 이루어진 문자열이라고 해도 각각의 line의 처음을 문자열의 처음으로 보겠다는 뜻이다.\n사용되는 함수들 re.search() import re text = \u0026#34;\u0026#34;\u0026#34; 010-1234-1234 010-1234-5678 +82-10-5678-5678 +82-4123-1234 \u0026#34;\u0026#34;\u0026#34; pattern = r\u0026#39;(?:0|\\+82-)\\d{1,2}-(\\d{4})-\\1\u0026#39; # pattern = r\u0026#39;(?:\\d{3})-\\d{4}\u0026#39; temp = re.search(pattern,text,re.MULTILINE) print(temp.group()) print(temp.groups()) # print(match.group(0)) search는 처음 매칭되는 문자열을 match객체로 return한다. match객체에서 group()를 사용하면 검색된 문자열을 return한다. groups()는 tuple형태로 검색된 문자열을 반환하는 match의 method다. 만일 capturing을 사용한다면, group(0)을 사용해서 capturing을 출력할 수 있다.\nre.finditer() 이것은 위에서 예제를 봤는데, iterator를 사용해서 matching될때마다 return하게 된다.\nre.sub() import re text = \u0026#39;\u0026#39;\u0026#39; 010-1234-1234 010-1234-5678 +82-10-5678-5678 +82-4123-1234\u0026#39;\u0026#39;\u0026#39; repl = r\u0026#39;치환됨\\1\u0026#39; pattern = r\u0026#39;(?:0|\\+82-)\\d{1,2}-(\\d{4})-\\1$\u0026#39; temp = re.sub(pattern,repl,text,re.MULTILINE) print(temp) # 다른예 # text = \u0026#39;\u0026#39;\u0026#39;010-1234-5678 Kim # 011-1234-5678 Lee # 016-1234-5678 Han\u0026#39;\u0026#39;\u0026#39; # text_mod = re.sub(\u0026#39;^[0-9]{3}-[0-9]{4}-[0-9]{4}\u0026#39;,\u0026#34;***-****-****\u0026#34;,text, flags=re.MULTILINE) # print(text_mod) re.sub는 substitute로, pattern을 검색해서 찾은 것을 replace하는 건데, 강사의 예제는 실행되지 않는다. 강사의 예제는 capture한것을 재가공해서 replace한건데, 제대로 안된다. replace할 문자열은 capture한 것을 사용하기 위해서 \\1 이라는 numeric reference를 사용했기 때문에, r이라는 prefix를 붙였다.\nre.split() import re print(re.split(\u0026#39;-\u0026#39;,\u0026#39;aaa-bbb\u0026#39;)) print(re.split(\u0026#39;(-)\u0026#39;,\u0026#39;aaa-bbb\u0026#39;)) import re text = \u0026#34;\u0026#34;\u0026#34; 010-1234-1234 010-1234-5678 +82-10-5678-5678 +82-4123-1234 \u0026#34;\u0026#34;\u0026#34; pattern = r\u0026#39;(?:0|\\+82-)\\d{1,2}-(\\d{4})-\\1\u0026#39; # result = re.search(pattern,text, re.MULTILINE) splited = re.split(pattern,text,re.MULTILINE) print(splited) # print(result) split는 검색결과를 list로 나타낸다. group이 있는경우는 좀 다르게 return한다. group에 match된 문자열과 전체문자열을 모두 표시한다. 따라서, 첫번째 group에 매치된 문자열과, group을 포함한 regular expression에 일치된 문자열을 return하는 것이다. group이란 독립적인 regular expression으로 볼 수 있기 때문이다.\nregular expression compile pattern을 compile해서 사용할 수 있다고 한다. compile을 한다는 의미가 와 닿지는 않는다. 강사는 pattern을 인식하는것이 시간이 많이 걸린다고 하는데, 그냥 meta와 escape문자로 이루어진 문자열에 불과한데, 시간이 더 많이 걸릴 이유는 없어보인다. 내가 봤을때, compile은 단지 pattern이란 문자열을 객체화한다고 본다. 그렇게 되면 재사용에 유리하다는 장점을 갖기 때문이다. 또한 코드의 가독성이 높아진다.\nfor string in dataset: match = re.search(pattern, string, re.MULTILINE) print (match.group(0)) 위에는 compile을 사용하지 않고, dataset으로 부터 string을 가져와서 검색하는 code다. 매번 string을 가져올때마다 pattern이 string에 적용되게 된다. 이것을 compile하면 다음과 같은 모양이 된다.\ncompiled = re.compile(pattern, flags= re.MULTILINE) for string in dataset: match = compiled.search(string) print(match.group(0)) re.search가 compiled.search(string)문장으로 대체된다. 가독성도 좋아지는 것을 볼 수 있다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture10-string\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture11-io\/": {
        "title": "lecture11-IO",
        "tags": [],
        "content": "standard Input/output 개요 input과 output의 의미 program이 하는 일은 대부분 변수나 객체 생성, for-loop, if로 이루어져 있다. 변수나 객체를 생성하는 것은, cpu와 memory간의 작업이다. 변수나 객체를 생성하는 명령어를 cpu가 실행해서, data memory에 data를 쓰는 작업이다. for loop도 code memory에 놓여 있는 code의 address를 cpu가 address를 계산하는 cpu와 memory의 계산 작업이다. if는 code or data가 놓여진 memory의 값을 가져와서 cpu의 alu가 비교하는 cpu와 memory의 계산작업이다. 결국 모든 program은 cpu와 memory사이의 통신과 계산으로 이루어져 있다. program에서 input과 output의 의미란 무엇인가? cpu와 memory가 아닌 다른 device와 통신하면 input과 output이 된다. memory에도 user program이 아닌 다른 program과 통신하면 input과 output이 된다.\nprogram과 program간의 i/o 관계 program의 input output은 program과 다른 program과의 communication이라고 볼 수도 있고, device와 device간의 통신으로 볼 수있다고 했다. 좀 더 자세히 살펴보자. device와 program은 같은 level이 아니다. device는 h/w level이고, program은 s/w level이다. 두개를 혼합해서 사용하면 햇갈린다. 우리가 만든 program은 cpu와 memory라는 장치를 이용하는 sw이다. 이 cpu에서 monitor로 data를 보낸다고 하자. 그러면 h/w level단에서는 cpu와 monitor device간의 통신이라고 볼 수 있지만 s/w level에서는 내가 만든 program과 monitor device driver라는 program과의 통신이라고 봐야 한다. 그리고 h/w level단에서의 통신은 모두 program간의 통신이라고 말할수도 있는게, 모든 h/w에는 그 h/w를 제어하는 s/w가 돌아가고 있기 때문이다.\nkernel(os) program과 다른 program간의 통신 or device와 다른 device간의 통신은 kernel이라는 program의 도움 없이는 안된다. I/O를 주관하는 kernel이라는 os라는 program이 이를 주관한다. user program이 monitor device driver라는 program과 통신하기 위해선, kernel program에 요청하는 것이다. file을 가져오기 위해서 hdd device와 통신하기 위해서도 file system이라는 s/w와 통신해야 하는데, 이것도 os에게 요청을 해야 한다.\nsystem call과 shell program과 program의 통신을 kernel의 주관한다고 했다. kernel이 user program이나 사용자에게 sytem call이라는 library를 제공한다. 이것은 다른 device에 data를 전달하거나 받거나 혹은 파일을 만든다거나 memory에 process를 만든다거나 하는 hw/resource관련한 작업을 user가 요청하게 만든것이다. c언어나 assembly로 프로그램을 짠다면, 이런 system call을 직접 호출 할 수 있다. 반면 python이나, ruby, javascript같은 script형 언어들은 shell을 사용한다. shell은 system call이라는 function들을 command형태로 바꾼 program이다. 즉 file을 open하거나 file에 directory를 만드는 작업은 c에서는 함수 호출을 하지만, shell위에 떠있는 python,ruby,js는 shell의 mkdir같은 명령어를 사용해서 directory를 만든다. 각각의 python instance아래에는 shell이 떠있다고 보면 된다.\nstandard i/o와 console i/o c언어는 system call이라는 function을 직접 호출할 수 있다고 했다. c에서는 system call을 호출하는 방식이 2가지가 있다. stdio라는 standard i/o 방식과 conio라는 console i/o방식이다. stdio는 system call을 호출하기 전에 buffer를 사용한다거나, 사용을 위한 특별한 객체나 변수등을 제공하고, system call을 wrapping해서 제공한다. 반면에 conio는 직접 system call을 호출한다.\npython에서는 shell을 통해서 system call을 호출한다. 즉 python은 kernel을 사용할 일이 있다면, shell에게 넘겨준다. shell에서는 python에서 전달받은 i/o관련 처리를 standard i/o library를 사용해서 처리한다.\nstandard output print(\u0026#34;this\u0026#34;, \u0026#34;sentence\u0026#34;) print(\u0026#34;this\u0026#34;, \u0026#34;sentence\u0026#34;, sep=\u0026#34;, \u0026#34;) 모든 program들은 shell에서 실행된다. cli로 된 shell이던, gui형태로된 shell이던 명령어 해석기를 거쳐서 program이 실행되기 때문에 중간에 shell이 개입된다. python program은 print함수를 사용해서 해당 data를 출력하고자 한다. shell은 중간에 있다가 출력할 data를 file에 써버린다. 이것은 python이 shell에 의존적인것과는 무관하다. c나 java 모든 program들의 실행은 shell에 의존적이기 때문이다. 즉 shell의 특성이지, python과는 무관하다.\npython a.py \u0026gt; results.txt 이렇게 하면 code의 print문은 shell에게 data를 전달해주고, shell은 results.txt에 저장하게 된다.\nstandard input \u0026gt;\u0026gt;\u0026gt; var = input() 입력을 받습니다. \u0026gt;\u0026gt;\u0026gt; var \u0026#39;입력을 받습니다.\u0026#39; \u0026gt;\u0026gt;\u0026gt; var = input() 12345 \u0026gt;\u0026gt;\u0026gt; var \u0026#39;12345\u0026#39; python의 input의 경우도 output과 마찬가지로 shell이란 중간단계를 거치게 된다. 즉 data를 입력받는게 kernel에 요청해서 kernel이 data를 python program에게 주는게 아니다. shell에게 요청하고 shell이 준다. shell이라는 중간 경유지를 거치기 때문에 경우에 따라서 shell에서 redirection을 사용할 수 있다. python에서 input()를 사용하면 data를 받기 위해서 기다린다. shell은 redirection으로 파일을 열고 data를 전달한다.\ntest.py \u0026lt; results.txt test.py에 input()는 results.txt로 부터 입력을 받게 된다.\nredirection 과 pipe 위에서 redirection을 봤는데, redirection은 data의 i/o를 file로부터 처리한다면, program과 program를 pipe로 연결해서 처리할 수도 있다. 예를 들어보자.\ntest1.py\nm = input() print(m) test2.py\nm = input() print(m) test1.py와 test2.py가 있다고 하자. 두개를 pipe로 연결할 수 있다. 다음을 보자.\n\u0026gt;\u0026gt;\u0026gt; python test1.py | test2.py test1.py를 실행하면 사용자로부터 입력을 받고 입력받은 data를 test.py의 입력으로 전달해서 출력할 수 있다.\n이렇게 pipe와 redirection은 shell에서는 자주 사용된다. 예를들어,\nconda list | grep numpy 위의 경우도 2개의 program을 연결하는 pipe를 보여준다. conda list의 결과가 grep numpy의 입력으로 들어가서 출력하게 된다.\nFile Input/Output file에 대한 처리는 os(kernel)에서 한다. file에 대한 처리는 system call을 통해서 한다. system call은 kernel의 함수를 외부에서 사용할 수 있게 export한 것이다. 이 system call들은 대부분 shell에서 wrapping했고, 이 wrapping된 함수를 user의 program들이 사용한다. shell은 user mode와 kernel mode 경계에 있다고 보면된다. user mode에서 실행하는 program들은(python interpreter도 포함해서) kernel mode에 접근할 수가 없다. shell을 통해서만 가능하다.\n개요 File i/o를 다루기전에 program과 file간의 관계를 살펴보자. file이란건 영구적 보존을 위해 data가 file system에 저장된 형태다. program도 file의 형태로 저장이 되어 있다. file을 생성하고 data나 code를 저장하는것은 program에서 한다. 따라서 program만이 file을 만들고 저장할 수 있기 때문에 관련 함수를 아는건 중요하다. 그런데 어떤 data를 넣을 것인가?는 다른 문제다. program에서 file을 만들고, data를 넣을수도 있고, file을 삭제할 수도 있다. 근데 왜 file을 만들어 오래 보존하는것일까? 도대체 어떤 내용이길래? 내용에 상관없이 모든것을 program을 사용해서 file로 저장할 수 있다. 좀더 정확하겐 file i/o 함수들이다.\nFile open fd = open(\u0026#34;\u0026lt;파일이름\u0026gt;\u0026#34;,\u0026#34;\u0026lt;접근모드\u0026gt;\u0026#34;, encoding=\u0026#34;utf8\u0026#34;) fd.close() \u0026lt;접근모드\u0026gt;\n접근모드 설명 r read mode - file을 text형태로 읽을 때 사용 rb binary read mode- file을 binary형태로 읽을 때 사용 w write mode - file을 text형태로 쓸 때 사용 wb write binary mode- file을 binary형태로 쓸 때 사용 a append mode - 파일의 마지막에 새로운 text를 추가할 때 사용 접근모드에서 신경써야 할것은 w다. 이미 내용이 있는 file을 open하고 write하기 위해서 w를 사용하면 안된다. 기존 내용이 다 삭제 되기 때문이다. file을 open하고 file 작업을 한 이후에는 close를 항상 해줘야 한다.\nread file read() - 파일 한번에 읽기 fd = open(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;) contents = fd.read() fd.close() print(contents) file을 읽는건 read()를 사용하면 된다. file을 다 읽은 후에 file을 close하는 것을 잊으면 안된다. resource를 낭비하기 때문이다. 그런데 file을 close하는것을 깜박할때도 많고, file을 읽다가 error가 나면, close를 하지않고 program이 종료를 할수 있다. 그래서 context manager형태를 사용하면, 자동으로 fd를 닫아준다고 한다. 아래의 구문을 사용한다고 한다.\nwith \u0026lt;contextManager\u0026gt; as \u0026lt;return value\u0026gt; with open(\u0026#34;text.txt\u0026#34;,\u0026#34;r\u0026#34;) as fd contents = fd.read() read()는 파일을 열고 한번에 읽는다.\n줄단위로 읽기 file descriptor사용\nimport os contents = [] print(os.path.realpath(__file__)) with open(\u0026#34;./data/test.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: for sentence in f: contents.append(sentence) print(contents) for-loop를 사용해서 file을 읽는데, read()를 사용하지 않는다. file descriptor가 range()같은 generator 역할을 한다. 한줄 한줄 return하게 된다.\n또한 white space도 포함해서 return하게 되어, \\n과 같은 escape문자가 포함된 하나의 string으로 return하게 된다. 즉 3줄이 있다면, 3개의 string이 return하게 된다.\n위의 예에선 return한 string을 list에 담아 두었다.\nreadlines 사용\n# contents = [] with open(\u0026#34;./data/test.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: contents = f.readlines() print(contents) 위에 나온 file descriptor와 동일한 결과를 나타낸다. for-loop을 사용하지 않는다. list도 선언하지 않는다. readlines는 파일 전체를 읽은 후, list에 line별로 넣기 때문에, code가 더 간단해 진다.\nwrite file write() with open(\u0026#34;./data/text.txt\u0026#34;, \u0026#34;w\u0026#34;) as fd: for i in range(10): fd.write(f\u0026#34;{i+1}번째 문장\\n\u0026#34;) open으로 file을 열고, write()를 사용해서 string을 쓴다. string을 여기서는 fstring으로 만들어 주었다. 변수값이나, 객체값을 string으로 출력할 목적으로 fstring을 사용하는 것이다.\nwriteline() 사용 with open(\u0026#34;./data/text2.txt\u0026#34;, \u0026#34;w\u0026#34;) as fd: fd.writelines(f\u0026#34;{i+1}번째 줄입니다.\\n\u0026#34; for i in range(10)) writelines()안에 for-loop이 있다. 계속해서 write를 할 수 있다. writelines()는 string을 write하는데,\\n은 자동으로 포함하지 않는다. 따라서 필요할 경우, \\n을 string 안에 넣어야 한다.\na(append) option 사용하기 i = 10 with open(\u0026#34;./data/text.txt\u0026#34;, \u0026#34;a\u0026#34;) as fd: fd.write(\u0026#34;내용을 추가합니다.\\n\u0026#34;) fd.writelines(f\u0026#34;{i+1}번째 줄입니다.\\n\u0026#34; append mode는 file의 contents를 지우지 않고, 이어서 작성을 해주는 option이다.\ndirectory import os os.mkdir(\u0026#34;test\u0026#34;) #folder가 이미 있으면 error if not os.path.isdir(\u0026#34;test\u0026#34;): os.mkdir(\u0026#34;test\u0026#34;) os.makedirs(\u0026#34;test/a/b/c\u0026#34;, exist_ok=True) os란 module은 directory를 생성하는 함수가 있다. mkdir이란 shell에서 사용하는 directory 생성명령어랑 동일하다. makedirs()는 subdirectory를 한번에 만드는 함수다. exist_ok=True는 이미 해당 폴더가 존재한다면 만들지 않고 pass한다. False는 새롭게 만든다. directory path에 사용되는 /문자는 window,linux 에 맞게 python이 변환해준다.\nlisting directory import os print(*[entry for entry in os.listdir(\u0026#39;img\u0026#39;)]) 여기서 *는 list unpacking 연산자다. 즉 list에 있는 item들을 unpacking 해서 출력하게 된다. *가 없다면, list가 출력하게 된다. listdir함수는 directory를 인자로 받아서 포함된 file들을 listing한다.\nglob import glob print(*[entry for entry in glob.glob(\u0026#39;img/*.txt\u0026#39;)]) os.listdir()는 directory에 포함된 파일을 for-loop으로 가져오지만, 원하는 파일만 선별해서 가져오는건 아니다. 이럴때, shell에서 사용하는 다음과 같은 명령어가 그리울 수 있다.\nls *.png ls *.pdf 이것을 가능하게 해주는게 glob()다. 현재 폴더에서 원하는 것만 가져오는 프로그램을 짠다면, for-loop로 현재폴더의 file list를 꺼내서 if로 비교연산을 해야 하는것을 meta문자를 사용해서 shell에서 편리하게 하듯, python에선 glob()를 사용해서 이것을 shell에서 하듯이 할 수 있다. 보통의 string에서 \u0026ldquo;test/*.img\u0026quot;는 그냥 문자열에 불과하다. glob()는 문자열에서 /와 *을 meta문자로 처리한다. 즉 일반 문자가 아니라 다른 동작을 하게 meaning이 별도로 지정된것을 말한다. 즉 /는 디렉토리 path separator로 meaning이 정해져 있고, *는 all character를 나타내는 것과 같다.\npickle 객체의 직렬화. program만이 file을 만들고 저장할 수 있다고 했다. 무슨 내용을 저장할까? 보통은 string으로 된 text file이나 program code를 compile한 binary file을 만든다. 에디터라는 program을 만든다면 file io를 사용해서 이런 file들을 만들 것이다. 그런데 program만을 위한 file을 만들 필요는 없을까? 내가 작업하고 있는 객체를 file로 저장하고 필요할때 program에서 load해서 사용하는 형태로 말이다. 또한 file은 network전송이 가능하기 때문에 program에서 사용하고 있는 객체를 원격에 있는 program에서 사용할 수 있게 말이다. 이것은 어떻게 보면, program file을 만들고 원격에서 사용하는 것과 무엇이 다른가?라고 말할 수도 있다. 그런데 다르다. program을 파일로 보내서 compile해서 객체를 만들었다고 해서, data도 같은것은 아니다. 객체를 저장해서 보낸다는 것은 객체라는 구조와 객체가 가진 data를 같이 보내는 것이다. 그래서 객체를 저장하고 load하는 방식에 대한 연구가 이루어졌고 그 결과가 객체 직렬화이다. 객체가 가진 구조와 data를 저장하고 load하는 api를 만들었고 이것이 python에서 pickle이다. pikckle에서는 객체를 보내기위해서 class도 같이 보낸다.왜냐면 복원을 해야 하기 때문이다. 이것을 객체 직렬화라고 한다. 하지만, 객체 직렬화는 대중적이지 않다. 옛날 방식인 data만 보내고 객체의 구조에 맞게 data를 읽어서 parsing해서 넣어주는 방식이 선호된다. 대표적인게 json이다. json은 객체형태에 맞는 data만 보낸다. structure는 보내지 않는다.\n객체 직렬화 pickle의 사용예 import pickle seq = [[ i * j for j in range(5)] for i in range(5)] print(seq1) with open(\u0026#34;test.pkl\u0026#34;, \u0026#34;wb\u0026#34;) as fd: pickle.dump(seq,fd) del seq with open(\u0026#34;test.pkl\u0026#34;, \u0026#34;rb\u0026#34;) as fd: seq = pickle.load(fd) # print(seq[12][9]) 위 코드에서 우선 살펴봐야 할것은 list comprehension이다. list comprehension은 list안에서 for-loop을 사용할 수 있다는 것이다. list comprehension의 for-loop는 item을 만들어낸다. item으로 list를 만들어낼려면, 위와 같이 list comprehension의 item에 해당하는 for-loop 앞에 위치한 곳에 list를 만들면, list안에 list item을 갖게 된다. 사용할 때는 seq[1][1] 이런식으로 사용한다.\nprimitive 객체의 Seriaization. pickle은 객체를 file에 읽고 쓸 수 있게 해준다. pickle의 dump()는 말그대로 dump한다. 덤프트럭에 담긴 객체를 file에 붓는다. 그리고 file에 있는 객체를 load()로 실어 return한다. pickle은 serialization이라고 보면 된다. 즉, serialization은 객체의 구조를 정의된 방식으로 file에 쓰고 객체 구조로 복원하게 된다. file에서 읽고 쓸때는 binary형태로 읽고 쓴다. 객체를 serialization해서 file에 저장했을때는 python이 저장한 방식으로 저장된 binary file이다. 다른 언어에서 사용할 수 없다. python의 객체는 python에서 정의된 객체의 structure를 가지고 있기 때문이다. java는 java만의 객체구조가 있고, javascript는 javascript만의 객체구조가 있기 때문에 다른 언어에서 이것을 복원한다고 해도 사용할 수가 없다.\n그리고 또하나 살펴봐야 하는것은 pickle에 의해 저장과 복원된 객체가 list라는 것이다. list는 primitive한 객체다 내부적으로 seriaization과 restoration이 정의되어 있기 때문에, pickle로 file에 썼다가 다시 복원하는게 가능하다.\nprimitive한 객체가 아닌, 내가 만든 class의 객체도 직렬화와 복원이 가능할까? 내가 만든 class의 attribute들이 모두 primitive한 객체라면 가능하다.\nmy class의 직렬화 import pickle class MyComplex: def __init__(self, real, imaginary): self.real = real self.imaginary = imaginary def __add__(self,other): return MyComplex( self.real + other.real, self.imaginary + other.imaginary ) my_complex = MyComplex(3,5) with open(\u0026#34;test.pkl\u0026#34;, \u0026#34;wb\u0026#34;) as fd: pickle.dump(my_complex,fd) del my_complex #del MyComplex with open(\u0026#34;test.pkl\u0026#34;, \u0026#34;rb\u0026#34;) as fd: my_complex2 = pickle.load(fd) print(my_complex2.real) print(my_complex2.imaginary) 우선 MyComplex라는 class의 attribute들은 모두 int type이라는 전제를 한다. 그래야 serialization이 가능하기 때문이다. my_complex라는 객체를 만들고, pickle을 사용해서 객체를 dump하고, load로 다시 복원 시켰다. my_complex라는 직렬화한 객체는 삭제하고, load()로 파일에서 복원한 것은 my_complex2라는 이름의 객체로 있게 된다. 이전 예제에서 list를 직렬화 복원과 큰 차이는 없다. 다만 여기서 차이가 있는것은 MyComplex라는 class가 삭제된다면, file에 있는 MyComplex class의 instance는 복원이 안된다는 것이다. del이라는 객체 지우는 명령어로 class를 삭제하고 복원하면 에러가 나는것을 볼 수 있다.\ncsv(comma seperated values) csv 개요 program에서 사용하는 data를 위한 file로는 예전부터 csv라는게 있었다. database도 program이 처리하기 위한 data를 저장한것이다. 그래서 일반 text파일과는 좀 다르다. program이 사용하기위한 data를 객체에 넣고 객체를 저장하고 원격에서 객체를 사용하기 위한방법으로 객체 직렬화라는게 나오긴 했지만, 이 방법은 대중화되지 않았다. program이 data를 처리하기위해서 필요한 data는 file이나 db에 넣고, 가져와서 program이 사용하는 방식의 옛날 방법이 더 선호된다. csv도 그런방식이다. data를 comma를 사용해서 저장하는 file. simple하다. excel파일도 comma separated value file이라고 볼 수도 있다. 아래와 같이 엑셀파일이 있다고 하자. 이런 data를 csv로 바꿀 수 있다.\n| id | Name | Loc | | 1 | cho | seoul | | 2 | kim | busan | | 3 | lee | daegu | | 4 | park | Gwangju | | 5 | choi | daejeon | id,Name,Loc 1,cho,seoul 2,kim,busan 3,lee,daegu 4,park,gwangju 5,choi,daejeon text data를 저장할때, 아무런 규칙없이 txt로 저장하는 것보다, csv파일로 data를 저장하고 처리하는게 더 효율적이다. comma가 아닌, tab이나, 공백으로도 처리가 가능하기 때문에 확장자가 .tsv(tab), .ssv(공백)인 파일들도 있다.\ncsv 읽고 쓰기 csv 읽기 - csv reader delimiter\nimport csv with open(\u0026#39;test/test.csv\u0026#39;,\u0026#39;r\u0026#39;) as fd: reader = csv.reader(fd, delimiter=\u0026#39;,\u0026#39;, quotechar=\u0026#39;\u0026#34;\u0026#39;, quoting = csv.QUOTE_MINIMAL) for entry in reader: print(entry) csv의 reader()는 file에서 csv파일의 각줄을 읽고 구분자를 사용해서 item을 뽑아내서 string으로 만든다. 그후 각각의 item을 원소로 하는 list 객체를 만들어 return한다. delimiter는 구분자를 말한다. 구분자를 사용해서 item을 가져온다.\nquotchar\n그런데 만일 string안에 구분자가 있는 경우는 어떻게 될까? 예를 들어보자. 다음과 같은 csv파일이 있다. delimiter가 ,로 csv reader를 만들자.\nid,name,loc 1,\u0026#34;park,hoyoul\u0026#34;,\u0026#34;incheon\u0026#34; 2,\u0026#34;lee\u0026#34;, \u0026#34;seoul\u0026#34; 이경우, 다음곽 같은 결과가 나온다.\n: [\u0026#39;id\u0026#39;, \u0026#39;Name\u0026#39;, \u0026#39;Loc\u0026#39;] : [\u0026#39;1\u0026#39;, \u0026#39;\u0026#34;park\u0026#39;, \u0026#39;hoyoul\u0026#34;\u0026#39;, \u0026#39;\u0026#34;seoul\u0026#34;\u0026#39;] : [\u0026#39;2\u0026#39;, \u0026#39;kim\u0026#39;, \u0026#39;busan\u0026#39;] ,를 기준으로 자른다. \u0026ldquo;는 그냥 문자일뿐이다. 그래서 \u0026ldquo;seoul\u0026quot;이라는 item도 \u0026lsquo;\u0026ldquo;string\u0026rdquo;\u0026lsquo;으로 만들어지고, csv에서 string안에 \u0026lsquo;,\u0026lsquo;가 있던,\n\u0026#34;park,hoyoul\u0026#34; 은 아래와 같이 가져온다.\n\u0026#39;\u0026#34;park\u0026#39;,\u0026#39;hoyoul\u0026#34;\u0026#39; 우리는 \u0026ldquo;park, hoyoul\u0026quot;이 하나의 item으로 뽑아낼 줄 알았다. 그런데 \u0026lsquo;,\u0026lsquo;에 의해서 string이 하나의 item이 아닌 2개가 되었다. 이것을 제어할 필요가 있다. 그래서 quotchar를 설정하고 csv reader를 만들어야 한다. 즉 quotchar가 \u0026quot; 라는 것은 \u0026quot; \u0026ldquo;로 둘러싼 string의 경우 안에 delimiter가 있어도 무시하라는 뜻이다.\nparsing option\nQUOTE_MINIMAL: 최소길이로 parsing한다. 이부분으 그냥 default값을 쓰고 나중에 공부할 때 채워 놓기로 한다. csv 쓰기 - csv writer import csv with open(\u0026#39;test/test1.csv\u0026#39;,\u0026#39;w\u0026#39;) as fd: writer = csv.writer(fd, delimiter=\u0026#39;,\u0026#39;, quotechar=\u0026#39;\u0026#34;\u0026#39;, quoting = csv.QUOTE_MINIMAL ) writer.writerow([\u0026#39;id\u0026#39;, \u0026#39;label\u0026#39;]) writer.writerows([I, f\u0026#39;label_{I}\u0026#39;] for I in range(10)) csv파일을 with open으로 열고, fd를 csv reader에 넣어서 csv reader 객체를 만들듯이, csv writer도 쓸 파일을 with open으로 열고 fd를 가지고 csv writer객체를 만든다. csv를 어떻게 처리할 지에 대한 option도 넣어두고, 이렇게 하면 내가 만든 string을 원소로 한 list가 csv파일에 저장될 것이다. csv reader를 만들면, csv파일을 한줄 한줄 읽어서 string item으로 된 list객체를 return했었다. 쓰는것은 반대다. list를 만들어줘야 한다. string item을 가진 list를 만들고 writer의 writerow()를 사용해서 파일에 쓴다. 여러줄을 쓰기 위해서 writerows()를 사용하기도 하고, 한줄만 쓰기위해서 writerow()를 사용하기도 한다.\njson(javascript Object Notation) json 개요 program을 위한 file이 있다고 했다. 즉, program에서 제공하는 structure와 data가 결합된 형태인 객체를 직접 file에 저장하고 꺼내서 사용하는 pickle을 말했었다. pickle과 같은 객체 직렬화 방식은 대중적이지 않아서 csv처럼 program이 필요한 data만 file에 저장하고 load하고, program의 structure는 program이 그대로 가지고 있는 옛날 방식을 사용한다고 했다. program은 적절한 구조를 만들고, csv파일에서 읽어서 객체를 초기화하는 방식이다. 그런데 csv형태에선 모든게 string이다. program에서 사용하는 structure는 여러 data type을 사용하는데, csv를 사용하면, parsing작업이 많아 진다. json은 객체의 구조에 적절한 data를 pre processing없이 사용할 수 있게 만든 방식이다. csv처럼 program에서 사용할 data만 저장한다는 면에서는 동일하다. 즉 객체를 저장하는 방법(structure+data)에서 data만 별도로 저장하는 방식인데, csv보다 upgrade된 방식이라고 볼 수 있다. key:value구조로 된 파일. csv파일의 모든 item들은 csv reader나 csv writer를 사용할 때, 모두 string으로 처리한다. 즉 csv reader로 읽을 때 모든 item들은 string이다. 저장할 때도 string으로 된 list를 csv파일에 저장한다. 이렇게 하는 이유는 csv파일 자체가 plain text파일이기 때문이다. json은 programming에 친화적인 data저장용 파일이다. csv의 모든 data가 string인 반면에, json은 int형, string형, list형 자료형태도 가질 수 있다. json파일 한개는 {}로 둘러싸인 object형이다.\njson 읽기 import json with open(\u0026#39;test/test.json\u0026#39;, \u0026#39;r\u0026#39;) as fd: data = json.load(fd) print(data[\u0026#39;hobbies\u0026#39;]) print(data[\u0026#39;hobbies\u0026#39;][2][\u0026#39;sports\u0026#39;][0]) json 쓰기 import json obj = { \u0026#34;ID\u0026#34;: None, \u0026#34;bool\u0026#34;: False, \u0026#34;bobbies\u0026#34;: { \u0026#34;sports\u0026#34;: [ \u0026#34;snowboard\u0026#34; \u0026#34;volley-ball\u0026#34; ] } } with open(\u0026#34;test/test2.json\u0026#34;, \u0026#39;w\u0026#39;) as fd: json.dump(obj, fd) csv파일을 쓸때는 csv파일에 들어갈 형태로 program에서 만든다. 들어갈 형태는 string을 item으로 갖는 list였다. 그리고 write했다.\n[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;] json도 똑같다. json에 들어갈 형태로 program내에서 만들어야 한다. json파일에 들어갈 형태라는 것은 dictionary object의 형태다. 따라서 위의 obj dictionary처럼 key:value형태로 data를 만들어서 json파일로 저장한다.\n일반적으로 program에선 객체를 가지고 작업을 한다. python에서 주로 객체를 사용한다. program에서 주로사용하는 객체를 인간이 이해할 수 있는 string이나, file에서 사용하기위해서 많은 program적 요소들이 존재한다. string을 보자. 우리는 string을 literal하게 string을 작성하지 않았다. string을 만드는 것은 file에 저장하거나, 화면에 보여준다. 이때, 순수하게 순전히 string을 작성해서 보여주거나 저장하지 않는다. 왜냐하면, program에서 주로 다뤄지는건 객체이기 때문에 객체정보를 string이나 file에 쉽게 포함되게 하는 방법이 필요했다. 왜냐? 우리가 file에 저장하거나 화면에 보여줄것은 string literal이 아닌 객체 값이기 때문이다. 그래서 string안에 객체의 값을 넣기 위해서 format이라던가, %표현, fstring을 사용했다. 마찬가지로 file도 string literal이 저장될 꺼라고 생각할테지만, 그렇지 않다. 객체의 값을 꺼내서 file에 저장하기 때문이다. python에서 사용하는 dictionary 객체, list객체등에 있는 값을 꺼내서 저장하기에는 json구조가 잘 맞는다.\n아니 그렇다면, programming에서 사용되는 객체를 파일에 저장하기에 적합한 pickle을 사용하면되지 json을 사용할 필요가 있을까? pickle은 모든 객체를 저장한다는 보장이 없다. 일부객체에만 사용할 수 있기에, 객체의 내용을 적절하게 json object형태로 만들고, json파일로 저장하는 방식이 모든 객체에 적용할 수 있기 때문에 더 인기있는 방식이 되었다. json object형태로 만들고 json파일에 저장하는것은 어떻게 보면 객체 직렬화와 동일하다. 1,\u0026ldquo;abc\u0026quot;같은 값들이 program내에선 객체다. 그리고 그것을 file에 쓸때는 객체 직렬화를 거치기 때문에, json파일로 저장하는건 객체 직렬화가 수행된다고 볼 수 있다. 그래서 program내에서 만든다는 json object의 구성품들은 모두 직렬화가 가능한 primitive data type이라는 것을 알수 있다.\nXML(Extended Markup Lanugage) xml 개요 csv에서 string만 사용한다는 단점을 json은 잘 극복했다. program에서 주로 사용하는 int, list와 같은 다양한 종류의 data도 사용할 수 있게 했다. 원래 객체를 저장하려는 방식(직렬화)에서 객체의 구조를 떼어내고 data만 저장하고 load하겠다는 의도였기 때문에 json은 구조도 객체형태의 data이기 때문에 매우 적합하다. xml은 json과 비슷하게 사용된다. 하지만 xml은 시작이 다르다. json은 program이 사용하는 객체를 혹은 program의 일정 단위를 파일의 형태로 저장및 복원하는 객체 직렬화의 대안으로 나온 구조이기 때문에 객체가 가진 구조적 특징, 이름, 여러종류의 data type을 key:value형태로 해서 비슷하게 구현했기 했다. 즉 json객체를 load만 잘하면, 그대로 program의 객체를 저장하고 load하는 직렬화랑 거의 비슷하게 된다. xml은 program을 위한게 아니라, 사람들이 보는 문서를 tag를 사용해서 좀더 구조적으로 만든것이다. tag에는 name에 해당하는 tag도 있고 attribute들을 설정할 수 있기 때문에, json과 거의 비슷하게 사용될 수도 있다. json이 객체가 가진 data를 객체의 구조에 맞게 만들었듯이 xml도 객체가 가진 구조에 맞게 만든다면 json처럼 사용될 수 있을 것이다. 하지만 역사에도 보았듯이 xml은 인간이 보는 text파일을 구조적으로 작성한 방식이라서 tag라는것도 객체를 위한것이라기 보단 문서를 어떤식으로 보이게 할 것인가? 그런데 촛점을 둔 문서다. html을 보면 알 수 있을 것이다. 따라서 json처럼 객체를 위한 data저장 파일로 보면 안된다. xml은 이미 html형태로 대중화가 되어있다. python에서는 xml을 파싱해서 적절한 처리를 할 library를 제공할 뿐이다. python에선 xml을 parsing할 수 있다는건 수많은 인터넷 문서, 즉 html로되어 있는 문서를 가지고 와서 program이 사용할 수 있다는 큰 장점이 있다. json과는 의도 자체가 다르다. xml문서는 순전히 data의 역할을 할뿐이다. 일반 책이나 문서파일이라고 봐도 된다. tag라는 부가적 정보가 있을뿐이지 그냥 data다. json처럼 code의 structure를 고려할 필요가 전혀 없다. 그냥 data다. 어떻게 보면, csv도 마찬가지다. 순전한 data다.\nxml parsing beautifulsoup xml 파일을 처리하기 위한 default library를 제공하긴 하나, 불편하다. parsing을 위한 외부 library가 존재한다. beautifulsoup을 사용하면 xml문서에 대한 처리가 가능하다.\nbeautifulsoup 설치 conda install beautifulsoup4 xml 파일 읽기 by beautifulsoup 예제\nfrom bs4 import BeautifulSoup with open(\u0026#34;test/test.xml\u0026#34;, \u0026#34;r\u0026#34;) as fd: soup = BeautifulSoup( fd.read(), \u0026#39;html.parser\u0026#39; ) to_tag = soup.find(name=\u0026#39;to\u0026#39;) print(to_tag.string) for cite_tag in soup.findAll(name = \u0026#39;cite\u0026#39;): print(cite_tag.string) cites_tag = soup.find(name=\u0026#39;cites\u0026#39;) print(cites_tag.attrs) print(cites_tag[\u0026#39;attr\u0026#39;]) cites_tag = soup.find(attrs={\u0026#39;attr\u0026#39;: \u0026#39;name\u0026#39;}) for cite_tag in cites_tag.find_all(name=\u0026#39;cite\u0026#39;): print(cite_tag.string) Beautifulsoup은 xml파일을 읽고 parsing을 한다. file을 읽고 처리해야 하기 때문에, with open절을 사용한다. fd.read()는 xml파일을 읽고, 지정된 parser로 parsing한다. 이렇게 하면 Beautifulsoup 객체는 xml의 모든 내용을 접근할 수 있다.\nfind()\nsoup에서 가장 많이 사용하는건 find()다. tag를 찾아서, tag의 값이나, tag의 속성을 가져올 수 있다.\nmytag = soup.find(name=tag) print(mytag.attrs) print(mytag.string) print(mytag[\u0026#39;attr\u0026#39;]) find()로 tag를 찾은후 tag의 속성은 attrs로 접근하고, tag의 값은 string으로 접근한다. tag의 속성은 dictionary형태이기 때문에 위처럼 mytag[\u0026lsquo;attrs\u0026rsquo;]로 접근이 가능하다.\n속성으로 tag를 찾을 수도 있다. 속성은 dictionary형태이다. 따라서 아래처럼 찾는다.\ncites_tag = soup.find(attrs={\u0026#39;attr\u0026#39;: \u0026#39;name\u0026#39;}) findAll()\nfind()는 find(name=\u0026lsquo;tag\u0026rsquo;)로 해서 하나의 tag를 찾는다면, findAll(name=\u0026lsquo;tag\u0026rsquo;)는 같은 이름의 tag를 찾아서 sequence로 만든다. sequence로 만들면, for-loop에 사용할 수 있다.\nfind_all()\nfindAll()는 xml내에서 정의된 tag를 모두 찾는다면, find_all()는 찾은 객체 내에서 검색이 가능하다.\ncites_tag = soup.find(attrs={\u0026#39;attr\u0026#39;: \u0026#39;name\u0026#39;}) for cite_tag in cites_tag.find_all(name=\u0026#39;cite\u0026#39;): print(cite_tag.string) 위에서 보면, cites_tag는 속성을 갖는 tag를 가져오는데, tag는 하나의 객체로 봐도 된다. 가져온 tag안에 sub tag들이 엄청 많을 수 있다. 그 tag안에 검색을 한다. find_all(name=\u0026lsquo;cite\u0026rsquo;), 즉 cite라는 tag가 있다는 뜻이다.\nYAML(YAML Ain\u0026rsquo;t Markup Language) 개요 객체 직렬화는 program에서 객체를 파일로 저장하고 복원하겠다는 idea다. program을 위한 file을 만들고 사용하겠다는 based idea가 있었다고 했다. 그래서 pickle도 있었지만, 대중화되지 않고, 옛날방식, data는 file에 저장하지만 복원시 parsing을 통해 적절하게 객체를 초기화하겠다는 생각이 지금도 널리 사용된다고 했다. 그래서 json이란 형태로 객체의 data를 저장하고 복원하는 방식이 인기가 있었다. json에도 많은 문제가 있다.\njson의 문제점 주석을 지원하지 않는다. 큰따옴표만 지원한다. escape문자의 처리가 힘들다. YAML json처럼 객체, dictionary, list를 나타낼수 있고, 위에 말한 단점들도 다 보완했다.\nyaml은 json의 superset으로 보면 된다.\ndictionary 표현법\ndoe: \u0026#34;this is a value\u0026#34; pi: 3.141592 xmas: true list 표현법\ncalling-birds: ​ - huey ​ - dewey ​ - louie ​ - fred dictionary 안의 dictionary\nxmas: tree-birds: four french-hens: 3 tab을 사용해서 inner dictionary를 표현한다.\n설치 conda install pyyaml -c anaconda yaml 읽기 import yaml import pprint with open(\u0026#39;test/test.yaml\u0026#39;) as fd: data = yaml.load(fd, Loader = yaml.FullLoader) pprint.pprint(data) 위에서 with open에 \u0026lsquo;r\u0026rsquo;은 생략할 수 있다. pprint는 standard library라서 import해서 사용하면 된다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture11-io\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture12-setting-exception-logging\/": {
        "title": "lecture12-setting-exception-logging",
        "tags": [],
        "content": "Command Line Argument 개요 python을 실행할때, gpu개수, epoch같은 변수들을 program이 동작할때 cmd line interface에서 argument에서 전달받겠다, 입력받겠다고 처리할 수 있다. program안에서 상수값으로 처리하는게 아니라, program을 실행할 때, 해당 값을 설정해서 실행하는 것이다.\n(1) python main.py (2) python main.py arguments (3) python main.py --options 12345 위와같이 program을 실행할 때, 아래와 같이 하면 command line argument를 건네 받을 수 있다.\nimport system print(sys.argv) 각각의 결과는 아래와 같다.\n(1) python main.py =\u0026gt; [\u0026#39;main.py\u0026#39;] (2) python main.py arguments =\u0026gt; [\u0026#39;main.py\u0026#39;, \u0026#39;arguments\u0026#39;] (3) python main.py --options 12345 =\u0026gt; [\u0026#39;main.py\u0026#39;, \u0026#39;--options\u0026#39;, \u0026#39;12345\u0026#39;] argument들은 공백을 기준으로 item이 도출된다. parsing이 복잡하다. item이 string형태라서 int,float로 형변환도 해야 하기 때문에 쉽게 사용할 수 있는 argparser를 사용한다.\nargparser 사용법 import argparse parser = argparse.ArgumentParser() parser.add_argument(\u0026#39;-l\u0026#39;, \u0026#39;--left\u0026#39;, type= int) parser.add_argument(\u0026#39;-r\u0026#39;, \u0026#39;--right\u0026#39;, type= int) parser.add_argument(\u0026#39;--operation\u0026#39;, dest=\u0026#39;op\u0026#39;, help=\u0026#39;Set Operation\u0026#39;, default=\u0026#39;sum\u0026#39;) args = parser.parse_args() print(args) if args.op == \u0026#39;sum\u0026#39;: out = args.left + args.right elif args.op == \u0026#39;sub\u0026#39;: out = args.left - args.right print out argv로 cmd명령어와 option을 하나의 문자열로 입력받아 parsing해서 처리하지 않고, 위와 같이 argparse 모듈을 사용하면, option에 대한 처리를 미리 정의할 수도 있다. 짧은 option과 긴 option을 사용해서 받아올 값의 type도 설정이 가능하다. 어떻게 사용하는지 정리해 보자.\nArgumentParser라는 객체를 만든다.\n이 객체에서 argument에 대한 설정을 할수 있다.\nparser.add_argument(\u0026#39;-l\u0026#39;, \u0026#39;--left\u0026#39;, type= int) parser.add_argument(\u0026#39;-r\u0026#39;, \u0026#39;--right\u0026#39;, type= int) parser.add_argument(\u0026#39;--operation\u0026#39;, dest=\u0026#39;op\u0026#39;, help=\u0026#39;Set Operation\u0026#39;, default=\u0026#39;sum\u0026#39;) command argument가 program에 전달되면, parsing이 가능하다.\nargs = parser.parse_args() add_argument로 정한 argument값에 대한 접근을 할 수 있다.\nargs.left, args.right, args.op로 접근 가능 args.operation은 dest옵션으로 args.op로 접근 가능하다.\nException Handling 개요. 0으로 나누거나, 파일을 열었는데, 해당 파일이 없다거나, server와 연결이 끊겼을 때.. 이런 예외가 발생했을때, 다른 대응 코드를 사용해서 처리해야 한다.\ntry except 코드 예외 발생이 예상되는 코드가 있다. 그 code에 다음과 같이 처리하면, 예외가 발생했을 때 그냥 program이 종료하는게 아닌, 적절한 대응을 해서 계속 진행이 가능하다.\ntry: \u0026lt;예외 발생 가능 코드\u0026gt; except \u0026lt;예외클래스\u0026gt;: \u0026lt;대응 코드\u0026gt; exception handling example for i in range(-5,5): try: print(10/i) except ZeroDivisionError: print(\u0026#34;Zero Division, skip the number.\u0026#34;) i가 0이 되면 zero division error가 발생한다. try exception처리가 없다면, program은 종료한다. exception처리를 했기 때문에 for-loop를 계속 진행한다.\nBuilt-in Exception Exception class 설명 발생 가능 예시 Index Error List의 index범위를 넘어감. list[001] Name Error 존재하지 않는 변수를 호출 not_exist+1 Zero Division Error 0으로 숫자를 나눔 10/0 Value Error 반환할 수 없는 문자열/숫자를 변환 float(\u0026ldquo;abc\u0026rdquo;) FileNotFoundError 존재하지 않는 파일 호출 open(\u0026ldquo;not exist.txt\u0026rdquo;,\u0026ldquo;r\u0026rdquo;) 이것 외에도 많은 built-in exception들이 있다.\nException class Exception들은 BaseException에서 상속받은 class들이다.\nexception이 inheritance를 갖기 때문에 try except에서 처리할 때 부모 class를 잡아서 처리하는게 효율적이다. 참고로 위 tree에서 exception처리할 수 있는 class는 Exception아래 클래스만 해당한다.\ntry: except Lookuperror: 이렇게 하면, index error와 key error에 대한 처리가 가능하다. 사용자 정의 Exception도 만들 수 있는데, 만들기 위해선 Exception class를 상속해서 만들면 된다.\nRaising \u0026amp; Referencing Exception raise구문으로 예외를 발생시킬 수 있다. 그리고 as 구문으로 잡힌 에러를 참조 할 수 있다.\ntry: while True: value = input(\u0026#34;A,B,C중 하나를 입력하세요:\u0026#34;) if len(value) ==1 and value not in \u0026#34;ABC\u0026#34;: raise ValueError(\u0026#34;잘못된 입력입니다. 종료합니다.\u0026#34;) print(\u0026#34;선택된 옵션:\u0026#34;, value) except ValueError as e: print(e) 위 코드에서 raise로 Exception객체를 만든다. 이렇게 만들어진 exception객체는 except구문에서 잡을 수 있다. ValueError 클래스 객체라면 e로 잡고, e를 출력하면 Exception객체가 가진 값을 출력한다. 만일 except문에서 처리하지 못한다면, program은 종료하게 된다.\nAssertion assert문이 있다. 조건을 확인해서 참이 아닐때 AssertError를 발생한다. raise가 무조건적인 error를 발생시킨다면, assert는 조건을 확인하고 발생시킨다.\nassert \u0026lt;조건\u0026gt; assert \u0026lt;조건\u0026gt;, \u0026lt;에러 메시지\u0026gt; def add_int(param): assert isinstance(param,int), \u0026#34;int만 된다.\u0026#34; return param+1 try: print(add_int(10)) print(add_int(\u0026#39;str\u0026#39;)) except AssertionError as e: print(e) try except는 try~catch구문과 동일하다. add_int가 try문에 걸려 있는데, 여기서 assert문이 있다. param이 int가 아니기 때문에 AssertionError가 발생한다. 그리고 except에서 해당 error를 catch해서 처리한다.\npost-error processing try-except문에는 except로 error를 잡아서 처리하는 것 외에 다른 처리를 할 수 있게 else와 finally같은 keyword가 존재한다. 3개의 각각의 경우를 비교해 보자. functions()에서 SomeError가 발생하거나 다른 Error가 발생하지 않을때, 대비하는 코드인 except, else, finally가 어떻게 수행되는 지 보자.\nexcept만 있는 경우 try: functions() except SomeError as e: print(e, \u0026#34;예외 발생\u0026#34;) print(\u0026#34;예외 이후\u0026#34;) 예외발생이 없는 경우 \u0026ldquo;예외 이후\u0026quot;를 출력. SomeError가 발생한 경우 \u0026ldquo;예외 발생\u0026quot;을 출력 \u0026ldquo;예외 이후\u0026quot;를 출력. 다른 예외가 발생한 경우. 프로그램 비정상 종료 else가 있는 경우 try: functions() except SomeError as e: print(e, \u0026#34;예외 발생\u0026#34;) else: print(\u0026#34;예외 이후\u0026#34;) else의 의미가 좀 애매하다. 왜냐면, try-except에서 처리가 되는 경우에 대한 else이기 때문이다. 즉 except에서 처리가 되지 않는 경우는 else를 수행하기 때문이다.\n예외발생이 없는 경우 \u0026ldquo;예외 이후\u0026quot;를 출력. SomeError가 발생한 경우 \u0026ldquo;예외 발생\u0026quot;을 출력 다른 예외가 발생한 경우. 프로그램 비정상 종료 finally구문이 있는 경우 try: functions() except SomeError as e: print(e, \u0026#34;예외 발생\u0026#34;) finally: print(\u0026#34;예외 이후\u0026#34;) finally구분은 모든 경우에 출력되는 것을 볼 수 있다.\n예외발생이 없는 경우 \u0026ldquo;예외 이후\u0026quot;를 출력. SomeError가 발생한 경우 \u0026ldquo;예외 발생\u0026quot;을 출력 \u0026ldquo;예외 이후\u0026quot;를 출력. 다른 예외가 발생한 경우. \u0026ldquo;예외 이후\u0026quot;를 출력. 프로그램 비정상 종료 Exception Handling Example for i in range(5,-5,-1): try: value /= i except NameError: print(\u0026#34;No value on Value: set 0\u0026#34;) value = 10 except ZeroDivisionError: print(\u0026#34;Zero Division: Skip\u0026#34;) except Exception as e: print(type(e),e) raise e else: print(value) finally: print(\u0026#34;step\u0026#34;) 첫번째로 발생하는 error는 NameError다. NameError가 발생하는 이유는, value /= i에서 발생한다. 이것은 value = value/i인데 좌변은 문제 없지만 우변이 문제가 있다. 우변의 value는 값을 가지고 있지 않다. 따라서 NameError가 발생한다. 그리고 finally가 수행된다. finally는 try except에서 처리하던 안하던, 수행이 되는 구문이기 때문이다. else는 try-except에서 error를 처리하지 못하면 수행된다. 따라서 zerodivisionerror가 발생한 이후는 계속해서 else와 finally만 수행되게 된다.\nLogging 처리 개요 program안에서 일어난 일을 logging할 수 있다고 한다. debug를 위해서 logging을 할 수도, 사용자 패턴파악을 위해서 logging을 할 수 있다고 한다.\nLogging module 사용 import logging logging.debug(\u0026#34;디버깅\u0026#34;) logging.info(\u0026#34;정보 확인\u0026#34;) logging.warning(\u0026#34;경고\u0026#34;) logging.error(\u0026#34;에러\u0026#34;) logging.critical(\u0026#34;치명적오류\u0026#34;) 상황에 따라 다른 level의 log출력이 가능하다고 한다. 아래 처럼 level을 갖는 log를 보여준다.\ndebug \u0026lt; info \u0026lt; warning \u0026lt; error \u0026lt; critical 디버그를 할때 print debug라는게 있다. 즉 tracer를 사용해서 debugging을 할 수도 있지만, 값을 찍어서 확인할 수도 있는데, 그때 이 log 모듈을 사용할 수 있다. log가 level이 있다면, 저장될때도, level에 따라 file에 저장되거나, 혹은 화면에 출력되는것도 결정하는걸로 알고 있는데, 그것에 대한 설명은 없다. 다만 아래 표를 읽어줬는데, 이표만 가지고는 별 도움이 안되는거 같다.\nlevel 설명 예시 DEBUG 상세한 정보, 문제를 진단할 때 사용 변수 A에 값대입, 함수 F호출 INFO program이 정상동작중 발생하는 event보고 서버시작, user의 서버접속 WARNING 예상치 못한 일이 발생하거나, 발생할 문제에 대한 보고 문자열 대신 숫자 입력, 인자로 들어온 list가 길이가 안맞음 ERROR 오류가 발생했으나 program은 동작가능 파일이 없거나 외부 서버 연결이 불가능 CRITICAL 심각한 오류 발생, 프로그램이 실행되지 않을 때 중요 파일이 없거나 사용자 강제 종료시 root logging 왜 root logging이라고 부르는지는 모르겠다. 하지만 여기서 logging을 할때 저장되는 문자열에 root가 있다고 한다. 예를 들면,\nWARNING:ROOT: this is warning message ERROR:ROOT: this is error message import logging logging.basicConfig( filename=\u0026#39;test.log\u0026#39;, level=logging.INFO ) logging.debug(\u0026#34;기록 안됨\u0026#34;) logging.info(\u0026#34;기록 됨\u0026#34;) logging.ERROR(\u0026#34;기록 됨\u0026#34;) basicConfig에서 설정하는 내용을 보면 log가 저장될 파일과 level이 정해진다. debug가 기록되지 않는 이유는 info보다 level이 낮기 때문이다. 우리가 program을 개발할때, develop단계에서는 debug를 위해서 print문을 많이 쓴다. 그리고 그 코드가 product단계로 가서, 그대로 출시될 수도 있다. logging을 사용하면 그런 문제를 막아줄 수 있다. logging에서 print의 level을 정할 수 있기 때문에, basic config만 설정하면된다. print문이 많다면, 모든 print문을 찾아서 지우거나 혹은 필요한것만 남겨야 하는데, logging을 사용하면 간단히 처리할 수 있다.\nlogger management root logger가 아닌, 새로운 이름의 logger를 만들기 위해선, getlogger를 사용한다고 한다.\nimport logging logging.basicConfig( filename=\u0026#39;test.log\u0026#39;, ) # logger = logging.getLogger(\u0026#34;main\u0026#34;) # 새로운 logger생성 logger = logging.getLogger(__name__) # module이름으로 logger생성 logger.setLevel(logging.INFO) logging.info(\u0026#34;Root에 info 기록\u0026#34;) logging.warning(\u0026#34;Root에 warning 기록\u0026#34;) logging.info(\u0026#34;메인에서 info기록\u0026#34;) logging.warning(\u0026#34;메인에서 warning기록\u0026#34;) basicConfig라는게 root logger의 설정이라고 한다. 하지만 getLogger로 새로운 user logger를 만들면 root logger의 설정을 그대로 사용하게 된다고 한다. 강의가 좀 부실하다. 나중에 더 조사해야 할듯하다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture12-setting-exception-logging\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture13-web\/": {
        "title": "lecture13-web",
        "tags": [],
        "content": "web crawling web crawling 개요 우리가 browser로 보는 화면은 html문서를 formatting한 것이다. web 문서인 html문서를 browser가 우리 컴퓨터에 down받고 down받은 html문서를 formatting해서 보여주는 것이다. browser가 html문서를 down받아서 보여주는 것처럼, python에서 html문서를 down받아서 분석할 필요가 있다. 이것을 web crawling이라고 한다. python에서 html문서를 가져오기 위해서는 requests라는 사용자 library를 사용해야 한다.\nRequests 설치 conda install requests requests 사용법 예시 import requests URL = \u0026#39;https://www.naver.com\u0026#39; response = requests.get(URL) print(response.status_code) print(response.text) request.get으로 html문서와 여러 응답결과를 객체로 만들어 return한다. return한 객체에 html문서가 있다. 문서는 text라는 변수가 가리킨다.\nCrawling 예시 import requests from bs4 import BeautifulSoup URL = \u0026#34;https://sports.news.naver.com/index\u0026#34; response = requests.get(URL) soup = BeautifulSoup( response.text, \u0026#39;html.parser\u0026#39; ) headline = soup.find(name=\u0026#39;ul\u0026#39;, attrs={\u0026#39;class\u0026#39; : \u0026#34;today_list\u0026#34;}) for title in headline.find_all(name=\u0026#39;strong\u0026#39;, attrs={\u0026#39;class\u0026#39;:\u0026#34;title\u0026#34;}): print(title.string) 간단한 web scrawl의 경우 beautifulsoup으로 해도 되지만, 복잡한 구조의 html문서의 web crawling은 scrapy패키지를 사용한다.\n강의 끝 강의에서 미흡된 부분은 아래와 같다.\nMulti thread Networking ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture13-web\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture3_data-structure\/": {
        "title": "lecture3 data structures",
        "tags": [],
        "content": "Data Structure List list의 특징 대괄호로 만들어진다. 아무 type의 객체를 가리킬수 있다. list가 con cell로 이루어져있고 car, cdr이 모두 pointer라서 어떤 type의 객체를 가리키는건 너무 자연스럽다. 길이가 정해져 있지 않다. seq = [12345,101, \u0026#34;Text\u0026#34;, None, True] print(seq) list index \u0026amp; slicing indexing\nindex로 개별 원소를 접근한다. 이 부분이 좀 특이하다. lisp에서 개별 원소에 접근할 때는, linked list이기 때문에 car과 cdr을 사용해서 access했기 때문에, 마치 배열처럼 index로 접근한다는건 좀 특이하다. 배열이 index로 접근할 수 있는건 각각의 원소가 위치한 메모리 공간이 붙어있기 때문에, index로 해당 원소의 메모리 공간을 지정할 수 있기 때문이다. 그런데, list는 그렇지가 않다. index를 지정해도, index만큼 포인터를 이동해야만 하기 때문이다. 예를 들어, list의 2번째 원소에 접근하는것은 car(car a)을 의미한다. 즉 a[2] =\u0026gt; car(car a)를 변환될 듯하다. 음수도 indexing이 가능하다. slicing\n사용법: seq[start: end: step:] default값은 생략 가능하다. start: end: 가 0이거나, step:이 1인 경우 생략 가능하다. example seq=[1,2,3,4,5,6,7,8,9,10] print(seq[:3]) print(seq[3:]) print(seq[3:-1]) print(seq[-3:-1]) print(seq[::2]) print(seq[9:2:-1]) print(seq[9:2:1]) seq[:3]은 index가 0,1,2를 의미한다. 3은 포함하지 않는다. seq[3:]은 index가 3,4,5\u0026hellip;9까지를 의미한다. seq[3:-1]은 index가 3,4,5\u0026hellip;8까지를 의미한다. seq[::2]는 step만 지정하는 것도 가능하다. seq[9:2:-1]는 9부터 시작해서 2로 간다. 9보다 작은것으로 갈려면 step을 -값으로 해주어야 한다. seq[9:2:1]은 9부터 시작해서 2로 가는데, 1씩 더해서 간다. 이런 경우, []를 얻는다. lisp의 list와는 다른 list원소 접근법이다. index로 접근하는것은 직관적이긴 하다. function과 같이 쓰일때 강력한 성능을 보일지는 모르겠다. List operators\nappend(+)\na = [1,2,3,4] b = [5,6,7,8] print(a + b) a = a + b print(a) list는 mutable객체라서 a = a + b를 해도 새로운 객체가 만들어지진 않을 듯하다. 원소 값 바꾸기\na[0] = \u0026#39;something\u0026#39; multiply(*)\nlist에 곱하기도 연산이 가능하다. a = [1,2,3,5] print(a * 2) in 연산자.\na = [1,2,3,4] print(3 in a) len(): 길이 구하는 operator\nseq = [1,2,None, True] print(len(seq)) append(): 원소를 추가한다. 뒤에 추가된다.\nextend(): list를 추가한다. 뒤에 추가된다.\ninsert(index,value): index에 value를 추가한다.\ndel: list의 element를 삭제한다. method나 operator형태가 아니다.\na = [1,2,3] del a[1] print(a) remove(value): list의 method. list의 특정 값을 삭제한다. 하나만 삭제한다. 동일한 값이 또 있어도 삭제하지 않는다.\na = [1,\u0026#34;sth\u0026#34;,23, \u0026#34;sth\u0026#34;] a.remove(\u0026#34;sth\u0026#34;) print(a) python은 모든것이 object이고, 모든 function은 method다. 강사는 내장함수와 메소드를 나누어 설명한다. 또한 예약어를 말하기도 한다. 나는 내장함수도 method라고 생각한다. 그런데, fluent python이란 책에서는 len은 method가 아니라고 한다. 예약어는 ()를 사용하지 않는다. 내장함수(built-in function) len() sum() range() method .append() .insert() 예약어 del assert 강사는 예약어, 내장함수, method, 내부 library, third-party의 순서로 원하는 기능을 구현한 함수를 찾으라고 한다. list의 time complexity big-Out 표기법\nbig-O는 함수는 아니고, 표기법이 함수 형태일 뿐이다. 나는 big-O의 O가 out(결과)를 나타낸다고 생각한다. 입력 argument의 개수를 I로 표시하기로 했다. I(N) = O(1) : n개의 입력이 있다면, 1번의 computation이 일어날때 이렇게 표기한다. 이 말은 무한의 데이터가 있어도, 1번만 혹은 10번만 computation하면 된다는 말이다. 즉 input의 개수와 상관이 없다. O에 N이 포함이 안되었다는건 관련이 없다는것이다. 무한대의 입력이 있으나, 없으나 상관이 없다. I(N) = O(logN) : n개의 입력이 있다면, logN번의 computation이 일어날때 이렇게 표기한다. ex) 16개의 입력이 있다면, 4번만 계산하면 된다. I(N) = O(N): n개의 입력이 있다면, n번의 computation이 일어난다. I(N) = O(NlogN): n개의 입력이 있다면, NlogN의 computation이 일어난다. I(N) = O(N^2): 보통 double loop I(N) = O(N^n): list의 operator와 big-O 표현법\nindex: l[i] =\u0026gt; O(1) index는 list의 원소를 꺼낼때, O(1)이 걸린다. 즉 한번에 데이터를 꺼낼수 있다는 말이다. linked list나 lisp을 사용하는 입장에선 조금 이해가 안 갈 수가 있다. 100개의 item으로 구성된 list에서 하나의 원소를 꺼낼때, list의 첫번째 원소가 원하는 값이면 1번의 계산, 최악의 경우 마지막 원소와 일치한다면 100번의 이동이 필요하다. 따라서 O(N)을 예상한다. 그런데 python에선 O(1), 마치 array와 같은 속도를 보인다고 하니까 놀랠 수 밖에 없다. array가 O(1)의 속도를 갖는 것은 address와 index를 더해서 특정 메모리공간을 지정할 수 있기 때문이다. 즉 한번의 덧셈만 하면 된다. 그런데 linked list에서는 그렇지 않다. 매번 list item을 거쳐가야 한다. 어떻게 O(1)이 나오는지는 모르겠다. python에서 list는 동적배열(dynamic array)라서 가능하다고 하는데, 아직 설명이 없다. 참고로 list operator의 입력으로는 list가 들어간다고 생각하면 된다. store: l[i] =\u0026gt; O(1) store도 array처럼 현재 address + index로 특정 메모리 공간을 한번에 지정이 가능하기 때문에 O(1)이다. len: len(i) =\u0026gt; O(1) 왜 length가 O(1)인지 모르겠음. append: l.append(5) =\u0026gt; O(1) append는 list의 마지막에 추가하는것이기 때문에 list객체가 1000개의 item이 있던, 10000개가 있던간에 O(1)이 될 것이다. pop: l.pop(n) =\u0026gt; O(1) pop 함수는 n번째 요소를 제거한다. 그리고 꺼낸 요소를 반환한다. array라면, index와 address를 사용해서 item의 위치를 지정할 수 있기 때문에 한번의 연산으로 해결될 수 있을껄로 보인다. clear: l.clear() =\u0026gt; O(1) list의 clear()는 모든 요소가 제거된다. 그런데 왜 O(1)이 걸릴까? list 객체가 가진 value에 list가 pointer로 연결되어 있다면 그 Value값을 0로 만들면 되는 것이기 때문이지 않을까? insert: l.insert(n,v) =\u0026gt; O(N) list의 특정 index에 특정값을 입력하는것은 최선의 경우는 마지막원소 끝에 insert하면 하나의 list cell을 추가 하기 때문에 1번의 계산이면 된다. 최악의 경우, 첫번째 item에 삽입하면, 그 뒤의 요소들을 하나씩 뒤로 이동 시켜야 하기 때문에 O(N)이 된다. delete: l.delete(n) =\u0026gt; O(N) delete도 list의 특정 item을 삭제하고, list의 item별로 위치 재조정을 하기 때문에 O(N)이 걸린다. remove: l.remove(value) =\u0026gt; O(N) remove함수는 value를 list에서 찾아서 삭제한다. 최악의 경우 list 마지막 item에 원하는것이 있을 수 있다. 이 경우 마지막까지 원소를 비교해야 하기 때문에 O(N)이 걸릴 수 있다. 동적 배열에 대해서 list를 array로 만든다. linked list가 아닌, array다. array가 가진 특징인 fixed된 array와 다르게 dynamic array는 특정길이의 array가 할당되지만 할당된 크기를 넘어가면 자동으로 array가 늘어나는 방식이다. 이것은 lisp의 vector와 비슷할 것이라고 생각된다. Tuple tuple의 특징 tuple의 모양: ()를 사용한다. ,로 사용해도 된다.\nt = (1,2,3,4) t = 1,2,3,4 print(t) tuple은 immutable하다.\nassign이 불가능하다.\nt = (1,2,3,4) # t[3] = 8 ;; 실행되지 않는다. immutable하기 때문이다. immutable은 update가 안된다. assign이 가능할 수도 있다.\nt = (1,2,[5,6,7]) t[2].append(8) print(t) 함수 return값으로 사용된다. 아래와 같이 여러 값을 return할 수 있다.\nreturn 1,2,3 하나의 요소를 가진 tuple\nt = (1) # tuple이 아니다. int다. print( type(t)) t = (1,) # tuple이다. print(type(t)) string은 immutable하다는 면에서 tuple로 봐도 된다.\npacking과 unpacking packing: 여러 데이터를 묶기, unpacking: 여러 데이터를 풀기\nt = 1,2,3,4,5 ;; packing a,b,c,d,e =t ;; unpacking print(d) unpacking의 관습: _를 사용해서 필요없는값은 사용하지 않는다.\nt = \u0026#34;holy\u0026#34;,1,2,3 name,_,_,_ = t print(name) unpacking과 packing은 list에서도 가능하다.\nt = [\u0026#34;holy\u0026#34;,1,2,3] name,_,_,_ = t print(name) 특이한 unpacking: *를 사용해서 나머지 해당 요소들을 list로 묶는다.\nt = [1,2,3,4,5] a, *b, c =t print(a,b,c) dictionary dictionary의 특징 {}을 사용한다.\ndictionary는 사전형태다. 즉 key를 사용해서 빠르게 찾는게 가능하다.\ndictionary는 mutable하다.\n요소는 key: value로 되어있다.\nkey는 immutable하다.\n{key1: value1, key2:value2, key3:value3} example\ndictionary = { 1: \u0026#39;something\u0026#39;, (1,2.5): 1.5, \u0026#39;text\u0026#39;: 2, } print(dictionary[1,2.5]) 위의 예에서 (1,2.5)라는 key가 있고, 이 key값에 접근할 때, dictionary[1,2.5]라는 표기를 눈여겨 볼 필요가 있다. 왜냐하면, key가 tuple이기 때문에 ()없이 사용할 수 있다.\n만일 a[1,2,3], dict[a,[1,2],3:5] 이런식의 표현법을 보면 key가 tuple이라고 생각하면 된다.\ncomma(,)에 대해서\ndictionary를 만들때나 list, tuple의 마지막 원소 다음에 ,를 입력해도 아무 문제 없다. dictionary 기본 동작 dictionary의 생성\ndictionary = {} dictionary의 삽입\ndictionary = {} dictionary[\u0026#39;text\u0026#39;] = 1 dictionary[\u0026#39;list\u0026#39;] = [5,6,7] print(dictionary) 동일한 key값을 갖는 item은 생성 불가능, overwrite된다.\ndictionary = {} dictionary[\u0026#39;key\u0026#39;] = \u0026#39;value\u0026#39; dictionary[\u0026#39;key\u0026#39;] = \u0026#39;updated value\u0026#39; print(dictionary) dictionary item제거: del을 사용한다.\ndictionary = {} dictionary[\u0026#39;key1\u0026#39;] = \u0026#39;value1\u0026#39; dictionary[\u0026#39;key2\u0026#39;] = \u0026#39;value2\u0026#39; del dictionary[\u0026#39;key2\u0026#39;] print(dictionary) len으로 크기 확인\nlen(dictionary) dictionary의 변환\ndictionary을 list로 변환할 수 있다. 이 때 items()라는 method를 사용한다. key와 value는 tuple형태로 list의 item으로 들어가게 된다. dictionary = { \u0026#34;한국어\u0026#34;: 0 , \u0026#34;영어\u0026#34;:1, \u0026#34;중국어\u0026#34;:2} print(dictionary.items()) key만 list로 만들 수 있다. 이 때 keys()라는 method를 사용한다.\ndictionary = { \u0026#34;한국어\u0026#34;: 0 , \u0026#34;영어\u0026#34;:1, \u0026#34;중국어\u0026#34;:2} print(dictionary.keys()) value로만 list를 만들 수 있다.\ndictionary = { \u0026#34;한국어\u0026#34;: 0 , \u0026#34;영어\u0026#34;:1, \u0026#34;중국어\u0026#34;:2} print(dictionary.values()) in을 사용하는 경우\n어떤 collection의 특정 요소가 있는지 없는지 확인할때나, loop를 돌릴때 in keyword를 사용한다. dictionary와 in과는 어떤 관계가 있을까? in의 뒤에는 보통 list가 있어야 한다. in뒤에 dictionary를 직접 사용하지는 않는다. 따라서 dictionary를 list형태로 바꿔야 한다. 그래서 keys(), values(), items()라는 메소드가 존재하는 것이다. dictionary를 list로 변환후 in을 사용해서 특정값의 존재 여부를 확인할 수 있다. 여기서 2가지를 더 말하고 싶다. 첫번째로 dictionary라는게 어차피 key를 통해서 값을 꺼내면 되는건데, 굳이 in을 써서 값을 확인하기 위해 list로 변환해야 하는가? 하는 의문이 들수 있다. key를 알고 있다면, 별문제 없지만, key를 잘못썼거나, key를 모를때는 dictionary에서 key list를 뽑아서 in을 사용해서 check하는것은 그리 나빠보이지 않는다. 두번째로 in이라는건 이렇게 있는지 없는지 여부의 기본 기능보다 for-loop에서 많이 쓰인다. dictionary를 for-loop에서 사용한다고 했을때, in을 사용한다. 따라서 dictionary를 list형태로 바꿀 필요가 있다. 즉 dictionary와 in을 같이 사용한다는 것은 list로 변환해서 사용한다는 것을 의미한다. dictionary = { \u0026#34;한국어\u0026#34;: 0 , \u0026#34;영어\u0026#34;:1, \u0026#34;중국어\u0026#34;:2} print(\u0026#34;한국어\u0026#34; in dictionary.keys()) dictionary의 time complexity dictionary는 key마다 index값이 있다. index가 있다는 말은 address로 접근 한다는 뜻이다. 따라서 value에 접근하는 time complexity는 O(1)이다. 이것을 hash구조라고 한다. index: d[k] =\u0026gt; O(1) key로 값을 가져오는것은 dictionary의 크기가 엄청 커도 1번의 computation으로 가능하다. store: d[k] = v =\u0026gt; O(1) length: len[d] =\u0026gt; O(1) delete: del d[k] =\u0026gt; O(1) clear: d.clear =\u0026gt; O(1) d = {} or d= dict()와 같다. Set set 개념 dictionary의 key만 모여 있는 형태.\nset을 만들때, list를 사용한다.\ns = set([1,2,3,\u0026#39;text\u0026#39;]) print(s) set에 원소 추가\ns = set([1,2,3]) s.add(4) print(s) set 원소 삭제(remove)\nset 원소에 해당하는 값이 있다면 삭제 없다면 error가 생긴다. s = set([1,2,3]) s.remove(2) print(s) set 원소 삭제(discard)\nremove는 값이 없다면 error가 생긴다. discard는 에러가 생기지 않는다. s = set([1,2,3]) s.discard(44) print(s) update 메소드\ns = set([1,2,3]) s.update([5,None, True, False, 33]) print(s) set operator 수학적 집합 연산자 존재.\n교집합(\u0026amp;)\ns1 = set([1,2,3,4]) s2 = set([3,4,5,6]) print(s1 \u0026amp; s2) 합집합(|)\ns1 = set([1,2,3,4]) s2 = set([3,4,5,6]) print(s1 | s2) 차집합(-)\ns1 = set([1,2,3,4]) s2 = set([3,4,5,6]) print(s1 - s2) 배타적 합집합(^)\ns1 = set([1,2,3,4]) s2 = set([3,4,5,6]) print(s1 ^ s2) frozen set( immutable)\nset은 mutable하다. 반면 frozen set은 immutable하기 때문에 dictionary key값으로 사용할 수 있다. a = frozenset([1,2,3]) d = {a:3} print(d) ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture3_data-structure\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture4_condition-and-loop\/": {
        "title": "lecture4_condition-and-loop",
        "tags": [],
        "content": "Condition \u0026amp; Loop 조건문은 if else, 반복문은 while-for 들여 쓰기: space 4칸, tab을 써도 된다. Conditional Statement if문 사용법1 - if,elif,else 사용법 if를 사용해서 원하는 조건을 만족하면 수행하게 한다.\nexample 1\nscore = 80 if score \u0026gt; 60: print (\u0026#34;Over 60\u0026#34;) if score \u0026gt; 70: print(\u0026#34;Over 70\u0026#34;) if score \u0026gt; 80: print(\u0026#34;Over 80\u0026#34;) 위에서 보듯이 조건에 맞으면, 출력을 한다. example 2\nexample1에서 보면, 3가지 case가 있다. 이 중에 맞는 경우가 2가지가 있다. 이럴 때, 만족하는 모든 case를 출력하지 않고 하나를 만족하면 수행을 하지 않게 하고 싶다면, elif를 사용한다. score = 80 if score \u0026gt; 60: print (\u0026#34;Over 60\u0026#34;) elif score \u0026gt; 70: print(\u0026#34;Over 70\u0026#34;) elif score \u0026gt; 80: print(\u0026#34;Over 80\u0026#34;) example 3\n만일 모든 조건을 만족하지 않을 때, 조건을 만족하지 않습니다.라는 메시지를 내보낼려면 어떻게 해야 하는가? 이 때, else를 사용한다. score = 10 if score \u0026gt; 60: print (\u0026#34;Over 60\u0026#34;) elif score \u0026gt; 70: print(\u0026#34;Over 70\u0026#34;) elif score \u0026gt; 80: print(\u0026#34;Over 80\u0026#34;) else: print(\u0026#34;wrong value\u0026#34;) if문 사용법2 - false에 해당하는 것들 false에 해당하는 값들. if False: print(\u0026#34;This sentence does not show\u0026#34;) if \u0026#34;\u0026#34;: print(\u0026#34;Empty is False\u0026#34;) if 0: print(\u0026#34;0 is False\u0026#34;) if None: print(\u0026#34;None is also False\u0026#34;) if문 사용법3 - 비교연산자와 논리연산자의 사용 example\na,b = 5,8 if a == 5 and b ==6: print (\u0026#34;This is False\u0026#34;) if not a \u0026lt; b \u0026lt; 9: print(\u0026#34;This is False\u0026#34;) if a + 3 == b: print(\u0026#34;This is True\u0026#34;) 여기서, a,b = 5,8을 보는 순간, tuple의 unpacking임에 익숙해 져야 한다. 생소하게 바라보면 안된다. ternary operator 사용법 [value1] if [Condition] else [value2] 형태. if else문인데, 생소하다. condition이 참이면 value1을 거짓이면 value2를 반환 연산자이다.라고 강사가 말했는데, 왜 연산자인지 모르겠다. 연산자 운선순위에서 가장 아래에 위치한다. 햇갈리지 않게 하기 위해서 괄호를 사용한다. value = 32 \u0026#34;odd\u0026#34; if value % 2 else \u0026#34;even\u0026#34; 연산자라 다른 연산자와 같이 사용될 수 있다고 한다. value =32 print((\u0026#34;odd\u0026#34; if value % 2 else \u0026#34;even\u0026#34;) + \u0026#34;_number\u0026#34;) Loop loop의 기본 생각은 연산을 100번 200번 적용하는 방법이다. 함수를 100번 호출하겠다. 200번 호출하겠다. 이럴때 loop를 사용한다. while while 사용법\n기본 모양\n​- while \u0026lt;조건\u0026gt;: 명령1 명령2 example\n조건을 만족하는 동안 수행한다. i = 1 while i \u0026lt; 4: print(i) i = i+1 for 기본개념\n주어진 객체를 순환하는 개념 while의 반복은 연산을 몇번 수행한다는 제어문이 포함되어 있지않다. for loop은 몇번 반복 할지를 설정하고, 몇번 반복했는지를 알 수 있는데, 이를 이용할 수도 있다. for [element] in [Iterable]의 형태로 사용 list 기본 사용예\nlist 사용 example1 for i in [0,1,2,3,4]: print(i) example2 for i in [0,1,2,3,4]: if i % 2: print(i, \u0026#34;is odd\u0026#34;) list range iterator 사용예\nrange 사용\nfor-loop에서 list를 사용하는건 비 효율적.\n100번 반복하고 싶다고 해서 0~99까지 list를 작성하는건 비효율적.\nrange라는 내장함수를 사용. generator를 반환한다.\ngenerator는 숫자를 하나씩 생성 반환한다.\nfor-loop에서 필요한것은 counting. counting을 위해서 list를 사용하면 많은 메모리 필요, generator는 next counting값을 하나만 가지고 있다. 따라서 메모리 효율적.\nrange(start,end,step) 형태.\nrange는 지정된 횟수가되면 error를 발생하고, 이 error를 받아서 loop가 종료된다.\nexample1\nfor i in range (5): print(\u0026#34;test2\u0026#34;, i) range(5)는 0-4까지를 의미한다. example2\nfor i in range(1,6): print(\u0026#34;test3\u0026#34;, i) range(1,6)은 1~5까지를 의미한다. example3 for i in range(1,10,2): print(\u0026#34;Test4\u0026#34;,i) string iterator, dictionary 사용예\nexample1\nfor c in \u0026#34;This is text\u0026#34;: print(c) example2\nfor word in [\u0026#34;한국어\u0026#34;,\u0026#34;문장\u0026#34;,\u0026#34;처리\u0026#34;]: print(word) example3\nfor key in {\u0026#34;text\u0026#34;:1, \u0026#34;word\u0026#34;:2}: print(key) example4\nfor key in {\u0026#34;text\u0026#34;:1, \u0026#34;word\u0026#34;:2}.values(): print(key) example5\nfor key in {\u0026#34;text\u0026#34;:1, \u0026#34;word\u0026#34;:2}.items(): print(key) dictionary를 list로 바꾸는 이유는 in하고 같이 쓰일 때이다. in은 for와 같이 쓰이기 때문에, dictionary를 list형태로 바꿔야 한다. keys(),values()는 자주 변환되는 형태다. 그런데 items()는 어디에 쓰일지 궁금하다. key와 value를 tuple형태의 item list가 어디에 쓰일지도 궁금하다. 이것을 강사가 설명한다. example6에 작성했다. example 6\nfor key, value in {\u0026#34;a\u0026#34;:1, \u0026#34;b\u0026#34;:2}.items(): print(key,value) items()가 반환하는 tuple list를 어떻게 사용하는지 궁금했다. tuple list의 형태로 되어 있는것을 꺼내서 쓸때는 unpacking한다. tuple이기때문이다. tuple을 사용하는 방식은 unpacking이기 때문이다. 그래서 위의 key, value in dictionary 형태로 사용된다. break \u0026amp; continue break\nbreak를 사용하면, 여러개의 loop로 둘러싸여 있더라도 가장 바깥쪽의 loop를 벗어날 수 있다. 강사 자료 오타. range문의 수정. for i in range(1,100): if i % 17 == 0: break print(i) continue\ncontinue문은 loop의 처음으로 되돌아간다. example for i in range(100): if i % 17: continue print(i) loop에서 else\npython의 loop에 있는 특별한 기능\nelse를 loop와 같이 사용할 수 있다. 반복문이 끝났을 때 실행되는 block으로 보면된다.\nexample\nfor i in range(10): print(i) else: print(\u0026#34;loop complete with break\u0026#34;) 0-9까지 loop를 돌고 \u0026ldquo;loop complete with break\u0026quot;를 출력한다. example2\nfor i in range(10): print(i) if i \u0026gt; 5: break else: print(\u0026#34;loop complete without break\u0026#34;) else는 for block안에 있진 않다. 그래서 break문으로 for loop를 벗어난다면, else블럭이 실행되야 한다고 생각하지만, 실행되지 않는다. 이걸로 알 수 있는건 for block과 else블럭은 연관되어 있다고 볼 수 있다. ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture4_condition-and-loop\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture5_function\/": {
        "title": "lecture5_function",
        "tags": [],
        "content": "function python에서 모든것은 객체다. function은 method이면서 객체다. function이 method인건, 내부인자로 self를 넣을 수 있다는것만 봐도 객체의 method다. object의 method다. function 그자체는 symbol object의 구조를 갖기 때문에 또한 객체다. 내가 봤을 때는 lisp의 symbol structure를 그대로 가져온 듯하다. lisp에서 function은 symbol structure에 저장된다. 마치 symbol을 object로 말한다는 느낌이다. 참조:https://medium.com/swlh/everything-is-an-object-in-python-learn-to-use-functions-as-objects-ace7f30e283e 변수의 경우, assignment(=) operator로 객체를 만들었다면, function의 경우 def란 keyword로 function객체를 만드는 거 같다. 함수가 호출된다는 것은 이미 function객체가 어딘가에 만들어져 있다는 것이다. 함수 호출시 값을 전달할때 값을 stack에 넣고, function definition의 argument와 binding될 꺼 같은데, function definition의 argument는 global,nonlocal로 선언되었는지, 아니면 그냥 local 변수인지 모르겠다. python interpreter는 def를 보면, name,body에 해당하는 function값을 객체로 만든다. 호출할때 만드는게 아니라, def를 보고 만들거나, 이미 만들어져 있다. 만들어진 객체들은 symbol table(name space)에 저장된다. 혹은 저장되어 있다. def로 함수를 정의할때 함수의 인자들은 body에 있는 local 변수로 보면된다. 함수 호출이 일어나면, stack에 parameter를 넣어두고, body를 실행하는데, 이때, argument를 하나씩 binding시키면서 처리가 된다. function의 기본구조 def name(arg1,arg2...): statement1 statement2 return [value] return값이 없는 경우 None값이 return된다.\nexample\ndef rectangle_area(x,y): return x * y row = 10 col = 100 print(rectangle_area(row,col)) print(rectangle_area(20,1.5)) 여기서 눈 여겨 봐야 할 것은 x,y는 동적 typing이 된다는 사실이다. 함수가 호출되서 객체가 만들어 질때, x,y에 해당하는 값들이 eval되어 전달 된다. 첫번째는 10,100이 전달되고, 두번째는 20,1.5가 전달된다. 전달 되면 binding이 된다.즉 assignment가 실행되는데, assignment는 rvalue에 해당하는 값(여기선,10 or 100)의 type을 가져온다. 즉 int를 가져오기 때문에, 만들어지는 객체는 int객체가 만들어지고, 그들의 이름은 x,y가 되는 것이다. 따라서 return값도 int가 된다. 두 번째 함수에서는 float가 된다. 동적 typing에 따라서 만들어지는 객체 type이 결정되는 과정을 알 필요가 있어서 적었다. call by reference 구조의 문제점. 함수를 호출할때, 인자 전달을 할때 주소를 전달할 때, call by reference라고 한다. 값을 전달하면 call by value.\npython에서 call by reference 사용예라고 보여준다. 그런데 난 이 설명이 잘못되었다고 생각한다.\nexample\ndef function(seq2): seq2 += [1] seq1 = [1,2,3,4,5] function(seq1) print(seq1) seq1은 [1,2,3,4,5]와 binding되어 있다. 즉 seq1의 이름을 갖고, list [1,2,3,4,5]값을 갖는 객체다. 함수 호출을 하면 argument와 binding을 한다. binding하면, seq2의 이름을 갖고 list [1,2,3,4,5]의 값을 갖는 객체가 만들어진다. 여기서 seq2에대한 operator(+=)연산을 한다. operator는 해당 객체의 값을 update한다. 따라서 seq2의 값인 [1,2,3,4,5]를 [1,2,3,4,5,1]로 update한다. 여기서 중요한것은, seq1의 값은 list 객체이고, seq2의 값도 list객체를 값으로 갖는다. seq2에서 list객체의 값을 update했기 때문에 seq1이 참조로 하는 list는 변경되게 된다.\n그리고 call by reference는 function에서 수정한 값이 function밖의 값에 영향을 미치는 side-effect가 존재한다. 따라서 권장되지 않는 방식이라고 한다. 그리고 그것의 해결법을 강사는 제시한다.\ncall by reference 문제의 해결. example\ndef function(seq2): seq2 = list(seq2) seq2 += [1] seq1 = [1,2,3,4,5] function(seq1) print(seq1) 강사가 제시하는 해결책은 list객체를 전달해서 seq2객체가 만들어지고, 내부에서 수정할 수 없게 새로운 객체를 만들어 사용하자.인데, 내 경우 seq += [1]이라는게 기본적으로 객체의 값을 udpate하는 operator이기 때문에, assignment로 만들면 새로운 객체가 생성될 것이기 때문에 굳이 list()으로 새로운 객체를 만들 필요가 없다는 생각이다.\nexample\ndef function(seq2): seq2 = seq2 + [1] seq1 = [1,2,3,4,5] function(seq1) print(seq1) [1, 2, 3, 4, 5] variable scope variable scope의 예 example\nvar1 = 10 var2 = 20 def function(var2): var2 += 1 print(var1 + var2) function(var2) print(var2) 여기에서 function안에 있는 var1과 var2를 보면 외부에 있는 var1을 참조한다. 이것은 lisp과는 다르다. lisp에서는 전역변수를 참조하지 못한다. scope를 벗어나기 때문이다. 그러나, python은 여타 다른 언어와 비슷하게 참조가 가능하다. variable scope예2 example\nvar1 = 1 def main(): var2 = 10 def function(): var3 = 100 print(var1,var2,var3) function() print(var1,var2) main() print(var1) 여기서 매우 재밌는 형태의 함수가 사용된다. 즉 함수 안에 함수가 있다. 여기서 global 변수라는 것은 다른 file에서 접근해서 사용할 수 있다고 한다. 반면에 local에 있는 변수들은 local scope 밖에서 참조는 불가능하다. global과 nonlocal의 사용 global\npython의 scope와 관련한 keyword중에 global이란게 있다. 이것은 말 그대로,local변수를 전역변수로 만들겠다는 의미다.\n그런데, 다른 쓰임이 한개 더 있다. example2에서 설명한다.\nexample1\ndef test(): global a a =3 b =2 return a+b test() print(a) 위에서 보면 a를 global로 선언했다. 이말은 local에 정의된 a라는 변수는 global변수로 만들겠다?라는 의미다. 따라서, a =3은 local에서도 접근 가능하고, print(a)에서도 접근 가능하다. example2\n또 다른 예를 들어 보자. a = 1 def test(): a = 3 b = 2 return a+b print(a) 그냥 정상적인 코드다.\n하지만, 우리가 다른의도를 가지고 있다면? 즉, test안의 local변수 a를 생성해서 쓰고싶은게 아니라, global변수 a의 값을 변경하고 싶을때 어떻게 할 것인가? 그런데 a =1 이라고 생성된 객체는 immutable하기 때문에 test()내에서 변경자체가 안되는데 무슨 소리야라고 할 수 있다. 하지만, global로 선언하면 비슷한 효과를 낼 수 있다. 비슷한 효과라기 보단, 내 생각엔 global로 선언한다는 의미가, a =3이라는 문장에서 객체를 만들면, global에서도 a라는 새로운 객체가 만들어진다고 생각한다. 그래서 이전에 a=1로 생성한 객체는 접근할 수가 없다. 새롭게 a라는 이름을 가진 객체를 만들었기 때문이다.\na = 1 def test(): global a a = 3 b = 2 return a+b print(test()) print(a) 결론적으로 local scope내에서 global로 선언하면 local scope 외부에서 참조할 수 있다.라고 보면된다. nonlocal\nnonlocal도 local변수를 local scope외부에서 만들겠다는 의미다. global하고 비슷하다. 다만, global은 top-level의 전역 scope를 갖게 한다면, non-local은 local scope의 바로 바깥 outer scope를 의미한다.\n이것을 설명하기위해 예를 든다면, 중첩 function을 사용해야 한다.\nvar = 1 def main(): var = 10 def function1(): global var var += 1 def function2(): nonlocal var var += 1 function1() function2() print(var) main() 여기에서 global과 nonlocal이 같이 쓰였다. function1이 호출되면, var변수는 global에서 생성된다. function2가 호출되면, var변수는 바로 바깥쪽 scope에서 생성된다. 전체 과정을 살펴보자. 전역변수 var은 1값을 갖는다. main()가 호출된다. local변수 10값을 갖는 var이 만들어진다. function1()이 호출된다. local과 global에 var변수를 생성한다 값은 11을 갖는다. main의 local변수인 var은 읽기만 할뿐이다. function2()를 호출한다. function2의 nonlocal은 main에 있는 var값과 동일한 이름의 var변수를 만든다. 그 값은 11이된다. print(var)은 (7)에의해 11값을 출력한다. variable capture 우선 용어의 의미는 잘 모르겠다. 예제를 보자.\nvar = 1 def function(): print(var) var += 1 function() 여기서 var +=1은 2가되고, function에선 var값을 출력한다. 강사는 말한다. 이것은 pure function이 아니라고, function의 연산은 주어진 argument를 계산하고 return해야 하는데, 외부에서 변경될 수 있는 변수가 함수를 control하고 있다는 것이다. 이것은 전역변수에 의해 control되는 function도 동일한 의미를 갖는다.그래서 pure function이 아니다. 함수형언어에서 variable capture라는 용어가 있다고 한다. 환경이라는 말과, closure라는 말이 나온다. 정확히는 모르겠다. 이런형태의 코드는 피하라고 한다. closure closure example1\n강사가 closure를 설명하면서 환경얘기를 많이 하는데 뭔소린지 모르겠다. 예제를 보자.\nexample\nnumber = 10 def print_closure_factory(number): def print_closure(): print(number) return print_closure print_5 = print_closure_factory(5) print_10 = print_closure_factory(10) number += 10 print_5() print_10() python에서는 function은 객체이기 때문에, print_closure_factory라는 객체안에 print_closure라는 객체가 선언된걸로 밖에 안보인다. 그냥 print_closure_factory(number)를 호출하면 함수가 return값으로 나온다는 것밖에 모르겠다. 왜냐면 여기서 이렇게 복잡하게 짤 필요가 없기 때문이다. 그냥 argument를 갖고, return값을 갖는 하나의 함수를 만들어서 사용하면 된다. 굳이 이렇게 짤 필요가 없다. 이것은 예제가 잘못된거 같다. 굳이 closure로 설명할 필요가 없다. closure를 보면 lazy evaluation이 생각난다. 함수 내부의 함수로 정의되며, return이 함수인경우 return되는 함수는 바로 evaluation되지 않는다. closure example2\nexample def add(var): return var + 2 def multiply(var): return var * 2 def factory(function, n): def closure(var): for _ in range(n): print(\u0026#34;test\u0026#34;) return var return closure print(factory(add,4)(10)) print(factory(multiply, 4)(3)) closure는 함수를 입력받고, 함수를 출력하는 함수를 뜻하는 것 같다. factory를 보면 인자가 2개다. 함수와, 그 함수를 몇번 수행하겠다는 횟수를 입력받는다. factory의 return값은 함수다. 어떤 함수냐 하면, 반복하는 함수다. 반복하는 함수를 return하는데, 함수명과 반복횟수는 argument로 되어 있고 argument를 이용해서 return하는 함수를 만든다. 실제 실행은 return 받은 함수에 인자를 전달하면 실행이 되게 했다. return 되는 함수의 모양은 인자로 받는 함수와 모양이 비슷하다. argument의 개수가 같다. 여기서 또 한가지 눈에 띄는 부분은 var = function(var)이다. 이게 재귀적인 모습이라고 한다. add,4를 인자로 건네주면 add(add(add(add(var))))과 같은 모양이라고 한다. Decorator Decorator의 개념\n함수를 입력으로 받아서 함수를 return하는데, 같은 이름의 함수로 return하는 함수를 받을때 decorator를 사용한다.\nexample\ndef print_closure_factory(function): def print_closure(var): print(\u0026#34;Input:\u0026#34;, var) out = function(var) print(\u0026#34;Output:\u0026#34;, out) return print_closure def add(var): return var + 2 print_add = print_closure_factory(add) print_add(10) print_closure_factory(add)를 호출한다. 전달되는 add는 function 객체다. 함수가 호출되면서 binding이 일어난다. function은 add라는 function object와 binding된다. body의 function은 add로 바꿔준다. add로 변경한 print_closure function 객체를 return한다. print_add(10)을 계산한다. 이것은 decorator를 사용하지 않았다.\ndecorator 사용 예\nexample\ndef print_decorator(function): def print_closure(var): print(\u0026#34;Input:\u0026#34;,var) out = function(var) print(\u0026#34;Output:\u0026#34;,out) return print_closure @print_decorator def add(var): return var + 2 add(10) 우선 @print_decorator라는건 위의 function를 인자로 받아 function을 return하는 함수를 사용하겠다는 뜻이다. 두번째로 @print_decorator 아래는 add라는 함수와 add(10)이라는 문장이 있다. add함수는 인자로 들어가고, return값은 add라는 이름으로 받겠다는 뜻이다. 그리고 10 값을 주어 출력하겠다. Decorator의 또다른 예\nDecorator에 argument를 사용하는 경우. decorator라는것은 함수를 입력받아 함수를 return하는 것을 간략화 한것이다.\ndecorator를 선언하고 아래의 인자를 전달해서 closure를 return받아야 하는데, 그전에 먼저 decorator함수를 wrapping할 수 있다고 한다.\n즉 먼저 decorator(인자)를 수행하면, 인자값이 해당 closure에 적용된다. 이렇게 적용한 후, 다시 아래의 인자를 적용해서 함수를 return받는다.\nexample\ndef times_decorator_factory(times): def times_decorator(function): def closure(var): for _ in range(times): var = function(var) return var return closure return times_decorator @times_decorator_factory(5) def add(number): return number + 2 print(add(5)) 구조가 복잡한데, 우선 @times_decorator_factory(5)를 실행하면, times가 5로 바뀌고, times_decorator가 return받는다. return 받은 times_decorator는 또다른 decorator다. 즉 def times_decorator(function)이 된다.\n이 상태에서 아래에 있는 add함수가 인자로 decorator에 넘겨진다. function이라는 argument가 add로 replace되면서 closure를 return 받는다. return 받은 함수는 동일한 이름인 add를 갖는다.\ndecorator를 사용하면 동일한 이름의 함수를 return 받는다.\ndecorator의 주의 사항\nexample\ndef print_decorator(function): def print_closure(var): print(\u0026#34;Input:\u0026#34;, var) out = function(var) print(\u0026#34;Output:\u0026#34;, out) return print_closure @print_decorator def add(var): return var +2 print(add.__name__) decorator를 사용하면 동일한 이름으로 넘겨받은 함수객체를 사용할 수 있다고 했다. 하지만, 넘겨받은 함수객체는 function name을 가진 객체다. add.__name__은 넘겨받은 객체의 이름이다. 그렇다면 add는 무엇인가? add가 넘겨받은 함수객체와 binding이 되었다면, add.__name__은 add가 되어야 하는게 맞을 것이다. 그런데 어떤 과정으로 이것이 이렇게 되었는지는 모르겠다. appropriate Decorating\n위의 예에서 function 객체의 이름이 add가 아니고 return받은 function객체의 이름이였다. 이것을 수정하려는 것 같다.\nfrom functools import wraps def print_decorator(function): @wraps(function) def print_closure(var): print(\u0026#34;Input: \u0026#34;, var) out = function(var) print(\u0026#34;Output:\u0026#34;, out) return print_closure @print_decorator def add(var): return var + 2 print(add.__name__) 여기서 @wraps(function)라는 함수를 사용해서 입력받은 함수의 이름을 꺼내서 함수 객체를 만들때 이름으로 넣는것 같다. Recursive function factorial example def factorial(n): if n == 1: return 1 return n * factorial (n - 1) print (factorial(5)) function의 parameter parameter 사용법1 def function(var1, var2): print(var1, var2) function(var2 = 10, var1 = 15) parameter 사용법2 def function(var1, var2 = 20): print(var1, var2) function(10) function(var2 = 10, var1 = 15) parameter 사용법3 def function(var1, var2 = 20, var3): print(var1, var2,var3) 위의 예는 잘못된 case다. var2=20으로 default값이 있는경우 뒤에 옮겨야 한다. variable Length Parameter 인자의 개수가 많을 경우 남는 인자를 packing해서 사용할 수 있다.\n가변인자라고 하는데, 가변인자는 맨마지막에 한개만 위치 가능하다.\n반드시 *args라고 할 필요는 없다. *a로 해도 상관없다.\n넘겨받는 값이 몇개인지 알수 없기 때문에, stack에 있는 값들을 pointer로 전달하겠다는 뜻이다. 이렇게 하면 stack에 있는 나머지 값들이 tuple형태로(참고로 tuple은 array다.) 함수에 전달된다.\nkwargs라는 keyword argument하고 햇갈리면 안된다. *args는 stack에 올라온 값만 있는 argument를 pointer로 전달 받는다. 만일 stack에 keyword가 있는경우는 전달 받지 못한다.\nexample\ndef add_all(a,b,*args): print(args) sum = 0 for elem in args: sum += elem return a + b + sum print(add_all(1,2,3,4,5)) 함수 호출시 전달되는 (1,2,3,4,5)라는 parameter는 stack에 저장된다. 그리고 함수의 body에 대한 처리가 시작된다. 함수 정의시 지정한 argument들은 local변수이다. 표기만 ()안에 표기했을뿐 실제는 local변수와 똑같다. 따라서 stack과 body에 있는 local변수의 binding이 제일 먼저 실행된다. a =1, b=2, args=(3,4,5)이렇게 처리가 된다. args는 packing된 tuple이기 때문에 unpacking을 해줘야 한다. keyword variable length parameter 명시적으로 지정된 parameter가 남는다면, 키워드 가변인자 **(Double asterisk)를 사용하여 남는 keyword변수를 packing할 수 있다. example1 def print_args(a, *args, **kwargs): print(args,kwargs) print(print_args(1,2,3,var1=100,var2=200)) example2 parameter에는 순서가 있다. 일반인자 -\u0026gt; 기본값인자 -\u0026gt; 가변인자 -\u0026gt; 키워드 가변인자 가변인자가 tuple로 packing되었다면, keyword가변인자는 dictionary로 packing이 된다. def function(var1, var2=10, *args, **kwargs): print(var1,var2,args,kwargs) function(1,2,3,var3 =10) parameter unpacking example1\nfunction의 argument에 *가 있으면, 함수호출시 전달되는 parameter를 packing해서 받는다면, 함수 호출시 인자가 *가 있는 경우 unpacking해서 stack에 넣어야 한다. def function(a,b,c): print(a,b,c) l = [1,2,3] function(*l) example2\ndictionary를 인자로 packing해서 호출한다. packing해서 호출하는게 엄청 자주 쓰인다. def function(var1,var2,**kwargs): print(var1,var2,kwargs) d = { \u0026#39;var1\u0026#39;:10, \u0026#39;var2\u0026#39;:20, \u0026#39;var3\u0026#39;:30 } function(**d) typing hints type을 명시하지 않는다면, 가독성이 떨어진다.\nfunction의 인자와 return값에 대한 type을 명시할 수 있다.\nexample\ndef multiply_text(text: str, n: int) -\u0026gt; str: return text * n example\nvariable에도 type을 달 수 있다. a: int =4 s: str =\u0026#34;a\u0026#34; function에 대해서 (내생각) 가끔 보면, len()같은 경우 어디선 len()가 function으로 define되어 있다고 생각할 텐데, method로 정의 되어 있을 수 있다는 것을 알아야 한다. __로 시작하는 dunder method의 경우 객체.method로 접근이 안된다. 왜냐면 __로 이름이 시작되면 mangling된다. mangling된다는 것은 이름이 변경된다는 것이다. __라는 이름으로 access할 수 없다. 이런 dunder method는 사용법도 다르다. 예를 들어, a()는 method가 어떤 class에 정의되어 있다면, a(객체) 이런 식으로 사용된다. 따라서 모양만 보곤, a라는 function이 어딘가에 정의되어 있다고 생각하겠지만, 인자로 들어가는 객체 class에 __a라는 dunder method일 확률이 높다. 내생각에 python에서 모든 function은 특정 class의 method일거 같다는 생각이다.\n우리가 function을 사용하는 이유 우리가 programming을 작성하다보면, 대부분의 작업이 유한개의 data sequence를 입력을 받고, 입력받은 data를 for-loop과 if를 사용해서 다른 형태의 data sequence로 만든다던가, 값을 출력하는 일이다. 이것을 python에서는 내장 method나 외부 library의 method들이 내부적으로 이런 일을 한다. function은 일반화 한단 말을 많이 한다. 일반화 한다는 것은 여러개의 data에 모두 통용되는 계산이기 때문에, 보통은 많은 data를 처리할수 있는 기능이 있다. 그래서 for-loop를 내부적으로 처리한다. 내가 하고 싶은 말은 function이나 method를 작성할때도 고려해야 하지만, 사용할때, 내가 사용하는 함수가 내부적으로 data sequence를 입력받고 for-loop과 if를 처리한다는 것을 염두에 두어야 한다. 외장 function이나 우리가 가져다 쓰는 function들은 대부분 우리가 for-loop if로 처리해야 할것을 미리 해둬서 그냥 가져다 쓰기만 하게 만든 것이기 때문이다. 우리가 for-loop과 if를 사용할 일이 있다면, function을 찾아보고 사용하면 된다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture5_function\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture6-pythonic-programming\/": {
        "title": "lecture6-pythonic programming",
        "tags": [],
        "content": "Pythonic Programming for-in-iterator-loop, iterator,generator in predicate \u0026lsquo;in\u0026rsquo; keywords를 사용하는 건 2가지가 있다. predicate으로 in과 for-in-loop에서 사용이 있다.\n내가 보기에 \u0026lsquo;in\u0026rsquo;은 rvalue와 lvaue를 취하는 \u0026lsquo;=\u0026lsquo;과 비슷하다. 즉 rvalue와 lvalue를 보고 동작이 결정된다.\n\u0026lsquo;in\u0026rsquo;의 rvalue는 iterable객체가 와야 한다. lvaue는 name이 오거나,값이 와야 한다.\nrvalue test\nfruits = 3 print(\u0026#34;banana\u0026#34; in fruits) in 뒤에 나오는 rvalue는 iterable 객체여야 한다. 아니면, error. test2\nrvalue의 처리 : in 뒤에 객체가 iterable하다면, __self__로 객체를 얻어와서 __next__를 호출하면 값이 return된다. in은 lvalue도 처리한다. 만일 lvalue를 처리하지 않고 rvalue만 처리한다면? 즉 rvalue의 값만 return한다면? # fruits = [\u0026#34;apple\u0026#34;,\u0026#34;orange\u0026#34;] print(\u0026#34;banana\u0026#34; \u0026#34;apple\u0026#34;) 위의 예처럼 rvalue만 처리하는건 위의 경우 처럼, 값만 2개 있는 꼴이다. 즉 lvalue를 처리해야 한다. lvalue가 값인경우 비교해서 true 면 종료된다. 만일 false면 계속 next를 호출해서 비교한다. 즉 rvalue로 return한값과 lvalue값에 is함수를 적용하는 것과 같다. fruits = [\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;] print( \u0026#34;apple\u0026#34; in fruits ) for-in-loop 위에서 봤듯이 in keyword는 rvalue에 해당하는 값을 return후 lvalue와 true가 나올때까지 비교한다. 만일 lvalue가 name이고 for가 있다면, 값을 비교하지 않고 binding을 한다. fruits = [\u0026#34;banana\u0026#34;,\u0026#34;apple\u0026#34;,\u0026#34;orange\u0026#34;] for i in fruits: print(i) range range개념\nrange는 generator다. 즉 함수내부에 yield라는 keyword가 있다. 그리고 function객체다. range라는 generator를 설명하기 앞서 iterator에 대한 간략한 소개가 필요하다. iterator는 객체에 __iter__와 __next__가 구현되어 있고, 내부적으로 cur이란 변수를 갖는다. in keyword에 의해 next함수고 호출되고 next함수는 cur이 가리키는 값을 return한다. 그러면, for는 return한 값을 binding한다. generator도 마찬가지다. in 에 의해서 yield까지 수행하고 값을 return한다. 다음 수행될 주소를 cur에 가지고 있다. iterator와 generator 모두 start,cur,end라는 변수를 가지고 있다는 게 공통점이다. range 사용법\nrange(5) start:0, end:5로 counting된다. range(1,3) start:1, end:3으로 counting된다. iterator와 generator객체의 출력 iterator객체와 generator객체를 출력하기위해서 print문을 사용할 경우, 객체임을 출력하지 , 객체가 가진 내용을 출력하지 않는다. gen1 = (i *2 for i in range(10)) print(gen1) 이럴 때는 list객체로 만들면 출력이 된다. gen1 = (i *2 for i in range(10)) print(list(gen1)) Comprehension과 Generator list나 dictionary같은 것을 만드는 이유는 data의 저장과 사용하기 위해 만든다. 거기에 들어가는 data들은 직접 작성될 수도 있고, code로 만들 수도 있으며, 외부로 부터 가져올 수도 있다(network, file, etc). 여기서는 외부 data는 신경쓰지 않기로 한다.\n우리가 직접 list 데이터를 쓰는건 작은 데이터일 경우, 문제가 되지 않는다. 큰 data일 경우 for-loop을 이용해서 data를 생성해서 list에 저장하는 방식을 쓰거나, 방식은 같지만 list comprehension으로 많은 data를 만들수가 있다. 하지만 for-loop, list-comprehension은 모두 유한의 자료를 대상으로 한다는 것이다. 무한한 자료의 처리는 할수 없다. 무한한 자료의 처리는 실시간 data를 필요하는 경우에는, generator가 필요하다. Generator를 사용하는 이유는 무한의 data를 만들어 낼 수 있다는 데 있다. 예를들어서 경비행기 simulator를 만든다고 하자. 우리는 매번, 온도 습도 고도와 같은 정보를 실시간으로 입력받아야 한다. simulator에서 그런 data가 미리 준비되어 있다고 할지라도, 그 data들은 유한하다. 유한한 data를 나타내기 위해서 list를 직접작성하던, 직접작성하는게 노가다라서 list comprehension을 사용하던 유한의 data밖에 만들어낼 뿐이다. 언젠간 끝이 있다. 실제와 같은 simulator에서는 유한하지 않는 무한한 data가 제공되어야 한다. 그것은 generator로 만들어질 수 밖에 없다. 하지만, 우리가 지금 말할려는 것은 compreshension이다. list를 직접사용하는게 아닌 코드를 이용해서 긴 list를 만드는 방법에 대한 얘기다. 아래처럼 수동으로 작성하는게 아닌 code를 사용하는 방식이다.\n[1,1,2,3,5.....] 그런데, code를 사용해서 list data를 만들때, 가장 먼저 떠오르는 것은 for-loop으로 만들 것이다.\nresult = [] for i in range(10): result.append(i * 2) print(result) 그런데, for-loop으로 data를 만드는 방식 말고, 더 간단한 문법으로 만드는 방식을 제공한다. 그것을 comprehension이다. 위의 for-loop를 comprehension으로 표현하면 아래와 같다. for-loop와 달리, list안에다 직접 데이터를 쓴다는 느낌이다.\nresult = [i * 2 for i in range(10)] print(result) 그래서, 문법도 보면 [ ]가 나오고, 꺽쇠 안에 처음에 표현될 data의 형태가 나온다. 아래와 같은 방식이다.\n우리가 원하는 data가 어떤형태인가? list면 , dictionary면 { } 원소는 어떤 형태인가? 정수이고 짝수다. 2*i 형태 원소는 몇개인가? 10개, range를 사용하자. for i in range(10) 최종적으로 [ 2*i for i in range(10)] comprehension examples Comprehension example 1\n10개의 data를 갖는 dictionary를 만들고 싶다. 아래와 같은 형태로.\n{\u0026lsquo;0\u0026rsquo;: 0, \u0026lsquo;1\u0026rsquo;: 1, \u0026lsquo;2\u0026rsquo;: 2, \u0026lsquo;3\u0026rsquo;: 3, \u0026lsquo;4\u0026rsquo;: 4, \u0026lsquo;5\u0026rsquo;: 5, \u0026lsquo;6\u0026rsquo;: 6, \u0026lsquo;7\u0026rsquo;: 7, \u0026lsquo;8\u0026rsquo;: 8, \u0026lsquo;9\u0026rsquo;: 9}\n10개의 data가 필요하니까 range(10)을 사용하고, for in을 사용해서 index를 가져와서 dictionary에 하나씩 하나씩 쓴다.\n이런 dictionary를 하나하나 쓰긴 그렇다. 이 경우 dictionary comprehension을 사용한다.\nexample\nresult = {} for i in range(10): result[str(i)] = i print(result) dictionary에 이런 data를 만들기 위해서, dictionary comprehension을 사용하자.\nexample\nresult = {str(i):i for i in range(10)} 위에서 보다시피, dictionary에 들어갈 형태는 \u0026lsquo;index\u0026rsquo;:index 형태다. 즉 key:value의 형태다. dictionary안에서 str(i):i로 만들고, 루프-for i in range(10)를 사용하면 된다. Comprehension example 2\n이번에 만들 list는 10개의 data를 갖는데, 10이하의 정수가 random하게 배열된 list다.\n이런 걸 만들기 위해서, 어떻게 할 수 있을까? 아래에서는 set객체를 만들고, set객체에 add로 집어넣었다. 그런데 결과값은 random하다. 이건 좀 신기하다.\nexample\nresult = set() for i in range(10): result.add(str(i)) print(result) 이제 dictionary comprehension으로 이런 dictionary를 만들려고 한다. 어떻게 해야 할까?\nresult = {str(i) for i in range(10)} print(result) 여기서도 만들려고 하는 list item의 형태를 본다. string타입의 item이다. 그런데 {}이기 때문에 dictionary아니면 set이다. item이 key:value형태가 아니다. 따라서, 이것은 set이라는 것을 알수 있다. for i in range(10) 이렇게 하면 set comprehension이 만들어졌다. comprehension example 3\nexample1\ncomprehension의 구조를 보면, for문 다음에 if문이 나올 수 있다. for문 다음에 for문이 나올 수도 있다. 해석은 순차적이다. 아래를 보면, for에서 binding된 i를 if를 거쳐서 item으로 만든다. evens = [i for i in range(100) if i % 2 == 0] print(evens) [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98] 50개의 정수를 원소로 갖는 list다. 각각의 원소는 2의 배수 형태다. 어떻게 만들 것인가? range(n)에 대해서 정확히 알아야할 듯 하다. range는 개수를 입력으로 받는다. 시작은 0부터 한다. 아래와 같이 만들면 된다. 위에 처럼 복잡하게 만들 필요는 없는 듯 하다. 위에서 눈여겨 봐야 할 것은 for i in range(100) 다음의 if문이 나온다는 것이다. result = [ 2* i for i in range(50)] print(result) example2\n이것은 for문 다음에 for문이 나오는 형태다. 이중 for문으로 보면 된다. 3중 for문, 4중 for문도 만들 수가 있다. result = [(i,j) for i in range(5) for j in range(i)] print(result) 10개의 tuple을 원소를 갖는 list다. tuple의 첫번째 원소는 규칙을 가지고 있다. 반면에 두번째 원소는 규칙을 모르겠다. test result = [(i,j) for i in range(1) for j in range(i)] print(result) example3\n아래 구조는 다차원 배열을 만드는 것이라고 한다. 동작 원리를 보면, 가장 밖에 있는 for i in range(5)가 돌면서 내부의 list를 만들게 된다. 내부의 for-loop은 []가 없다면 내부 for-loop 다음에 옆에 for-loop이 실행 되었을것이다. 하지만 [ ]때문에 외부 for문에 따라 내부 for문이 도는 형태가 된 것이다. 결과적으로 정수 값을 갖는 2차원 table을 만든다. identity matrix를 만든다고 한다. eye = [[int(i ==j) for j in range(6)] for i in range(5)] print(eye) eye = [[int(i ==j)] for j in range(6) for i in range(5)] print(eye) Generator Generator의 개념 range가 가장 대표적인 예, range는 숫자를 생성하고, 요청이 있으면 숫자를 return하고 새로운 수를 만든다. list를 만들지 않는다. 따라서 메모리 효율적이다. function에 yield가 있다면, generator이다. generator를 이해하기 위해선, iterator와 for in loop의 동작 방식을 살펴볼 필요가 있다. for in loop와 iterator for in loop에 대해서 알 필요가 있다. for in loop를 알려면 iterator에 대한 이해가 필요하다. for in loop의 구조는 다음과 같다. for index in iterator iterator는 객체다. python의 모든것이 객체라서 iterator가 객체라고 말하는것은 좀 불 성실해 보인다. 좀 더 자세하게 말하자면 __iter__라는 dunder method와 __next__를 구현하고 있는 객체라고 말하는게 좀 더 정확할 것이다. list, tuple, dictionary, set과 같은 collection type의 class는 2개의 method가 구현되어 있다. 이 메소드가 어떤 역할을 하는지 살펴보자. for i in iterator라는 구문이 있다고 하자. python interpreter는 iterator의 _iter__라는 메소드를 호출해서 self객체를 얻는다. 그다음 self._next()를 통해서 iterator가 가진 원소를 꺼내온다. 그리고 i와 binding을 한다. loop를 돈 다음에, iterator의 __next__메소드를 호출해서 다음 원소의 값을 가져온다. 단지 __next__메소드를 호출한다고 다음값을 가져오는가? 그렇게 말하면 너무 무성의하다. iterator객체들은 내부적으로 cur이라는 변수를 유지하고 있다. 일종의 pointer인데, 현재 참조하는 data를 가리킨다. __next__를 호출할 때마다 다음 데이터를 return하는 구조다. stop이라는 마지막을 나타내는 pointer를 next가 가리키면 exception이 나고 for-loop은 끝나게 된다. Generator에 대한 생각. for in loop와 iterator에 대한 개념이 생겼으니, Generator에 대해서 알아보자. Generator는 yield가 있는 함수라고 한다. yield가 뭔지도 알아야 한다. 여튼\u0026hellip; iterator가 있어야 할 곳에 Generator가 있을 수 있다고 한다. Generator에는 iter,next같은 함수가 구현되어 있지 않다. iterator라고 부르는 객체들은 data를 가지고 있는 collection객체 였다면, Generator는 function객체다. Generator는 객체가 가진 data를 return하는게 아닌 말그대로 data를 만들어서 return한다. 그렇게 하기 위해선 명령어의 주소를 가지고 있고, 다음 명령어를 실행하는 방식이다. iterator와 비교하면, iterator는 cur이라는 pointer로 다음에 return할 data를 가리킨다면, Generator는 다음에 수행할 statement를 yield로 가리키고 있다고 보면 된다. for loop의 동작방식은 __iter__로 객체를 얻어와서 self.__next__를 호출한다. 이것이 generator에게 다르게 적용되진 않는다. 즉, __iter__를 호출하면 function객체가 return되고, __next__메소드가 호출되면, yield가 가진 다음 명령어부터 실행된다. 계속 수행되다가 yield를 만나면 어떤 data를 return할 것이다. 그러면 index와 binding해서 for-loop의 body를 수행한다. example def my_range2(): yield 1 yield 2 yield 3 for i in my_range2(): print(i) def my_range(stop): number = 0 while number \u0026lt; stop: yield number number += 1 for i in my_range(5): print(i) Generator는 lisp에서도 macro로 존재하는 기능이다. 동작과정을 살펴 보면, 제일 먼저, python interpreter는 my_range라는 function 객체를 만든다. for-in-loop에서 my_range라는 객체를 __iter__로 얻고, 5를 stack에 저장후, __next__를 실행시킨다. generator(function object)의 __next__는 수행할 명령어의 주소를 cur에 가지고 있는데, cur은 __init__을 가리키고 있다. 처음 호출이기 때문이다. __init__에선, function객체는 argument binding을 한다. stack에서 5라는 값을 my_range객체의 argument stop과 binding한다. stop은 일종의 멤버변수다.따라서 함수 호출 후 body를 수행할 때 stop이 binding된다. 쭈욱 body를 실행한다. while에 진입한 이후에 yield를 만난다. yield는 다음 명령어의 주소를 cur과 같은 변수에 저장한다. 다음 __next__호출시 cur에 저장된 명령어를 수행하기 때문이다. 그리고 yield는 값을 return한다. 주의해야 할것은 yield는 값을 return할 뿐이지, 함수의 종료를 뜻하지는 않는다. 만일 return문이 있다면, return문을 만나면 함수는 종료를 하게 된다. 특이한 generator even_generator = (i * 2 for i in range(10)) for i in even_generator: print(i) even_generator는 언뜻보기에 tuple comprehension처럼 보인다. tuple안에 comprehension이 들어가 있기 때문이다. 그러나 tuple comprehension은 존재하지 않는다. dictionary와 set, list는 comprehension이 있어도, tuple comprehension은 존재 하지 않는다. 저것은 comprehension을 generator로 만든것으로 보면 된다. Generator이기 때문에 for-loop으로 출력해보면 위와 같은 결과가 나온다. 근데, tuple comprehension, 즉 tuple형태로 된 generator에서 ()를 제거해도 문제가 없다고 한다. tuple은 ()가 생략 가능하기 때문이다. Built-in Functions sum([iterable]) iterable의 합을 구한다. generator도 iterator로 간주한다. example print(sum([1,2,3,4,5])) print(sum(i for i in range(1,101) if i%2 == 0)) any([iterable]), all([iterable]) any는 하나라도 참이면 참, all은 모두가 true여야 True다. example any_value = any([False,True,False]) all_value = all([False,True,False]) print(any_value,all_value) max([iterable], min([iterable]) max는 주어진 iterable에서 최대값을 return한다. min은 주어진 iterable에서 최소값을 return한다. iterable대신 generator도 쓸수 있는가? 유한 generator는 된다. 무한 generator는 가능한가? print(max([7,6,-2,5,8])) print(min([7,6,-2,5,8])) print(max((i *2 for i in range(10)))) zip([iterable],[iterable],\u0026hellip;) zip은 seq를 인자로 받아서 sequence를 column별로 묶는다고 보면된다.\nexample\nseq1 = [1,2,3,4] seq2 = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;] seq3 = [True,False,True] print(list(zip(seq1,seq2,seq3))) 각각의 sequence의 첫번째 원소를 묶어서 tuple을 만든다. 두번째 원소들을 모아서 두번째 요소를 만든다. 두번 째 요소도 tuple형태다. 3개씩 3개가 만들어진다. 그런데 seq1의 4는 짝이 없다. 이런 경우, 그냥 버린다. zip 사용법 예제\nexample\narray = [[1,2,3],[4,5,6],[7,8,9]] for row in array: print(row) for col in zip(*array): print(col) row와 col출력을 하는 예제다. row는 이해가 되지만, column이 이해가 안간다.\ncolumn을 나타내기 위해서 생각나는 방식은 아래와 같은 방식 일 것이다.\nfor col in zip(array[0],array[1],array[2]): print(col) 그런데 이것은 [[1,2,3],[4,5,6],[7,8,9]]라는 list를 unpacking해서 array[0],array[1],array[2]로 만든것과 같다. 이것을 다시 packing하면,*array로 나타낼 수 있다.\nzip함수의 흥미로운 부분이 있다.\nseq2 = zip(*seq1)이라고 하면, seq1 = zip(*seq2)와 같다. 근데 윗 부분은 좀더 예제라던가 동작방식을 살펴봐야 할 듯 하다.\nEnumerate iterable을 for문으로 돌릴때, index가 필요한 경우가 있을 수 있다. 어떤 list의 값과 index를 사용해야 한다면, 다음과 같이 코드를 짤 것이다.\nseq = [\u0026#34;this\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;sentence\u0026#34;] for i in range(len(seq)): print(i, seq[i]) enumerate를 이용한다면 더 간단하게 짤 수 있다.\nexample1\nseq = [\u0026#34;this\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;sentence\u0026#34;] for i, word in enumerate(seq): print(i, word) example2\nseq1 = [\u0026#34;this\u0026#34;, \u0026#34;sentence\u0026#34;] seq2 = [True, False] for i, (a,b) in enumerate(zip(seq1,seq2)): print(i, a,b) generator객체나 enumerate객체는 출력되지 않는다. 출력을 하기 위해선 list를 사용한다.\nprint(list(enumerate([\u0026#39;This\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;sentence\u0026#39;]))) lambda function lambda function은 이름이 없는 함수\nexample\ndef add(a,b): return a+b 이것을 lambda expression으로 바꾸면, add = lambda a,b: a+b lambda [param1],[param2]\u0026hellip;[expression]형태로 만든다.\nmap ([function],[iterable]) 각 요소에 function함수를 적용하여 반환 seq = [6,-2,8,4,-5] print(list(map(lambda x: x* 2, seq))) filter ([function], [iterable]) 각 요소에 predicate을 적용하여 참이 나오는것만 반환 seq = [6,-2,8,4,-5] print(list(filter(lambda x: x \u0026gt; 2, seq))) ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture6-pythonic-programming\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture7_object-oriented-programming\/": {
        "title": "lecture7_Object-Oriented-Programming",
        "tags": [],
        "content": "OOP programming class 기본 class 선언 예시 example\nclass Courier(object): # (object)는 생략가능 NATIONALITY = \u0026#39;KOR\u0026#39; # 클래스 속성 def __init__(self, name: str, address: str): # 생성자 self.name = name # attribute 초기화 self.address = address elf.parcels = [] def assign(self, parcel: str) -\u0026gt; None: self.parcels.append(parcel) def deliver(self) -\u0026gt; None: for parcel in self.parcels: print(parcel, \u0026#34;배달중\u0026#34;) class 특징들 class이름은 대문자. 상속은()를 사용한다. class attribute는 전역적으로 선언 class의 member attribtue는 init에서 self로 초기화. class 생성 example class Courier(object): # (object)는 생략가능 NATIONALITY = \u0026#39;KOR\u0026#39; # 클래스 속성 def __init__(self, name: str, address: str): # 생성자 self.name = name # attribute 초기화 self.address = address self.parcels = [] def assign(self, parcel: str) -\u0026gt; None: self.parcels.append(parcel) def deliver(self) -\u0026gt; None: for parcel in self.parcels: print(parcel, \u0026#34;배달중\u0026#34;) courier1 = Courier(\u0026#34;김기사\u0026#34;,\u0026#34;경기도 성남시 정자동\u0026#34;) print(courier1.name, \u0026#34;-\u0026#34;, courier1.address, \u0026#34;근무중\u0026#34;) courier1.assign(\u0026#34;편지\u0026#34;) courier1.deliver() class declaration class Courier(Object): class 이름은 CamelCase가 관습적으로 사용된다. 부모 class가 지정되지 않으면, object가 자동 상속된다. 그런데 object는 class가 아니라 객체라는것도 유의해야 한다. 모든 class는 object객체를 상속한다. Object class가 아니다. object객체에 있는 method를 built-in function이라고 부른다. class Attribute class Courier(Object): Nationality = \u0026#39;KOR\u0026#39; 속성은 2가지가 종류가 있다. class attribute와 member attribute. 둘다 객체가 갖는 속성이다. 하지만 여러 모로 다르다.\n우선 의미가 다르다. 붕어빵틀로 붕어빵을 찍어낼때, 붕어빵의 내용물은 붕어빵 객체마다 다를수 있다. 하지만, 붕어빵의 크기에 대한 속성은 모든 붕어빵 객체가 동일한 값을 갖는다. 생성하는 순서와 방식이 다르다. class를 python interpreter가 읽으면서 class객체를 만든다. 그때, class 객체의 attribute는 객체의 한 요소로 값이 만들어진다. 반면에 member attribute는 객체가 생성될때 init이라는 생성자에서 local하게 생성된다. python interpreter가 class로 쓰여진 부분을 읽어서 만들어지는 class객체에는 class변수에 해당하는 pointer와 function들에 대한 pointer들이 있을 뿐이다. python interpreter가 객체선언을 읽으면 그때 객체를 만들게 되는데, 그때는 init이라는 생성자를 호출 시켜서 member attribute를 생성하게 된다. 접근하는 방식이 다르다. class attribute는 class 자체 객체에 포함된 속성이라서 아래와 같이 사용한다. 반면에 member attribute는 객체를 만든 후에야 생성자에 의해 만들어진다. 그리고 그 이후에 객체.attribute로 사용될 수 있다. print Courier.Nationality class의 function들. class 내부에 있는 함수들이 있다. 이 함수들은 method라고 부른다. 이 method는 내부에 self라는 argument들을 가지고 있다. 이 self라는것은 객체를 의미한다. 예를들어서, python interpreter가 아래에서 보듯이 class Holy를 읽게 되면, Holy라는 이름의 class객체를 생성하고 method를 등록한다. Holy class 자체에서 method를 호출하려면, 첫번째 인자가 self라는 객체를 요구받는다. class자체객체를 전달할 순 없다. 즉 method를 사용하려면, 아래처럼 Holy class로부터 tempholy같은 객체를 만든다. 만들어진 객체에는 method들이 등록되어 있지는 않다. 객체에서 method를 호출하는것은 class객체에 등록된 method를 호출하는것이고, 그래서 첫번째 인자는 self로 되어 있는 것이다. self에는 tempholy가 인자로 들어가서 수행하는 것이다. tempholy객체에는 자신의 class에 대한 포인터가 등록되어 있기 때문에 class에 정의된 method들을 호출 할 수 있다. 다시 말하면, class는 class멤버변수와 method의 껍데기만 가진채로 생성이 되고, 객체가 만들어지면, 그 객체에는 class pointer가 있기 때문에, class의 class attribute와 method를 수행할 수 있는 것이다. class의 method를 수행하는 방식은 2가지가 있다. 하나는 class자체 객체에서 호출하는 것이다.\nclass Holy(object): class_var = \u0026#34;temp\u0026#34; def __init__(self, name: str): self.name = name print(\u0026#34;constructor\u0026#34;) def assign(self, newname:str) -\u0026gt; None: self.name = newname print(self.name,\u0026#34;assign method\u0026#34;) print(Holy.class_var) tempholy = Holy(\u0026#34;holy\u0026#34;) print(tempholy.assign(\u0026#34;park\u0026#34;)) print(Holy.assign(tempholy,\u0026#34;lee\u0026#34;)) 생성자(객체 속성) 객체를 생성할때 init()가 호출된다. init()는 class에 정의되어 있다. python에서 객체를 생성할 때는 무조건 =(asignment)를 사용한다. 이때 생성자의 모양에 따라 argument를 넣어 주어 생성한다.\ncourier1 = Courier(\u0026#34;김기사\u0026#34;, \u0026#34;경기도 성남시\u0026#34;) = 은 rvalue와 lvalue를 입력으로 받는다. rvalue의 type인 Courier가 courier1 객체에 들어가고, Courier의 method인 init()가 호출된다. 인자로는 \u0026ldquo;김기사\u0026rdquo;,\u0026ldquo;성남시\u0026quot;가 stack에 저장되고, Courier의 init()의 argument들은 function의 local변수이기 때문에 stack의 값으로 초기화된다. __init__함수에 보면, self는 courier1이 전달 되기 때문에, init()에 보면, self.name과 같은 식으로 객체를 만드는게 보인다. 이것은 courier1이라는 객체내에서 value값으로 만들어 지는 것이다. 따라서 courier1에서는 접근할수 있다. 그런데, 특이한게 있다. value는 생성자에 있는 member 변수가 아니다. java에서는 member변수가 아니라면, 객체에서 아래처럼 마음대로 member객체를 만들수가 없다. 그런데 python은 객체에서 member변수? member객체를 생성해서 사용할 수 있다.\ncourier1.value = 10 magic method: 생성자 initializer\ndunder method를 magic method라고 부르기도 한다. 즉 __로 시작하고 __로 끝나는 method를 뜻한다. init method도 dunder method다. 위에서도 이 init method에 대한 설명을 했는데, init method는 객체가 생성될때 호출된다. 예를 들면,\ncourier1 = Courier(\u0026#34;김기사\u0026#34;, \u0026#34;경기도 성남시\u0026#34;) 여기서 Courier class객체는 이미 만들어져 있다. class로 정의하면 생성이 되기 때문이다. 즉 이미 만들어진 type객체인 Courier의 init()를 호출하는 것으로 보면 된다. courier1은 인자로 전달되어 self로 assign되게 된다.\nmagic method: 소멸자\nclass Courier(object): def __del__(self): self.parcels.clear() 객체가 소멸할 때 호출된다고 한다. python에선 GC(Garbage Collection)을 가지고 있는데, 주기적으로 참조 되지 않는 객체를 삭제한다고 한다.\n객체지향의 3요소와 특성들 상속 inheritance class Courier(object): object는 부모 class, Courier는 자식 class가 된다.\n다형성 polymorphism 같은 이름의 method를 다르게 작성. 다중 상속이 가능하다고 한다. 그리고 super를 통해서 상위 class에 대한 접근이 가능하다. 이것이 polymorphism과 큰 관련이 있는지는 모르겠다. super를 사용하는 예제를 보여준다.\nclass Courier: def __init__(self, name:str): print(self) self.name = name print(\u0026#34;courier 생성자\u0026#34;) self.address = \u0026#34;부산\u0026#34; self.parcels = [] def assign(self, parcel: str) -\u0026gt; None: self.parcels.append(parcel) def deliver(self) -\u0026gt; None: for parcel in self.parcels: print(parcel, \u0026#34;super 배달중 -\u0026#34;, self.address) class JejuCourier(Courier): def __init__(self, name: str, ticket: int): print(\u0026#34;생성자juju\u0026#34;) # super().__init__(name) super(name) self.ticket = ticket def deliver(self) -\u0026gt; None: print(self.ticket, \u0026#34;티켓으로 제주도 이동\u0026#34;) super().deliver() # courier = JejuCourier(\u0026#34;김기사\u0026#34;, 15) JejuCourier(\u0026#34;김기사\u0026#34;, 15) # courier.assign(\u0026#34;편지\u0026#34;) # courier.deliver() # super(JejuCourier, courier).deliver() python은 모든 게 객체이기 때문에, class도 객체다. 그리고, class로부터 만들어지는 instance도 객체다. 각각의 객체엔 type(class)이란 항목이 있다. type(class)이란 항목엔 instance를 만든 class 객체를 가리키고 있다. 예를 들어서, A라는 class가 있고, a라는 instance가 있다면, A class도 객체가 있고, a도 객체 인 것이다. 객체인 A class와 a에는 객체이기 때문에 type(class)이란 항목이 존재한다. a객체의 type(class)에는 A class객체를 가리킨다. 그러면 A class객체의 type(class)이란 항목은 무엇을 가리키고 있을까? A class 그자체도 객체이기 때문에, class의 부모 class를 type(class)으로 가리키고 있을 것이다.\n위에서 type에 대해 설명한 것은 super()를 설명하기 위함이다. 우선 super는 내부적으로는 class로 정의되어 있다. init()만 가지고 있는 class다. super()는 type의 class의 init()를 호출하여 객체를 만든다. 소스를 보면서 설명해보자.\npython interpreter는 Courier, JejuCourier라는 class 정의를 보고, class 객체를 만든다. class 객체엔 name이란 항목, type이란 항목, value라는 항목이 설정된다. name에는 class의 이름이 들어가고, type에는 Courier의 경우는 object, JejuCourier에는 Courier가 들어간다. value에는 body부분이 들어가게 된다. class객체를 만들때, body부분은 실행하지 않는다. 즉 body에선 수많은 객체 생성을 할텐데, class객체는 body 전체만 가리키는 포인터만 가질뿐이다. class객체로 부터 instance객체를 만들고 instance 객체에서 body부분을 실행할 때 처리되는 것이다.\npython interpreter는 아래를 읽고 실행한다.\ncourier = JejuCourier(\u0026#34;김기사\u0026#34;, 15) = 은 객체를 만드는 명령어다. 객체를 만들고, name은 courier로 지정하고. type은 JejuCourier로 한느 객체를 만든다. 그리고 JejuCourier라는 class객체의 __init__함수를 호출한다. 인자는 지금 만든 courier객체, \u0026ldquo;김기사\u0026rdquo;, 15값을 stack 넣어 전달한다. courier라는 객체는 단순하다. 왜냐면, courier객체는 JejuCourier를 type으로 갖기 때문에 JejuCourier의 method를 그대로 상속해서 사용한다. type이라는 것은 부모 class로 보면 되기 때문이다.\n[JejuCourier의 __init__함수]\ndef __init__(self, name: str, ticket: int): print(\u0026#34;생성자juju\u0026#34;) super() super().__init__(name) self.ticket = ticket print문을 출력하고, super()라는 부분이 나온다. self는 courier라는 객체를 나타낸다면, super()는 현재 수행되는 class객체인 JejuCourier객체의 type, 즉 부모 class를 생성하는 것이다. 부모 class의 __init__을 호출해서 부모의 class의 instance객체를 만든다. 물론 그전에 부모 class객체는 만들어져 있는 상황이다. 예를 들어, JejuCourier()를 호출한다면, JejuCourier class객체는 이미 만들어져 있고, JejuCourier class객체의 init()를 호출해서 instance객체를 name없이 만드는것과 같다. 즉 저기서 super()는 부모인 Courier의 _init__메소드를 호출해서 instance객체를 만드는 것이다. 그런데 super()를 실행하면, Courier의 init()이 일치하는게 없다. Courier의 init(self, name:str)의 형태이기 때문에, 부모인 object의 init()가 호출될 것이다. Courier의 init(self, name :str)을 호출하기 위해서는 명시적으로 호출해야 한다. 즉, super()._init(name)으로 호출해야 한다. 그런데 여기서 질문, Courier의 init메소드의 인자 self는 무엇으로 초기화 되는가? 그리고 만일 super(name)으로 Courier의 _init__을 호출 할 수 있는가? 어떻게 self가 초기화 되는가? 자식객체가 type의 method를 호출할때는 자기자신이 인자로 전달된다. 그러면 super(name)도, super()._init(name)이 수행되듯이 수행되어야 할 것이다. 그런데 수행되지 않는다. 이것은 정말 이상한데, super라는게 부모 class를 가리키고, super()를 하면 instance를 만들고 인자 없는 init()을 호출하는 과정이다. super(name)하면, 부모 class에대한 instance를 만들고, init(self, name:str)을 호출해야 맞는데 호출 되지 않는다. super()는 Courier()를 실행하고, 그다음 init()를 호출하는건, JejuCourier()를 실행했을 때, JejuCourier instance를 만든후 __init__메소드를 수행하는것과 동일한데, 이상하게 안된다.\n그리고, 맨 마지막의 실행문을 보자.\nsuper(JejuCourier, courier).deliver() 이것은 어떻게 해석 할 것인가? 이전의 super()는 특정 객체의 method에 있었다. 즉 특정 객체의 method가 호출되어 실행되기 때문에 그 context에서는 super가 가르키는게 특정 class객체임을 알 수 있었다. 하지만, 여기서 super는 어떤 class객체를 가리키는가? 이게 module하고 관련있는것 같다. 즉 class내가 아닌 밖에서 사용되는 function도 module하고 어떤 관계가 있어 보인다.여기서는 별 다른 설명이 없다.\noverloading과 overriding overloading과 overriding은 모두 부모와 같은 이름의 함수를 뜻한다. overloading은 argument가 다른 함수다. 즉 다른 함수라고 봐도 된다. 하지만, overriding은 동일한 함수를 재정의 하는것이다. 단어만 보면 overwrite하고 비슷하다. 위 코드에서 보면, deliver는 overriding한것이고 __init__은 overloading한 함수다.\nstatic \u0026amp; class method 우선 예제를 보자.\nclass Number: Constant = 10 @staticmethod def static_factory(): obj = Number() obj.value = Number.Constant return obj @classmethod def class_factory(cls): obj = cls() obj.value = cls.Constant return obj number_static = Number.static_factory() number_class = Number.class_factory() print(number_static.value, number_class.value) staticmethod와 classmethod는 이름만 봐선, 우선 class method는 class객체에 포함되는 method고, static method는 일종의 전역함수로 봐도 되지 않을까? 일반 method는 self라는 argument가 있었다. 하지만, class method와 static method에는 self가 있을 필요가 없다.\n사용방법을 보면, 둘다 다음과 같이 호출한다.\nnumber_static = Number.static_factory() number_class = Number.class_factory() static method는 선언만 class안에 선언되었을 뿐이지, 밖에 선언되어도 상관없을 method다. 하지만, python에선 모든것은 객체고 method이기 때문에 안에서 선언되고 접근만 가능할 뿐이여서 class에 포함된 method라고 보기 힘들다. 여튼 코드 해석을 해보자.\npython interpreter는 Number라는 class를 읽고 Number class객체를 만든다. 그리고 다음 code를 실행한다.\nnumber_static = Number.static_factory() = 은 객체를 만든다. number_static이란 name을 갖고, Number.static_factory()함수를 호출 결과의 type과 value를 가질 것이다. static_factory()는 외부 함수로 봐도 된다. 여튼 여기서는 Number의 instance를 만들어서, return한다. 따라서 Number라는 type이 지정되는 객체가 만들어진다.\n두번 째로, 다음 코드를 보자.\nnumber_class = Number.class_factory() 여기서는 Number의 instance를 만들지는 않는다. 제일 처음에 python interpreter가 Number라는 class객체를 만들었기 때문에, Number class객체의 class method인 class_factory()를 접근한다.\n@classmethod def class_factory(cls): obj = cls() obj.value = cls.Constant return obj 여기서 눈여겨 봐야 할것은 cls이다. 우리가 객체를 생성해서 객체에서 method를 호출할 때는 객체.method() 형태로 method를 호출한다. 이 때, method는 class객체에 있기 때문에, 객체가 인자로 넘어가서 실행된다. 근데 여기서는 class method는 class에 정의되어 있다. 그리고 class객체 자기자신이 인자로 넘어간다는게 좀 다르다. cls는 Number class객체의 이름이 넘어간다. 그리고 그 이름으로 Number instance를 만들어서 return하는 구조다.\n위의 두 함수 모두, class의 instance를 만들고, instance의 method를 호출하는 방식과는 다르다. instance는 내부적으로 만들어져 return 하는 형태다. factory design pattern을 사용하기 때문이다.\n또 한가지 static method와 class method 모두 decoration을 사용하고 class객체에서 호출 가능하다는 공통점이 있지만, 둘 사이의 커다란 차이점은, class method는 상속이 되지만, static method는 상속이 되지 않는다는 것이다.\nAbstraction (visiblity) Abstraction으로 알고 있던 용어를 여기서는 visiblity라고 부른다. 다른 class에서 객체 내부 요소를 감추는 캡슐화 작업이라고 한다. java에서 private이나 protected로 설정했던거라고 보면 된다. 즉 내가 김기사라는 instance를 만들었을때, instance라고 해서 자신의 member attribute를 다 접근할 수 없게 만들었다. class에서 정의된 방식으로만 접근할 수 있게 할 수 있는데, 예를들면, set과 get이라는 method에서만 직접적 처리가 가능하게 했다. instance는 이 method를 호출해서 해당 변수에 접근이 가능하다. 이것을 capsule화라고 한다. java에서는 private과 protected라는 keyword로 제공했지만, python에서는 private이나 protected라는 keyword는 없다고 한다. 다만, __로 시작하면 private이라고 하고, _라고 하면 protected라고 일종의 규약처럼 사용되는데, 문법적 요소는 없다고 한다.\n예를 들어 보자.\nclass TestClass(object): def __init__(self): self.attr = 1 self._attr = 2 self.__attr =3 instance = TestClass() print(dir(instance)) print(instance.attr) print(instance._attr) # print(instance.__attr) dir은 instance가 가진 모든 attribute를 보여준다고 한다. 여기보면, _attr과 attr은 보이지만, __attr은 보이지 않는다. 강사는 mangling이 적용되었다고 말한다. mangling은 __가 앞에 붙어 있으면 이름이 _TestClass__attr로 변경된다. mangling이 되면, 객체에서 직접적으로 접근할 수 없게 된다. 즉, private한 효과가 있다. 위에서 직접 접근을 시도했지만, 에러가 발생되는 것을 볼 수 있다. 굳이 접근할려고 하면, instance._TestClass__attr로 접근할 수 있다. mangling된 이름으로 접근하면 된다. protected는 별다른 처리를 하진 않는다. 여기서 __로 시작하는것을 dunder method나 magic method로 보면 안된다. dunder method는 __로 시작하고 __로 끝날때만을 의미한다. __는 attribute와 function에 적용되고 mangling하는 특징을 갖는다.\nabstraction (visibility2) java같은 oop언어에서는 private을 사용하고, setter, getter 메소드를 정의해서 사용하는 경우가 많다. python에서는 명시적인 private과 protected keyword를 제공하지 않는다고 했다. 어떻게 보면, python에서는 기존의 oop언어가 member variable을 private으로 감추고, setter와 getter를 사용하는것이 쓸모 없다고 생각했을 수도 있다. 그래서 그냥 member variable에 값을 넣고 꺼내면 되지 않냐? 이런식의 주장을 하는 것 같기도 한다. 그렇지만, 직접적으로 그렇게 사용하진 않는다. python도 java처럼 setter와 getter를 사용한다. 하지만, 마치 직접 변수를 접근하는 것처럼 눈속임을 한다. 이때 사용되는게 @property와 @name.setter를 사용한다. 이것을 사용하면, python이 원래 의도했던, 마치 instance에서 setter getter라는 method도움없이 직접 입력하는 것과 같은 착시효과를 준다.\n예를 들어보자.\nclass Circle(object): PI = 3.141592 def __init__(self, radius=3.): self.radius = radius def get_area(self): return Circle.PI * self.radius ** 2 def set_area(self, value): self.radius = (value / Circle.PI) ** .5 circle = Circle(5.) print(circle.get_area()) circle.set_area(10) print(circle.radius) 위에는 일반적으로 coding할 때의 예다. radius라는 attribute가 있고, get_area, set_area함수에서 해당 radius에 접근해서 area계산값을 return한다. 그리고 instance에서 radius값을 직접 출력해 보기도 한다. 만일 radius가 private하다면, 아래의\nprint(circle.radius) 는 수행 될 수 없다. get함수를 써야, OOP의 개념을 살린 coding이라고 말할 수 있을것이다. 그런데 python에는 애초부터 private한 keyword가 없기 때문에 굳이 get함수를 사용할 필요는 없다. 다만 oop형태로 set과 get method를 만들지만, 직접 사용하는 것처럼 만들 수 있다. 아래의 예를 보자.\nclass Circle(object): PI = 3.141592 def __init__(self, radius = 3.): self.radius = radius @property def area(self): return Circle.PI * self.radius **2 @area.setter def area(self,value): self.radius = (value /Circle.PI) ** .5 circle = Circle(5.) print(circle.area) circle.area = 10. print(circle.radius) 여기에서 보면, @property와 @name.setter라는 decorator가 추가되었다. 이것은 setter, getter method를 마치 변수처럼 만들어준다. @property를 해주면, method가 변수처럼 되어 버린다. 위의 예에서는 마치 getter럼 정의된 area란 method에 @property가 있다. 따라서 아래와 같이 출력이 가능하다.\nprint(circle.area) area가 변수처럼 보이지만, area는 함수다. @property처럼 보여라하는 decorator가 붙어서 property처럼 처리한다.\n다음은 setter method처럼 정의된 함수에 decorator를 붙였다.\n@area.setter def area(self,value): self.radius = (value /Circle.PI) ** .5 그리고 다음과 같이 사용한다.\ncircle.area = 10. 보기에는 area변수에 10.0을 assign한것 처럼 보이지만, 실은 area라는 함수다.\nmagic method (dunder method) 파이썬에는 magic method를 많이 제공한다. 위에서 봤듯이 magic method는 __를 prefix와 postfix에 사용한다. 그리고 대부분이 object 객체에 있는 함수들이다. 이것은 built-in function들로 불린다.\nindexing method\nclass DoubleMapper: def __init__(self): self.mapping = {} def __getitem__(self, index): return self.mapping.get(index, index * 2) def __setitem__(self, index, item): self.mapping[index] = item mapper = DoubleMapper() print(mapper[10], mapper[1,2]) mapper[10] = 15 print(mapper[10], mapper[1,2]) [ ] 를 재정의 한 코드라고 강사는 말한다. __getitem__과 __setitem__을 class에 정의하게 된다면,\nmapper[10] = 5 이런 statement의 경우 __setitem__이 호출되고,\na = mapper[20] 이런 statement의 경우 __getitem__이 호출 된다고 한다. 이제 코드를 분석해 보자.\nprint(mapper[10], mapper[1,2]) 여기서, mapper[10]과 mapper[1,2]는 __getitem__을 호출한다. 처음은 10이라는 값을 넘기고, 두번째는 (1,2)라는 tuple값을 넘기는 것이다. 두 번째의 경우가 좀 이해하기 힘들긴 하다. 여튼 저런 값은 tuple값으로 생각하면 된다.\ndef __getitem__(self, index): return self.mapping.get(index, index * 2) 첫번째는 10이란 index를 __getitem__에 넘겼다. 여기서 get이란 함수가 좀 특이한데, 만일 index값이 없다면, 2를 곱해서 return한다는 뜻이다. 10이란 index에 값이 없기때문에, 20일 return된다. 마찬가지로 (1,2)라는 index가 존재하지 않기 때문에 2를 곱해서 (1,2,1,2)를 return한다고 한다. 즉 이제는 index가 10이거나 (1,2)에 대해선 값이 존재한다.\n이제 __setitem__을 수행하는 코드를 보자.\nmapper[10] = 15 이 코드는 class의 __setitem__을 호출한다.\ndef __setitem__(self, index, item): self.mapping[index] = item mapper객체의 index가 10인 값은 15로 저장되게 된다. 이렇게 해서 mapper객체의 값들은 {10:15, (1,2):(1,2,1,2)} 이렇게 유지된다.\n이렇게 setitem__과 __getitem__을 사용한다면, index관련한 처리를 재정의가 가능하다. dictionary와 tuple array, list같은 index를 사용한 연산에서 index의 기능을 재정의하는게 가능하다. 위에서도 index를 사용해서 값을 return받거나, index에 값을 삽입하는 것을 __getitem, __setitem__을 재정의하면 해당 method가 호출되는 것을 볼 수 있다.\n이런 형태가 pandas나 tensorflow에서 많이 보이는데, 안에 구조를 보면 setitem과 getitem을 재정의해서 사용하는 경우가 많다고 한다. tensor class가 이런 형태라고 한다.\nlength method\n예제를 먼저 보자.\nclass Dataset: def __init__(self, data, times =3): self.data = data self.times = times def __len__(self): return len(self.data) * self.times def __getitem__(self, index): if index \u0026gt; len(self): raise IndexError() return self.data[index % len(self.data)] dataset = Dataset([10,2,5,2], times=5) print(len(dataset)) 코드를 분석하자.\ndataset = Dataset([10,2,5,2], times=5) 이 부분은 dataset이라는 객체를 만든 것이다.\nprint(len(dataset)) 여기서, len(dataset) 이 부분이 해석하기가 좀 어려운데, dataset._len_()이 아니라 len(dataset)의 형태이기 때문이다. 두개가 형태만 다를뿐 동일한 것같다. 여튼, dunder method의 경우, len(dataset)형태로 많이 사용되어진다는 게 특이하다. 그리고 len(dataset)은 Dataset class의 len()를 호출한다고 보면 된다. 그리고 object 객체에 미리 정의되어 있다.\ngetitem()는 dataset[2], dataset[10] 처럼 index를 사용해서 값을 가져오는 명령에서는 __getitem__이 정의되어 있다면 호출된다. 연산자 재정의와 유사하다고 했다. code를 보면 다음과 같이 되어 있다.\ndef __getitem__(self, index): if index \u0026gt; len(self): raise IndexError() return self.data[index % len(self.data)] pass받은 index값이 원래 dataset이 가진 객체의 len()보다 작다면 에러가 나는데, len()는 객체가 가진 data의 길이다. 즉 index가 가진 data보다 큰 값으로 접근하면 에러가 발생된다는 얘기다.\ntyping magic method\nclass Courier: def __init__(self, name: str, address: str): self.name = name self.address = address def __str__(self): return self.address + \u0026#39;담당\u0026#39; + self.name courier = Courier(\u0026#34;김기사\u0026#34;, \u0026#34;경기도 성남\u0026#34;) text = str(courier) print(courier) 여기서도, str(courier)과 같은 형태가 나온다. courier.str()의 형태가 아니다. 이것은 object에 정의된 dunder method라고 바로 추측한다. 물론 위에선 재정의한 것이다. object에서 dunder method로 정의하는덴 그만한 이유가 있다. str이다. str은 int float와 같은 type이다. str(courier)라는 형태는 좀 이상해 보이지 않는가? 보통은 형변환시 사용되는 방법이다. str클래스가 있고, 생성자에 객체를 전달해서 str객체로 형변환한다고 생각한다. 또다른 예로, int객체 3이 str생성자에 전달되어 str(3)은 str 객체로 변환된다고 생각한다. 하지만, 이것은 int 클래스에 정의된 str dunder method의 호출이다. python에선 그렇다. int라는 class에 str__메소드가 정의되어 있는것이다. 우리가 형변환이라고 부르는 int(courier)이나, float(courier), bool(courier) 모두 class의 dunder method로 정의되어 있다는 것이다. __str dunder method를 정의해서 편리하게 쓰는 경우는 객체를 print할 때다. __str__메소드가 리턴하는 값이 출력된다.\ncomparison operator magic method\nclass Courier: def __init__(self, name: str, cid: int): self.name = name self.cid = cid def __lt__(self, other): return self.cid \u0026lt; other.cid couriers = [ Courier(\u0026#34;김기사\u0026#34;, 56), Courier(\u0026#34;박기사\u0026#34;, 72), Courier(\u0026#34;정기사\u0026#34;, 62) ] print(dir(Courier)) print(*[courier.name for courier in sorted(couriers)]) 여기서 눈여겨 볼 것은 list comprehension에서 sorted(couriers) 문장이다.\nprint(*[courier.name for courier in sorted(couriers)]) 이전에도 보았듯이 couriers.sorted()의 객체 method가 아닌, sorted(couriers)형태가 나온다. 이것은 sorted가 dunder method임을 말하고, class에 정의되어 있다. couriers객체의 type은 list이다. 즉 list에 sorted__()가 정의 되어 있을 것이다. sorted()의 내부 동작은 정확히 모르지만, 객체들의 lt()를 사용해서 크기 비교를 하는것 같다. 예를 들면, a \u0026lt; b, a\u0026gt; c, 혹은 if a == b 와 같이 많은 비교를 할 것이다. sorted가 아니더라도, 객체를 비교하는 연산을 사용하는 경우는 많다. 이때, class에서 lt()를 정의하고 있다면, a \u0026lt; b라는 일견 평범한 연산은, a._lt_(b)로 해석될 수 있는 것이다. 즉 python에서는 모든 것은 객체고, 모든 operator는 method이기 때문이다. 마찬가지로 __le, gq, ge, __ne__등 많은 것이 존재한다.\n연산자 재정의에 대해서.\n1\u0026gt;2, 1\u0026lt;3, 1 ==3 같은 logic operator ||, \u0026amp;\u0026amp;, ! 같은 관계연산자. +, , / ,*, % 같은 arithematic operator = assign operator len함수 같은것들. 이런 연산자들은 3\u0026gt;4, 1+4, a ** b 이런식으로 사용하는게 너무나 자연스럽게 생각하지만, 객체지향 언어에선 당연하다거나 자연스럽다고 생각하면 안된다. 왜냐하면, 객체 지향언어에서는 객체.method의 형태로 함수나 operator를 사용하지, 수학이나 c언어에서 사용하듯이 사용하는 저 방식은 매우 낯선것이기 때문이다. python에선 모든것은 객체고 모든 function은 method이다. 따라서 저 operators들은 class에 정의된 method이다. 우리가 class를 만들때마다 저런 operator를 모두 method로 만들어줘야 한다. 근데, Object에 이미 만들어져 있기 때문에, 자동으로 상속된다. 우리가 만든 dunder method는 모두 재정의한 것이다. overloading을 했던가 혹은 overriding을 한것이다.\n근데 한가지 궁금한 게 생겼다. 위에서 설명한 dunder method들, len, comparison 연산자들은 모두 객체에서 정의된 그대로 호출 할수 있었다.\na.__len__() 그런데 실제 사용할 때는\nlen(a) 와 같이 사용한다. 어떻게 해서 이렇게 사용할 수 있는것인가? 그리고, 위의 경우는 이름이 비슷하기라도 하다. 전혀 다른것들이 있다. 아래를 보면 \u0026lt; 심볼은 실제 lt()를 호출 한다. 이것은 어떻게 가능한 것인가? 여기에도 mangling이 되는 것인가? 그렇지는 않다. 왜냐면 dunder method는 직접 호출이 가능하기 때문이다.\na \u0026lt; b def __lt__(self,...): self.a \u0026lt; other.a 또 재밌는건, lt() method로 선언한 내부에는 \u0026lt;,\u0026gt;와같은 기호를 그대로 쓴다는 것이다. 그럴바에는 lt()를 만들 필요가 있었는지 모르겠다. 사용할때도 \u0026lt;,\u0026gt;같은 기호를 쓰고, 내부적으로도 사용한다면, 굳이 __lt__라는 이름뿐인 함수를 왜 정의하는지 모르겠다.\narithmetic operator : magic method\nclass MyComplex: def __init__(self, real, imaginary): self.real = real self.imaginary = imaginary def __str__(self): return str(self.real) + \u0026#39;+\u0026#39; + str(self.imaginary) + \u0026#39;j\u0026#39; def __add__(self, other): return MyComplex( self.real + other.real, self.imaginary + other.imaginary ) a = MyComplex(3, -5) b = MyComplex(-6,7) print(a + b) 어떤 class를 만들었을때, class로 만든 instance가 + 연산을 할 수 있게 하려면, class에 add()가 있어야 한다. 물론 object에도 정의되어 있다. overloading이나 overriding으로 재정의할려면 위와같이 add()를 재정의한다. str()도 재정의해서 print문에 사용할 수 있다. sub(), mul()도 존재한다.\niadd()도 존재한다. 이것은 = 을 사용해서 객체를 만드는 대신 +=을 사용해서 객체를 새롭게 생성하지 않는다고 한다. 왜냐면, +=는 연산자이기 때문이다.\nCallable : magic method\nclass AdditionNumber(object): def __init__(self, number: int): self.number = number def __call__(self, number: int): return number + self.number addition_5 = AdditionNumber(5) print(addition_5(10)) 이건 또 뭐야? 할정도로 이상한 모양이다.\nprint(addition_5(10)) addtion_5는 instance다. AdditionNumber(5)로 부터 만들어진 instance다. 그런데 instance에 (10)을 붙였다. 이것은 syntax error가 날 만도 하다. 근데 정상 동작이 된다. 어떤 이유에서일까? addition5자체는 instance객체의 이름이다. ()는 call method를 의미한다고 한다. object객체에 정의된 built-in function이기도 하다. 따라서, addition5._call_(10)을 addition5(10)으로 사용한다는 건데 그러면, ()와 __call__간의 mapping은 어디에 정의 되어 있는가?\nfor : magic method iterable\nseq = [1,2,3,4,5] for elem in seq: print(elem) 위와 같은 for문은 다음과 같은 형태라고 한다.\nseq = list([1,2,3,4,5]) iterable = iter(seq) while True: try: elem = next(iterable) except StopIteration: break print(elem) python에서 for문은 다른언어와 다르게 iterable객체에서 값을 가져와서 처리하게 되어있다. 즉 유한한 값을 반복한다. 그래서 구조도 좀 다르다. for in이 같이 쓰인다. in 다음에는 collection이 들어가는데, 이 collection은 iter()를 사용해서 iterable객체가 된다. iterable객체에는 start,end, cur이라는 내부변수가 있다. next()가 있어서 cur이 가리키는 값을 return한다. return한 값은 변수와 binding되고, 다음 명령어가 수행된다.\ncontext manager: magic method\nclass Courier: def __init__(self,name: str): self.name = name def __enter__(self): self.parcels = [] return self def __exit__(self,exec_type,exec_value, trace): for parcel in self.parcels: print(parcel, \u0026#34;배달 실패\u0026#34;) # parcel.clear() courier = Courier(\u0026#34;김기사\u0026#34;) with courier: courier.parcels.append(\u0026#34;소포\u0026#34;) with courier as c: c.parcels.append(\u0026#34;소포\u0026#34;) with로 시작되는 구문이 있다. 생소하다. as도 생소하다. 우선 with 다음에는 객체가 온다. 그리고 block이 정해진다. 해당 객체가 block에서 사용될때, class의 enter()가 실행되고, block을 빠져나올때, exit가 수행된다. as는 객체의 이름을 block에서 c라고 사용하겠다는 뜻이다. exit는 error나 exception이 발생되도 실행이 되게 되어 있다. 그래서 error의 정보를 나타내기 위해서 exec_type, exc_value같은 인수를 제공한다.\nwith as가 가장 많이 사용되는 경우는,\nwith fopen(\u0026#34;test.txt\u0026#34;) as fd 과 같이 file을 열때, context를 유지해야할 때 많이 사용한다고 한다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture7_object-oriented-programming\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture8-module-and-package\/": {
        "title": "lecture8-module-and-package",
        "tags": [],
        "content": "module import 사용법 module은 .py로 끝나는 파일 한개를 의미한다. python으로 작성된 모든 file들은 python module이라고 부를 수 있다. import구문으로 module을 불러올 수 있다. 예를 들어보자. 내가 작업하고 있는 file에서 functions.py라는 파일에 있는 qr()를 사용하고 싶다면, 우선 import로 가져와야 한다. 가져온다기 보단, 실행한다고 말을 해도 된다. 오히려 그게 직관적이다. 여튼 가져오던 실행하던 문맥에 맞게 이해하면 된다.\nimport functions print(functions.qr()) import로 가져온 file의 함수를 사용하기 위해선, 모듈명.함수명()으로 사용한다. import로 가져온 함수다라는 꼬리표를 달아두는 것이다. import뒤에는 module이 올수도 함수나 변수가 올 수도 있다. import뒤에 모듈이 올 경우에는 모듈 이름으로 class를 만들고 module이 담고 있는 내용이 복사가 된다고 생각하면 된다.\nimport 사용시 주의점 내가 작업하는 파일에서 import로 모듈을 가져올 때, 가져올 파일은 내가 지금 작업하는 파일과 같은 폴더이거나 하위폴더에 있어야 한다. 그래야 가져올 수 있다. 상위폴더는 안된다.python interpreter는 import로 모듈을 가져오면서 처음부터 끝까지 읽고 객체들을 만든다. 만일 모듈에 print문이 있다면, 그냥 출력시킨다.\nmodule의 이름 이전에 말했듯이 .py로 끝나는 파일을 module이라고 했고, 파일의 이름이 module의 이름이다. 그런데, 특이한게 있다. main이라는 module 이름이다. 이것은 python에 의해서 정해진 이름이다. 다음을 보자. 나는 test.py라는 파일을 만들고, 모듈이름을 출력하는 코드를 만들었다.\nprint(__name__) python test.py 이렇게 실행하면, test라는 이름이 출력되야 한다. 우리는 test module을 실행시켰기 때문에 test가 출력되야 하는데, main이라는 이름이 출력된다. python에 의해 실행되는 file의 모듈이름은 main인 것이다. 모듈이 실행되는 경우는 2가지다. python interpreter에 의해서 직접적으로 실행되거나, import문에 의해서 실행될 수 있다. 직접 실행되는 module의 이름은 main이 되고, 나머지는 파일이름을 module이름으로 갖는다.\nmain이란 module이름을 가장 많이 사용하는 예에는 다음과 같은 경우가 있다.\nif __name__ == \u0026#39;__main__\u0026#39;: 즉, python에 의해서 실행된 파일인 경우, 파일이름과 상관없이 수행하게 된다는 뜻이다. python으로 직접 실행하면, main이라는 이름을 갖기 때문이다.\nimport하는 예시들. 우선 가정을 하자.\nFigure 1: 구조.\n위와 같이 functions.py라는 파일이 directory라는 폴더 아래에 있다고 하자. main.py에는 아래와 같이 import할 수 있다.\nimport directory.functions print(directory.functions.add(1,2)) import뒤에는 module이 올수도 있고 함수나 변수가 올수도 있다. import뒤에 module이 오는 경우, class를 만든 후 붙여 넣기한다. import할 module이 같은 폴더내에 없다면, 경로를 위와같이 명시해야 한다. 그래야 정확하게 현재 파일의 윗 부분에 붙여 넣는다. 붙여 넣을때, directory라는 class가 만들어지고, 그 안에 functions라는 class가 만들어진다고 보면 된다. 따라서 그 안의 add라는 함수를 사용할 때는 위와 같이 꼬리표를 달아야 한다.\nimport directory.functions as func print(func.add(1,2)) as는 alias의 준말이라고 한다. 2개의 class를 만들어서 import하는게 아니라, as를 사용해서 func라는 class를 만들고, 그 안에 붙여 넣는다.\nfrom directory import functions print(functions.add(1,2)) from이라는게 나왔다. from은 경로만 얘기한다. functions를 import하겠다. functions의 위치는 directory아래에 있다. functions은 module이다. 따라서 functions라는 class를 만들고, functions의 내용을 다 붙여 넣기 한다. functions class의 내용을 사용할때는 class의 함수를 사용하기 때문에 class이름을 사용하여 접근한다.\nfrom directory.functions import add print(add(1,2)) 위에 표기법과 비슷하다고 생각할 수 있다. 근데 import뒤에 있는건 module이 아니라 function이다. module이 아니기 때문에 class를 만들고 copy \u0026amp; paste를 하지 않고, 바로 copy \u0026amp; paste할 것이다. 하지만, 여기서 알아야 하는건 import뒤에 module이 아닌 function이라는게 올 때는 조건이 필요하다는 것이다. from으로 module을 지정해야 한다. 그렇지 않고, import로 직접 function이나 variable을 가져오면 에러가 난다. 예를 들면 다음과 같은 경우가 있다.\nimport directory.functions.add import만 쓰이는 경우는 module을 써야 하는데, add는 function이라서 에러가 난다.\nimport add from directory.functions import * print(add(1,2)) 이것도 import하는게 module이 아니다. 그래서 그대로 functions module의 모든 내용을 copy \u0026amp; paste한다. 이것은 문제가 될 수 있다. 내가 작성한 함수와 import로 가져온 함수가 동일할 때, overwrite가 된다.\n주의 해야할게 있는데, import는 module,변수,함수만 할 수 있다. 경로라고 생각하면 안된다.\nFigure 2: example\n예를 들어 위에서 directory를 import하고, 하위 모든것이 import된다고 생각해선 안되는 것이다.\nimport 예시2 import할 때, 파일의 경로문제가 있다. main module과 import하는 module의 경로에 따라서 다음과 같은 에러가 발생할 수 있다.\nImportError: attempted relative import with no known parent package ValueError: attempted relative import beyond top-level package 경로에 따른 import문제가 발생하는 이유는, 경로는 main모듈 기준으로 상위폴더에 접근이 되지 않는다. 또한 하위폴더들은 절대경로로 주어지며, package를 사용했을 때만이 상대경로를 사용하여 상위폴더나 하위폴더에 접근할 수 있기 때문이다.\nimport의 경로(상위폴더와 경로의 기준) Figure 3: import example2\n경로의 개념이 os기준도 아니고, python interpreter기준도 아니고, main모듈 기준이라고 했다. function2 module을 import해서 경로가 어떤 것을 의미하는지 확인해 보자.\nfunction2에 대한 경로 import\nimport Users.holy.temp.pythontest.test_nlp.parent_dir.mydir.child_dir1.functions2 Users.holy.temp.pythontest.test_nlp.parent_dir.mydir.child_dir1.functions2.sub(3,2) python main.py import의 경로는 os의 root를 기준으로 설정했다. 에러가 나지 않는다면 import의 경로는 os기준이다.라고 말할 수 있을 것이다.\nFigure 4: import error\n경로라는게 os입장에서의 절대경로가 아닌것을 알 수 있다. 그렇다면 혹시 python의 실행위치가 경로의 기준인 top-level directory일까?\nimport parent_dir.mydir.child_dir.functions2 parent_dir.mydir.child_dir.functions2.sub(3,2) python parent_dir/mydir/main.py python의 실행위치는 project의 최상단에서 시작한다. python 실행위치 기준에서는 parent_dir이 하위디렉토리이기 때문에, 위와 같이 import하면 경로를 인식할 수 있을것이다.\nFigure 5: error2\n그런데 python은 하위폴더인 parent_dir도 인식하지 못한다. top-level directory가 파이썬의 실행위치가 아님을 알 수 있다. 그러면 main module 기준인가? 확인해 보자. main module을 기준으로 하위폴더의 function2를 import해서 test해보자.\nfunction2의 import\nimport child_dir1.functions2 child_dir1.functions2.sub(3,2) python parent_dir/mydir/main.py Figure 6: import success\n성공적으로 import하는 것을 알 수 있다.\npackage와 import 상대 경로 python으로 program을 만들때, file하나만 만들어 사용하지 않는다. 여러개의 file을 import해서 사용하고, 배포를 통해서 다른사람에게도 전달한다. 그래서 package라는게 나왔다. 정해진 규격에 따라 여러 파일들을 모아서 배포도 가능하고 그 자체가 하나의 독립적인 program이 되는 것이다. main.py같은 main 모듈은 package를 사용할 뿐이지, package에 포함되는 건 아니다. package에서 import문은 여러 특징이 있다. python에서 package를 만들어 test해보자.\npackage를 만드는 것은 간단하다. folder안에 init.py를 만들어 넣으면 package가 된다. init.py가 하는 역할은 단순히 이 폴더가 package라고 말하기도 하지만, import를 처리하기도 한다. 기존 import구문을 확장해서 처리한다. import구문에서는 module, 함수,변수만이 올 수 있었다. 그런데, init.py를 사용해서 import뒤에 폴더가 오게 할 수도 있다. 또한 상대경로도 사용할 수 있다.\nimport뒤에 폴더가 오는 경우\n우선 다음과 같이 game이란 package와 package를 이용할 main.py를 만들었다.\nFigure 7: package example\ngame package안에는 init.py가 있어서 package를 나타낸다. sound도 또다른 package다. sound에는 echo모듈 아래 echo_test()가 있다. main에서 이 함수를 import해서 사용해 보자.\nimport game.sound.echo game.sound.echo.echo_test() Figure 8: package test\n별다른 문제없이 실행되는 것을 볼 수 있다. 다음을 test해보자.\nimport game game.sound.echo.echo_test() Figure 9: package test2\n당연히 에러가 나온다. 왜냐면 import뒤에는 module이 나오거나, from이 있다면, function, 변수가 나와야 하는데, game이란 그냥 폴더가 나왔기 때문이다. 그래서 에러가 나온다. 그런데 package에선 이것이 가능할 수 있다.\ngame의 init.py에 다음을 추가하자.\nimport game.sound.echo 그리고 아까와 동일하게 main.py에서 game만 import하고 echo_test()에 접근하자. 동작이 되는 것을 확인 할 수 있다.\nimport game game.sound.echo.echo_test() Figure 10: package test\n즉 이것은 import game을 읽으면, game폴더안의 init.py의 설정된 내용으로 대체가 된다.\n즉 game이 game.sound.echo로 replace된다.\nimport game.sound.echo game.sound.echo.echo_test() import뒤에 *가 오는 경우\n다음을 test 해보자.\nfrom game.sound import * echo.echo_test() 이것은 문제가 있다. import *를 사용하기 위해선, from에서 module을 포함해야 하는데, from에 있는 sound는 module이 아니다. 따라서 error가 날 수 밖에 없다. 또한 echo.echo_test()도 echo를 import했을 때만 이렇게 사용될 수 있기 때문에 이것도 문제가 있다. 그런데, 이것도 package에선 가능할 수 있다.\nsound폴더의 init.py를 다음과 같이 설정하자.\n__all__ = [\u0026#39;echo\u0026#39;] import에서 *를 사용할 경우, 참조할 module을 지정하는 것이다. 결국 sound폴더의 init.py를 읽고, *가 echo로 replace된다는 뜻이다.\nfrom game.sound import * echo.echo_test() 위의 내용이 아래와 같이 바뀐다.\nfrom game.sound import echo echo.echo_test() 상대 경로 사용하기.\n다시 한번 우리의 package를 살펴보자.\nFigure 11: package example\n여기서 graphics폴더에 graph module을 추가해보자. 그리고 gameplayer라는 module도 상위 폴더에 만들자.\nFigure 12: package example\ngraph 모듈에서 상위폴더의 gameplayer.py라는 module을 import해 보자. 우리는 import구문은 하위 folder의 모듈만 access할 뿐 상위폴더의 module은 access할 수 없다고 했다. package에선 가능하다.\n내가 시도하려는 것은 graph라는 module에서 상위 폴더의 gameplayer라는 module의 pplayer()를 상대경로로 import해서 사용할려고 한다.\ngraph.py에 다음을 추가하자.\nfrom ..gameplayer import pplayer def render(): pplayer() ..은 상위 폴더를 의미한다. 상위 폴더의 module의 pplayer()를 import해서 사용하는 것이다.\n이제 main에서 graph module을 import해서 test해보자.\nfrom game.graphics import graph graph.render() 아래와 같이 동작되는 것을 알 수 있다.\nFigure 13: package results\ninit.py와 전역변수\ninit.py에서 import만 처리하는게 아니라, package에서 전역적으로 사용하는 변수도 넣어도 된다. 예를 들어, game 폴더 아래 init.py에 number_of_players = 10을 넣고 main에서 사용 할 수 있다.\nimport game.sound.echo NUMBER_OF_PLAYERS = 10 main에서 다음과 같이 사용할 수 있다.\nimport game print(game.NUMBER_OF_PLAYERS) summary\ninit.py가 없어도 최신 버전에서는 폴더를 package로 인식한다고 한다. 하지만, init.py가 있으면 많은 import기능을 확장할 수 있고, 전역적으로 사용되는 것을 모아둘 수도 있다. 일종의 convention 비슷하다. 또한, package에서 구현을 하고, main.py는 package를 test하는 용도로 사용한다는 것이다. main에서 모든것을 하려고 하면 안된다. 즉 main은 package에 있는 module을 import해서 test하는 역할이면 된다.\npython standard library 우리가 모든 package를 만들어서 사용하지 않아도 python에서 설치하지 않아도 제공하는 library(package)들이 있다. 이것을 standard library라고 부른다. 가장 많이 사용하는 standard library를 정리한다.\nrandom package import random print(random.randint(0,100)) print(random.uniform(0,1)) 0-100까지의 정수를 반환하거나, 0-1사이의 uniform distribution에서 한개를 sampling할 때 위 package를 사용한다.\ntime import time start = time.time() time.sleep(1) print(time.time() - start) time은 시간관련 standard library다. time()는 현재 시간을 return한다. sleep()는 1초 기다린다.\nthreading import threading import time def print_function(): print(\u0026#34; python은 GIL때문에 single thread이다.\u0026#34;) time.sleep(1) thread = threading.Thread(target=print_function) #쓰레드 만들기 thread.start() #Thread 시작 thread.join() #Thread 수거? GIL은 Global Interpreter Lock이라고 한다. interpreter기반이라서 그렇다고 한다.\npython 외장 library 와 package manager 외장 library python은 많은 외장 library를 제공한다.\n수치 그래프 -\u0026gt; matplotlib 웹서버 -\u0026gt; flask, django gpu연산 -\u0026gt; cupy deep learning library -\u0026gt; tensorflow, pytorch package manager와 virtual env 개요 package manager는 외부 package를 system에 설치하는 프로그램이다. virtual env는 python이 설치된 가상환경을 의미한다.\n문제점 python project마다, 다른 version의 python interpreter를 사용한다거나, 외장 library를 가져와서 사용할 수 있다. 예를 들어서, web개발을 위해 django를 설치하고 deep learning을 위해서 pytorch를 설치했다고 하자. 해당 framework마다 내부적으로 다른 version의 package들을 가져와서 사용하는데, 이게 충돌의 위험이 있다고 한다. 또한 python의 version에 따라 동작이 안되는 package가 있을 수 있다. 예를 들어서 django는 3.5에서 성능이슈가 있고, pytorch는 3.8에서 문제가 있다면, 둘다 문제가 없는 3.6이나 3.7을 사용하면 된다. 과연 문제가 없을까? 3.6에서 두 framework의 내부 package들끼리 충돌이 일어날 수 있다. 그래서 django를 위해선 python 3.9를 사용하고 pytorch를 위해선 3.8을 사용하면 된다. 그런데 여기서 문제, python은 system에 하나만 설치할 수 있지 않나? 그 문제를 해결한게 virtual environment이다.\npip(+ virtual env)와 anaconda pip와 anaconda는 package manager다. package를 system에 설치하고, 의존성 검사도 하고, 삭제도 하는 관리 프로그램이다. pip에는 virtual env, 즉 python을 버전별로 여러개 한 system에 설치하는 기능은 없다. virtualenv와 virtualwrapper등의 도움을 받아야 한다. anaconda는 conda에서 virtual env기능도 지원한다.\nanaconda는 200개의 외부 library가 설치된다. 무겁다. miniconda는 최소만 설치된다.\ncolab colab은 notebook마다 kernel이 개별적으로 있다. kernel은 python interpreter + library인 environment를 의미한다.\nanaconda 사용법 강사는 anaconda를 위주로 사용법을 설명해준다.\nvirtual environment 만들기 conda create -n nlp : nlp라는 가상환경을 만든다. -n은 name이라고 한다. conda activate nlp : nlp 가상환경을 활성화한다. conda deactivate : 현재 nlp 가상환경을 비 활성화 한다. package management conda install \u0026lt;package name\u0026gt; -c \u0026lt;설치 채널\u0026gt; : 채널은 package가 설치된 목록을 가지고 있는 repo로 봐도 된다. 유명한 channel로는 conda-forge가 있다. conda의 기본채널도 있다. 어떤 package를 설치하려고 하는데 default package에서 찾을 수 없다면, conda-forge채널에서 찾을 수 있을것이다. conda-forge에서 찾을수 없다면 거의 안 쓰이는 package라고 보면 되고, pip의 채널을 사용해야 한다. package를 설치할때는 anaconda hub 를 통해 검색하면 좋다. conda-forge사이트이다. pytorch같은 경우는 pytorch에서 직접 설치할 수도 있다. pytorch의 channel이 있기 때문이다. conda install pytorch -c pytorch default channel은 안써도 상관없고 써도 상관없다. conda install python=3.9 -c default conda list : 설치된 library를 볼 수 있다. conda list | grep numpy anaconda를 설치하고 깔아야 하는 library matplotlib : conda install로 설치하자. tqdm(progress bar): 진행사항을 progress bar로 보여준다. module과 built-in function에 대하여 .py파일은 module이다. module은 class로 봐도 된다. python에서 main module, 즉, program의 시작을 나타내는 module은 main이라는 class로 보면 된다. java에서는 public static void main()아래에서 coding을 한다. 변수도 선언하고 for-loop도 돌린다. public static void가 포함된 .java파일에는 class가 있다. java에선 하나의 파일이 하나의 class이기 때문에, class 문장으로 시작한다. 그런데 python에서는 implicit하다. 하나의 파일이 하나의 class인것도 java와 동일하다. 다만, class라고 명시적으로 쓰지 않는다. 그런데 module을 import하면 import한 모듈의 class가 만들어지고, class.변수,함수 이렇게 접근을 한다. java나 python이나 모두 file은 하나의 class이지만, java는 명시적으로 class가있지만, python은 없다고 했다. 그래서 .py를 열어보면, 바로 for-loop이 나온다거나, len()같이 함수들이 불쑥 불쑥 튀어나온다. 그런데, 그런 built-in function이란것들은 function같이 보이지만, main class혹은 module class의 method이다. len은 물론 object를 상속 받았기 때문에, object의 method이지만, python에서 function이라고 부르는 대부분은 method이다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture8-module-and-package\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture9-advanced-data-structure\/": {
        "title": "lecture9-Advanced-Data-Structure",
        "tags": [],
        "content": "Stack a = [1,10] a.append(4) a.append(20) print(a.pop()) print(a.pop()) stack은 FILO(First In First Out) python에서 stack은 list를 사용하면 된다. list에서 제공하는 append와 pop을 사용한다. list의 시작주소와 마지막 노드 주소를 가지고 있기 때문에 삽입과 삭제는 O(1)이 걸린다. Queue a = [1,0] a.insert(0,20) a.insert(0,15) print(a) print(a.pop()) Queue는 FIFO이다. python에선 list의 내장함수를 이용해서 사용할 수 있다. insert()로 0번 position에 입력하면 값들이 계속 shift된다. pop()은 마지막 position에서 값을 꺼낸다. 강사는 queue를 list를 사용하면, insert와 pop시 속도가 O(n)이 된다고 한다. python의 list는 dynamic array라고 한다. 근데 또 끝에 있는것을 pop()할때 O(n)이라고 하는데, 그러면 list 맞는거 같은데\u0026hellip; 내 생각에 list로 구현된 queue의 경우, pop()은 O(n)이 맞는듯하다. 왜냐하면 deque를 설명할 때, tail의 위치를 유지하고 있어서 pop()을 할때 O(1)이 걸린다는 얘길한다. 강사는 linked list를 사용해서 queue를 만들어야 한다고 한다. deque from collections import deque queue = deque([10,5,2]) queue.appendleft(16) #왼쪽 삽입 queue.pop() #오른쪽 삭제 queue.append(20) #오른쪽 삽입 queue.popleft() #왼쪽 삭제 print(queue) print(deque(reversed(queue))) #deque 뒤집기 O(n) deque는 linked list로 이루어진 double queue라고 한다. stack은 삽입과 삭제가 한방향에서만 일어난다. queue라는 것은, 삽입과 삭제가 서로 다른방향에서 일어난다. dequeue는 양방향에서 삽입과 삭제가 일어날 수 있다. priority queue(heapq) priority queue의 장점 priority queue는 매우 자주 사용되는 자료 구조라고 한다. queue에 입력된 data중에서 최소,최대값을 빠르게 구하고 싶다면, priority queue를 사용해야 한다고 한다. min/max함수를 써서 주어진 collection의 최소, 최대를 찾을수도 있다. 하지만, O(n)의 속도가 걸린다고 한다. 내부가 정렬되어 있다면, binary search로 O(log n)이 걸릴것이다. 그럼 삽입할때 마다, 정렬을 해줘야지 search시에 O(log n)을 유지하는데, 정렬을 하는데에 O(NlogN)이 걸리기 때문에 그닥 효율적이지 못하다고 한다. priorty queue를 사용하면, 이것을 해결한다고 하는데, 뭔말 하는지 모르겠다. priority queue는 python에서 heapq라고 한다.\nheapq 사용법 import heapq queue = [5,2,8,4] heapq.heapify(queue) #초기화, tree로 변경 O(N log N) print(queue) print(queue[0]) heapq.heappush(queue,3) print(queue) print(queue[0]) heapq.heappush(queue,6) print(queue) print(queue[0]) item = heapq.heappop(queue) print(item, queue[0]) item = heapq.heappushpop(queue,7) print(item, queue[0]) heap이란 자료구조 별도로 있다. max heap과 min heap이 있는데, max heap은 부모 노드값이 자식보다 큰 tree를 말하고, min heap은 부모 노드값이 자식보다 작은 tree를 말한다. python의 heapq는 min heap이다. 내부적으로 완전 이진 tree를 사용하고 있다. 사용하고 있는 tree와 배열간에는 다음과 같은 관계가 있다고 한다.\nheap[k] \u0026lt;= heap[2*k+1] and heap[k] \u0026lt;= heap[2* k+2] Defaultdict 개요 dictionary는 기본적으로 없는 key로 접근했을 때 key error를 발생한다.\nd = {\u0026#34;first\u0026#34;: 0} print( d[\u0026#34;second\u0026#34;]) 이것을 방지하기 위해서, key가 없을 때, default값을 반환하는 get()를 제공한다.\nd = {\u0026#34;first\u0026#34;: 0} print( d.get(\u0026#34;second\u0026#34;, \u0026#34;없어요\u0026#34;)) defaultdict()는 위에 get()가 사용하는 방식처럼 미리 default값을 dictionary에 정의한 것이다. 그래서 key가 없더라도 에러를 출력하지 않고 기본값을 출력한다.\n사용예 defaultdict가 어떨때 사용하면 좋은지에 대해서 강사는 예를 든다. 만일 우리가 어떤 text북에서 나오는 모든 글자를 counting하고 싶다고 하자. 어떻게 programming할 것인가?\ntext = \u0026#34;\u0026#34;\u0026#34;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan nisl.\u0026#34;\u0026#34;\u0026#34; characters ={} for char in text: count = characters.get(char, None) if count is None: characters[char] = 0 characters[char] += 1 print(characters) program을 작성하기 위해서, 입력은 무엇인지, 입력에 대해 어떤 처리를 해야 하고, 그 처리 결과를 어떻게 할지를 생각해야 한다. 입력은 text문자열이다. text문자열을 어떻게 처리할 것인가? text문자열을 하나씩 꺼낼것이다. text문자열은 유한개이다. 따라서 for loop을 사용할 것이다. text문자입력에서 하나씩 꺼낸 문자를 어떻게 처리 할 것인가? 그 문자를 counting해야 한다. 어떻게 counting할 것인가? dictionary를 사용해서, 해당 문자와 counting을 저장하고 싶다. 해당문자와 그 문자의 occurs를 같이 저장해야겠다는 idea를 도출하는게 중요하다. 문자와 occurs를 쌍으로 저장하려면 tuple도 있고, dictionary도 있다. tuple을 사용하려면, list같은 data structure가 또 필요하다. 그래서 dictionary를 사용하겠다. dictionary는 쌍으로된 많은 data를 저장할 수 있기 때문이다. text에서 문자 하나를 꺼내서 dictionary에 있는지 없는지를 검사한다. 만일 있다면, occurs를 증가시킨다. 없다면 dictionary의 key로 등록하고 occurs를 1로 counting한다. 그런데 위의 코드는 내 생각과 다르다. 위의 코드에선, key에 해당하는 문자가 있는지 없는지 검사하지 않는다. 무조건 key에 해당하는 값을 return하거나, 없으면 None값을 key로 return하는 dictionary의 get이란 함수를 사용한다. get이란 함수의 좋은점은 2가지가 있다. key가 없으면 에러를 내지않고 임의의값으로 key를 등록한다. key가 있는지 없는지 확인할 필요가 없다. 없으면 default 값으로 key를 등록하기 때문이다. 그리고 if문을 사용해서 none으로 등록된 key를 제대로 된 alphabet으로 하고 occurs를 등록한다. 이렇게만 해도 충분해 보인다. 하지만, 강사는 defaultdict가 이것을 훨씬 편하게 해준다고 한다.\ndefaultdic의 사용 from collections import defaultdict text = \u0026#34;\u0026#34;\u0026#34;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan nisl.\u0026#34;\u0026#34;\u0026#34; characters = defaultdict(int) # characters = defaultdict(lambda: 0) for char in text: characters[char] += 1 print(characters) defaultdict을 사용하면, 매우 간단해지는 것을 볼수 있다. 즉 text로부터 꺼낸 알파벳에 대한 key값이 모두 dictionary에 들어있다고 생각하게끔 만든다. 즉 모든 알파벳에 대한 key와 value가 이미 dictionary에 있기 때문에 해줘야 할 것은 text에서 뽑은 key를 갖는 요소에 +1만 해주면 된다. 위에서 살펴봤던 get을 사용하는 경우나, 내가 생각했던 방식보다 훨씬 간단한것을 알 수 있다.\n여기서 defaultdict를 생성할때, int를 주면 int()를 해서 모든 값이 0으로 채워진다고 한다. 그런데 특정값을 생성할 수 있는 lambda를 사용해도 된다. lambda로 0을 만들수도 있고, 특정 계산이 들어갈 수도 있다. 그리고 for-loop에서 꺼낸 알파벳을 key값으로 해서 value를 저장하는데, key가 없다면 key를 생성하는 부분은 내부적으로 구현되서 감춰져 있다. 강사는 dictionary를 사용할 일이 있을때, defaultdic을 사용하는것도 좋지만 counter를 사용하면 더 깔끔하게 코딩할 수 있고 pythonic하다고 한다.\nCounter 개요 Counter는 defaultdic과는 달리 세는데 최적화된 class라고 한다. defaultdict를 다시 한번 살펴보자.\nfrom collections import defaultdict text = \u0026#34;\u0026#34;\u0026#34;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan nisl.\u0026#34;\u0026#34;\u0026#34; characters = defaultdict(int) # characters = defaultdict(lambda: 0) for char in text: characters[char] += 1 print(characters) 이것을 counter를 사용하면 다음과 같이 된다고 한다.\nfrom collections import Counter text = \u0026#34;\u0026#34;\u0026#34;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan nisl.\u0026#34;\u0026#34;\u0026#34; characters = Counter(char for char in text) print(characters) Counter안의 표현법은 list comprehension과 비슷하다. 간단하게 counter의 기본 동작을 확인하는 code를 짜보자.\nfrom collections import Counter print(Counter([1,2,1,2,3])) Counter에 [1,2,1,2,3]이라는 list를 넣어주면, list의 item을 key값으로 하고, 해당 key의 occurs를 value로 하는 dictionary가 내부적으로 생성된것을 볼 수 있다. 즉 우리가 원래 하려고 했던 작업인 text로 부터 알파벳들이 몇번씩 occurs되는지를 Counter를 사용하면 매우 간단하게 할수 있겠다는 생각이 든다. 즉 list를 넣어주면 counting값을 갖는 dictionary를 자동으로 만들어주니까, 우리가 해야할 것은 text를 Counter에 넣어만 줘도 되는거 아닌가? 물론 text는 string이고 list가 아니라는 차이는 있다. 한번 해보자.\nfrom collections import Counter text = \u0026#34;\u0026#34;\u0026#34;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan nisl.\u0026#34;\u0026#34;\u0026#34; print(Counter(text)) 문제없이 된다. 그런데, 왜 강사는 string을 list comprehension을 사용해서 list로 만들었는지는 이해가 안간다. 다만, list comprehension을 넣을수 있다. 이것을 알려주려 했을지도 모르겠다. 또다른 예를 보여준다.\nfrom collections import Counter print(Counter([\u0026#34;test\u0026#34;,\u0026#34;test\u0026#34;, \u0026#34;text\u0026#34;])) 여기서 궁금한점, string을 사용해서 단어를 세는 program을 Counter로 작성하는것이 가능할까? 하는것이다.\ncounter에 대한 분석 counter는 dictionary from collections import Counter c = Counter({\u0026#34;korean\u0026#34;:2, \u0026#34;English\u0026#34;:3}) print(c.keys()) print(c.values()) print(c[\u0026#34;korean\u0026#34;]) print(list(c.elements())) # d = {\u0026#39;a\u0026#39;:3,\u0026#39;b\u0026#39;:2} # print(list(d.elements())) Counter는 내부적으로 dictionary를 이용한다. 따라서 dictionary로 봐도 된다. 그리고 list만 인자로 넣는것이 아닌 dictionary를 인자로 넣어도 아무 문제 없다. list의 경우 내부적으로는 list를 counting해서 dictionary를 다시 만든다. dictionary는 그대로 가져다 쓴다. 여기서 특이한 method가 있다. elements라는 method이다. 일반적인 dictionary에는 존재하지 않는다. counting은 list를 dictionary형태로 바꿀때 counting value를 사용했다. 이를 elements()로 list로 변환할 때는 counting을 했던것을 다시 바꿔준다.\ncounter는 집합 연산 지원 from collections import Counter a = Counter([1,1,2,2,2,3]) b = Counter([2,3,3,4]) print(\u0026#34;a =\u0026#34;, a) print(\u0026#34;b =\u0026#34;, b) print(\u0026#39;a+b =\u0026#39;, a+b) print(\u0026#39;a\u0026amp;b =\u0026#39;, a\u0026amp;b) print(\u0026#39;a|b =\u0026#39;, a|b) print(\u0026#39;a-b =\u0026#39;, a-b) # a = {\u0026#39;a\u0026#39;:3,\u0026#39;b\u0026#39;:5} # b = {\u0026#39;c\u0026#39;:5, \u0026#39;b\u0026#39;:2} # print(a+b) a+b\na와 b가 counter객체일때 두 객체의 합은 무엇일까? dictionary에선 +연산자를 지원하지 않는다. counter는 내부적으로 key에대한 counter를 가지고 있기 때문에, key가 같다면, counter수를 증가시켜준다.\na\u0026amp;b\na\u0026amp;b도 예측하기 어렵다. 우선 두 counter객체가 가진, key가 양 객체에 모두 존재해야 한다. value에 해당하는 occurs는 작은값을 가지게된다. 그게 공통적으로 갖게 되는 값이기 때문이다. 예를 들어, a객체에 2:1, b객체에 2:4가 있다면, a\u0026amp;b로 얻는 것은 2:1이 된다.\na|b\n이것도 key와 value를 모두 따져야한다. key의 경우, a객체와 b객체에서 한번이라도 나온것은 다 포함된다. value의 경우, 계산은 하지 않는다. 둘중 큰값을 선택한다. 예를들어서, a객체에 2:1이 있고, b객체에 2:3이 있다면 a|b로 얻는것은 2:3이다.\na - b\n이것은 a객체가 가진 item에서 b객체의 item을 빼준다. 여기서 고려해야 하는것은 a객체에도 있고, b객체에도 있는 item이다. b객체에만 있는것은 고려대상이 아니다. a객체에만 있다면, -해야할 께 없기때문에 고려대상이 아니다. 즉 공통으로 있는 item에서 계산이 일어난다. 예를 들어 a객체에 2:3이 있고, b객체에 2:1이 있다면, a-b에는 2:2가 들어가게 된다.\nNamed Tuple 개요: named tuple이 나온 배경 class Coords3D: def __init__(self, x, y, z): self._x = x self._y = y self._z = z @property def x(self): return self._x @property def y(self): return self._y @property def z(self): return self._z named tuple이란건 data만을 담기 위한 class라고 한다. 위의 예를 보면, class를 만들었다. 이 class에는 x,y,z값을 저장하고 별다른 method가 없다. 즉 하나의 instance는 하나의 3d 좌표값만을 갖는 class다. 한번 생성된 3d값은 수정은 안되고, @property를 통해서 각각의 값을 꺼내서 보거나, 사용할 수 는 있지만, 새 값을 넣는건 안된다. 아래 property를 사용하는 예다.\ncoord = Coords3D(1,2,3) print(coord.x) print(coord.y) print(coord.z) 이런 class를 만들 수도 있지, 난 대수롭지 않다고 생각한다. 그런데, 이런 간단한 구조인데 굳이 class를 만들 필요가 있냐?라는 사람들이 있다고 한다. 그사람들이 말하는 것은 data만 저장하는 값인데, 값을 꺼내기 위해서 @property를 사용한 getter함수를 모두 작성해야 하고, 같은형태의 많은 data값을 저장하는 것도 아니기 때문에 굳이 이렇게 만들어서 써야하느냐는 사람들이 있다. 그런 사람들은 3d좌표값을 나타낸다면, tuple을 사용하면 되지.라고 말한다.\ncoords3d = (10,20,30) print(coords3d[0]) print(coords3d[1]) print(coords3d[2]) 위와 같이 tuple을 사용하면, class를 사용한 것과 별차이 없다. class를 사용했을때는 x,y,z와 같이 좌표값을 인식할 수 있는 변수를 사용했기때문에 coords.x, coords.y, coords.z 처럼 가독성은 더 좋지만, 기능은 별다른 점이 없기 때문이다.\nnamed tuple의 사용 위의 tuple을 사용하면, index로 접근하기 때문에 가독성이 안좋았다. 이 단점을 없애기 위해서 named tuple이란 자료구조를 사용한다.\nfrom collections import namedtuple Coords3D = namedtuple(\u0026#34;Coords3D\u0026#34;, [\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;z\u0026#39;]) point = Coords3D(10,20,z=30) print(point.x) print(point[1]) print(*point) # point[1] += 1 error 발생 namedtuple은 이름이 암시하듯 tuple의 item에 이름 붙이기가 가능하다. 이것의 생성방식이 좀 특이한데, 다음을 보자.\nCoords3D = namedtuple(\u0026#34;Coords3D\u0026#34;, [\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;z\u0026#39;]) 첫번째 인자로 type(class) 이름이 들어간다. 그리고 두번째 인자로 item의 이름이다. type이름이 들어간다는것은 우리가 class로 coords3d라는 class를 만들었듯이, namedtuple도 내부적으로 class를 만든다는 것을 의미한다. 이렇게 만들어진 type의 instance를 만들어사 사용한다. 이것의 장점은 여러종류의 tuple을 만들고, class 이름도 마음대로 정할수 있다는 것이다. 사용법을 살펴보자.\n만들어진 Coord3D instance인 point는 name으로도 접근 가능하고 indexing으로도 가능하다. 한가지 특이한것은 point객체는 tuple이기 때문에 point라는 tuple이 가진 내용을 unpacking해서 보여줄 수 있다는 것이다.\nprint(*point) tuple은 immutable하기 때문에 값을 변경시키는 += 연산자는 에러를 발생한다.\nDataclass의 사용 개요 위에서 data만을 저장하는 경우가 있었다. 예를들면, 3d좌표값 같은 경우가 있었다. 3개의 좌표값을 갖는 data structure를 위해서, 처음에는 class를 만들었다. class를 사용하기엔 너무 거창해서, 그냥 tuple을 사용하려 했으나 가독성이 안좋아서 namedtuple을 배웠고 이를 사용할 수도 있었다. 근데 처음에 정의한 class처럼 비슷한 용도로 사용할 수 있는 dataclass라는게 있다고 한다.\n사용법 from dataclasses import dataclass @dataclass class Coords3D: x: float y: float z: float = 0 def norm(self) -\u0026gt; float: return (self.x ** 2 + self.y ** 2 + self.z **2) ** .5 point = Coords3D(10,20,z=30) print(point) print(point.norm()) Data만을 저장하기 위해서 우리가 만들었던 class를 다시 한번 보자.\nclass Coords3D: def __init__(self, x, y, z): self._x = x self._y = y self._z = z @property def x(self): return self._x @property def y(self): return self._y @property def z(self): return self._z @dataclass라는게 class에 붙게되면, 형식이 좀 다르다. 일반적인 class를 작성할때는 init()도 정의해야 했고, 값을 꺼낼수 있도록 @property라는 decorator를 구현해야 했다. 그런데, @dataclass는 이 과정을 다 없앴다. 즉 class의 내부변수 x,y,z만 정의하면 된다. 나머지 instance.x, instance.y, instance.z로 해서 값을 접근하게 해주는 @property로 함수를 정의하는것은 해주지 않아도 된다. dataclass로 만들어진 instance는 instance를 출력할 수 있는 str()가 재정의되어 있는듯하다. 그래서 print()로 출력할때 나름 이쁘게 보여진다고 한다. 그런데 그냥 객체의 요소를 보여줄 뿐 예쁘다는 생각은 들지 않았다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture9-advanced-data-structure\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/webcrawler1\/": {
        "title": "web scraping1",
        "tags": [],
        "content": "개요 Figure 1: web scraping book\n집에 돌아다니는 읽어보지 않은 책이 있다. 라이언 미첼이라는 사람이 쓴 건데, web scraping 그리고 web crawling에 관한 책이다. 한번 읽어 보고 정리하기로 한다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/webcrawler1\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/lecture2_variable_and_operator\/": {
        "title": "lecture2_variable_and_operator",
        "tags": [],
        "content": "[lecture2] variable \u0026amp; operator 변수와 assignment 변수는 lisp에선 symbol이라고 부르고, 모든 symbol은 동일한 형태의 structure를 가졌다. symbol의 이름은 unique했다. symbol의 이름은 address였기 때문이다. 하지만, python에서 변수는 type이 가리키는 structure를 갖는다. 모두 동일한 모양이 아니다. 변수의 이름은 unique한건 마찬가지 인 듯 하다. address이기 때문이다. 변수와 assignment의 예 1 example\n(1) a = 15 (2) b = a (3) b print(b) interpreter가 이것을 어떻게 해석할까?\n(1) 과정\nlvalue인 a를 보고 symbol table에서 찾는다. 없다면 a라는 이름을 새로 만든다.\nrvalue인 15를 본다.\n=(assignment)를 실행한다. rvalue의 type이 int라는 것을 알고 int객체를 만든다.\nint객체의 value에 15를 집어넣는다.\nint객체의 name에 a를 집어넣는다.\n이렇게 해서 하나의 객체를 만들었다. (2) 과정\nlvalue인 b를 보고 symbol table에서 찾는다. 없다면 b라는 이름을 만든다.\nrvalue인 a를 보고 symbol table에서 찾아서 a를 꺼낸다. 없으면 error가 발생된다.\n=(assignment)를 실행한다. int객체를 만들고, value로는 a값을 , name이 b인 객체를 만든다.\npython interpreter가 객체의 value를 꺼낸다. 즉 eval한다.\n즉 assignment의 역할이 무엇일까?\n객체를 만드는 것이 아닌가? 즉 interpreter는 = 을 보고, rvalue와 lvalue를 보고 객체를 만들어야 한다는 걸 안다. 그러나 무조건 객체를 만드는 것은 아니다. lvalue를 보고, 해당 symbol이 symbol table에 있는지 여부를 확인한다. 없다면 객체를 만들려고 한다. 만일 있다면, immutable인지 mutable인지 확인한다. 만일 mutable이라면, 새로운 객체를 만들지 않고 update한다. immutable이라면, 새로운 객체를 만든다. 이제 rvalue 살펴본다. rvalue의 type을 확인하고 그 type에 맞는 객체를 만든다. 위의 예를 보면, a = 15에서 a가 symbol table에 없기 때문에, 객체를 생성해야 한다고 본다. 그리고 rvalue를 보고 int type임을 알수 있기 때문에 int객체를 만드는 것이다. 객체를 만든후 name과 value에 값을 assign한다. 그리고 만든 객체의 value는 rvalue인 15를 가리고 name은 lvalue인 a를 가리킨다. 변수와 assignment의 예2 example2 a = b = 2 뒤에서부터 처리한다. 즉 name이 b, value가 2인 int객체를 만든다. 그 다음 name이 2 value가 b를 가리키는 또 다른 int 객체를 만든다. literal object에 대해서 3이나 5와같은 값도 객체다 literal object이다. 예를 들어서, 아래와 같은 것이 가능하다.\n4.0.real or (4).real 4.0은 float객체가 만들어진 후 real이란 float의 method가 수행되는 것이다.\n나는 lisp의 symbol과 비슷하다는 가정아래 해석한다.\nFigure 1: lisp의 symbol1\nliteral 객체의 assignment는 새로운 객체를 생성하고 객체의 value가 literal object를 가리키는게 아니라 value의 값으로 들어가는거 같다. 예를 들면 a =3의 경우, 새로운 객체가 만들어지고 객체의 value로 3이란 객체를 가리키는게 아니라 3값이 직접 새로운 객체의 value가 되는 것 같다.\nname(변수)와 assignment의 특징 숫자로 변수명을 시작할 수 없다. 대소문자를 구별한다. assignment의 특징 assignment는 return값이 없다. 그래서 함수형 언어에서는 권장하지 않는다. 예를 들어, (a = 2) == 2 이것은 syntax error를 발생한다. a와 2를 갖는 객체를 만들지만, 그 객체를 return하지 않기 때문에 비교할 수 없다. 그런데, python에선, 객체를 return하게 할 수도 있다. 아래를 보자.\n(a := 2) == 2 이것은 어떻게 해석할 것인가? name이 a이고 value가 2인 객체를 return한다. ==은 rvalue, lvalue의 객체의 value를 비교한다.\nprimitive data types data type을 알아야 하는 이유는 한 가지다. 객체를 만들때, data type에 맞는 객체를 만들기 때문이다. 그리고 type에서 제공하는 method와 member variable을 사용할 수 있기 때문이다. numerals int,float,complex double은 없다. float가 double과 같다고 보면 된다. example float: 1.7, -5.7, 4.67e-3, 3e5 complex: 1+8j, 1.6+8j string string char type은 없다. example \u0026#39;text\u0026#39;, \u0026#34;한글\u0026#34; boolean bool example True, False None 일종의 null, example None 연산자 (operator) python이 객체 지향적 언어라고 하는데, 객체의 method를 사용하는게 아니라, 객체와 객체 사이에 operator를 넣어서 연산하는게 이상해 보일 수 있다. 그러나, operator는 method로 변환이 된다. 다음을 참조 하자. 참조:https://www.pythonmorsels.com/everything-is-an-object/#manually-calling-dunder-methods 즉, 연산자는 어떻게 보면, 모든 객체에 내장된 멤버 함수로 봐도 된다. Object 객체의 멤버 함수로 보는게 더 정확할 듯 하다. 연산자의 종류 arithematic operator\n(덧셈), - (뻴셈) , *(곱셈) , **(거듭제곱), /(몫) , //(몫,정수), %(나머지) bit operator\n~(NOT): 이게 좀 계산법이 황당한데, 우선, 2진수로 변환한다. 그리고 앞에 0을 붙인다. 양수이니까, 예를 들어, 5 =\u0026gt; 101 =\u0026gt; 0101 그리고, ~연산을 적용한다. ~연산은 1010이다. 이게 답이다. 그런데, 여기서 1을 빼주고 1의 보수를 취해서 값을 도출한다. 즉 1010에서 1을 빼서 1001이 되고, 여기서 1의 보수를 취해 0110이 나오는데, 원래 msb가 1이였기 때문에 -6값이 되는 것이다. | (OR): 2진수로 변환한 후 or연산을 하면 된다. \u0026amp; (AND): 2진수로 변환한 후 and연산을 한다. ^ (XOR): 같으면 0, 다르면 1로 계산한다. \u0026lt;\u0026lt;, \u0026gt;\u0026gt; : shift연산은 곱셈과 나눗셈이 된다. 축약 가능\nexample (1) a = a + 1 =\u0026gt; (2) a += 1 두 식은 약간 다른 의미를 갖는다고 한다. in-place하고 out-place의 개념을 설명한다. 둘다 assignment문이라서 object를 만들거라고 생각하지만, (1)은 out-place라서 새로운 객체를 만들지만, (2)는 in-place라서 기존 객체의 값을 update 시도를 먼저 하고 안될 경우 새로운 객체를 만든다고 한다. bit 연산자도 축약에 사용할 수 있다. a = 7 (1) a = a ^ 4 (2) a ^= 4 비교 연산자\nx \u0026lt; y x \u0026gt; y x \u0026lt;= y x \u0026gt;= y x == y : x,y value가 같다. x is y : x,y 주소가 같다. x != y : x, y value가 다르다. x is not y: x,y 주소가 다르다. x in X : x가 X에 포함된다. x not in X : x가 X에 포함되지 않는다. boolean operator\noperand가 boolean type일때 수행한다. bit operator는 operand가 arithematic이다. not AND OR operator priority\n기본적으로 산술연산자 \u0026gt; bit연산자 \u0026gt; 비교연산자 \u0026gt; 논리연산자의 순이다. mutable vs immutable primitive data type은 값을 변경할 수 없는 immutable이다. example1\nexample\n(1) a = 10 (2) b = a (3) a += 1 (4) a, b, a is b python interpreter는 a = 10을 본다. 우선, lvalue인 a에 대해서 symbol table에서 확인한다. 없다. 그리고 rvalue를 본다. int type이란 것을 알기에 int객체를 만들고, name과 value를 설정한다. python interpreter는 b = a를 본다. lvalue인 b가 symbol table에 있는지 확인한다. 없다. rvalue인 a를 본다. symbol table에 있다. 해당 객체의 type정보만 가지고 온다. int다. 이제 객체를 만든다. b라는 이름과 a라는 값을 갖는 객체를 만들었다. python interpreter는 a += 1을 본다. lvalue인 a를 symbol table에서 찾는다. a는 10의 값을 가지고 있는 immutable한 객체다. rvalue를 본다. a가 가진 값과 1을 더해 11이란 값을 만든다. 이제 객체를 만들어야 하는데, lvalue가 immutable하기 때문에 update할 수 없다. 새로운 객체를 만든다.a라는 새로운 객체를 만든다. 그러면 기존 a객체가 갱신된다. 여기서 확인해야 할 것은 b의 value다. b의 value는 a인것인가? 아니면, a가 가진 값인가? 지금 봤을때는 a가 가진 address인거 같다. 그래서 (3)까지 출력했을 때, a값은 새로운 객체의 11값을 가지고, b의 경우는 옛날 객체인 a의 값인 10을 갖는다. 새로운 a객체를 가르키지 않는다. 그리고 a is b는 false다. is라는 함수는 a와 b의 값을 가져오기 때문이다. example2\n(1) a = [1,2,3] (2) b = a (3) a += [4] (4) a, b, a is b python interpreter는 a = [1,2,3]을 본다. lvalue를 보고 symbol table에서 a를 찾는다. a는 없다. rvalue를 본다. [1,2,3]이다. eval할 필요가 없다. 이제 객체를 만든다, name,value를 연결한다. python interpreter는 b = a를 본다. lvalue의 b를 symbol table에서 찾는다. 없다. rvalue의 a의 type을 확인한다. list다. list객체를 만들고,이름과 value를 연결한다. 여기서 list객체를 만드는지는 잘 모르겠다. python interpreter는 a += [4]를 본다. lvalue인 a를 본다. symbol table에 있다. type을 보니 list다. 즉 mutable하다. rvalue를 본다.a +[4]를 계산하자. a의 value인 [1,2,3]의 append를 사용해서 [4]를 추가한다. [1,2,3,4]의 값이 나왔다. 이제 여기서 객체를 만드는것이 아닌 a객체의 value를 update한다. a의 값은 [1,2,3,4]이고, b도 [1,2,3,4]이다. a is b는 True가 된다. example3\na = [1,2,3,4] b = a a = a + [5] a,b, a si b In-place operator에 대해서 a +=1과 a= a+1의 차이: assignment와 operator의 차이 python에서 모든 것은 객체다. 그리고 모든 function은 어떤 객체의 method다. 그런데, 위에서 봤던 operator들은 method의 모양을 하고 있지 않다. 그럼 operator라는 것은 무엇인가? 본질은 method다. 즉, member method이다. 이것은 여기 에서 확인할 수있다. 이제 a += 1과 a = a+1에 대해 말해보자. a += 1에서 +=는 operator임을 알수 있다. member function, 즉 method라는것은 해당 객체의 값을 변경, update를 한다. 그런데 a 객체는 immutable이다. integer literal이기 때문에 값을 변경하지 못한다. 그래서 새로운 객체를 만들어낸다. 만일 a가 list와 같은 mutable한 객체라면, 그 값은 변경이 될 것이다. 그리고 a = a + 1의 경우는 assignment다. 즉, 새로운 객체를 만들어 내는 것이다.\nexamples\nexample1\na = 10 b = a a += 1 print(a) print(b) print(a is b) example2\na = 10 b = a a = a + 1 print(a) print(b) print(a is b) example2\na = [1,2,3,4] b = a a += [5] print(a) print(b) print(a is b) example2\na = [1,2,3,4] b = a a = a + [5] print(a) print(b) print(a is b) == 과 is ==는 값을 비교, is는 객체의 이름(주소)를 비교\nexample1\n아래는 False가 나와야 정답인데, 이상하게 True가 나온다. a = 13453436 b = 13453436 print (a is b) 아래는 True가 나온다. a = 13453436 b = 13453436 print (a == b) example2\n이것도 제대로된 결과가 나오지 않는다. True,True,False,True가 정답이라고 한다. print(b is \u0026rsquo;long-long-text\u0026rsquo;) 이 왜 false가 나오는지 모르겠다. a = \u0026#39;text\u0026#39; b = \u0026#39;long-long-text\u0026#39; print(a is \u0026#39;text\u0026#39;) print(a == \u0026#39;text\u0026#39;) print(b is \u0026#39;long-long-text\u0026#39;) print(b == \u0026#39;long-long-text\u0026#39;) example3\na = True print(a is True) example4\na = None print(a is None) Dynamic typing type을 명시하지 않고, assign할 때, rvalue를 보고 type이 정해진다. implicit type conversion bool -\u0026gt; int -\u0026gt; float -\u0026gt; complex bool type은 int type으로 conversion이 가능하고, int는 float로 conversion이 가능하다.\na = True a = a + 2 print(a) a = a + 1.5 print(a) python interpreter가 a = True를 보고, Boolean 객체를 만들고, 객체에 a라는 이름과 True라는 값을 맵핑한다.\npython이 a = a + 2를 본다. lvalue인 a를 symbol table에서 찾는다. 있다. rvalue를 계산한다. a의 value는 True이고, 2라는 값이 넘어온다. 이때 boolean객체의 overriding된 + method가 True와 2라는 값을 더해서 어떤일을 하는지는 정확히 모르겠다. 여튼 더하면 3이란 값이 계산되고, assign을 적용해서, int객체를 만들고 a의 이름과 3이란 값을 갖게 된다.\npython interpreter가 a = a + 1.5를 보고 위의 과정과 비슷한 과정을 거치게 된다.\nexample2 형변환이 안된다.\na = 1 a + None a + \u0026#39;text\u0026#39; explicit type conversion complex를 float로, float를 int로, int를 str로 형변환을 할수 있다. 이것은 강제 형변환을 해야 한다. example a = 12345 float(a) complex(a) str(a) bool(a) bool의 경우는 none,[],{} 등은 false값을 갖는다. 형변환의 또다른 예 print(int(75.75)) print(str(75.75)) print(bool(\u0026#39;True\u0026#39;)) 소수점 처리 방식 소수점 버림: int(75.75) 소수점 반올림: round(75.75), object의 method. 소수점 올림: math.ceil type checking type이라는 method를 사용한다. 아무래도 object의 method인거 같다. isinstance는 predicate이다. example a = 123 type(a) isinstance(a,float) ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/lecture2_variable_and_operator\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/linear_algebra1\/": {
        "title": "linear_algebra1",
        "tags": [],
        "content": "linear algebra에 대한 생각 인과 관계(causation)와 상관관계(correlation) 어떤 변수와 다른 어떤 변수와의 연관성이 있을때 relation이 있다고 한다. 예를 들어, x가 증가하면 y도 증가한다던지 혹은 x가 증가하면 y가 감소한다. x가 감소하면 y는 증가한다. 등등. 이런 관계를 영어로는 좀 더 명확하게 표현할 수 있는것 같다. 예를 들면, describe variables in terms of one another. 여튼 이런 관계는 수학적으로 표현할 수 있다. 인문학 분야에서도 이런 관계를 표현하는데, 좀 다르다. 인간관계, 상관관계와 같이 구분해서 표현하는데, 이것은 관계를 어떻게 해석하느냐의 문제다. 수학적으로는 어떤 변수의 값이 다른 변수의 값에 영향을 미치는 relation일 뿐이다.\nrelation과 수학적 표현 relation은 집합으로 표현할 수도 있고 1차방정식, 2차방정식, function으로도 relation으로 나타낼 수도 있다. 여튼 이렇게 수학적으로 나타낸 relation은 일종의 법칙과 같다. 예를 들어, 온도가 높아지면 아이스크림 판매량이 늘어난다.를 수학적으로 y = 3x +5처럼 나타낼 수 있다. 이렇게 수식으로 정의되면, 어떤 온도를 x에 집어넣으면 얼마만큼의 아이스크림이 판매될지 예측할 수 있다. 우리가 원하는건, 방정식을 만들고, data를 집어넣어서 예측을 하는 데 있다. 그럼 어떻게 방정식을 만들 수 있을까? data가 있다면 방정식을 만들 수가 있다.\n관계, 예측, data, 방정식 어떤 feature끼리의 관계가 있다면, 그 관계를 방정식으로 만들 수 있다면, 우리는 방정식을 통하여 어떤 data도 예측할 수 있다. 방정식을 만드는 방법은 data로 만든다.\ndata로 방정식 만들기 참조:https://pydata.tistory.com/29 intended: 온도가 올라갈때 마다 아이스크림 판매량을 예측하는 기계를 만들고 싶다. 매일 온도를 측정하고, 판매량을 기록했다. 이 data를 바탕으로 온도에 따라 아이스크림 판매량을 예측하는 기계를 만들고 싶다.\n온도 -4 -3 -2 -1 0 1 2 3 4 아이스크림 판매량 -6 -4 -2 0 2 4 6 8 10 보기 좋게 세로로 변경하자.\n온도 아이스크림 판매량 -4 -6 -3 -4 -2 -2 -1 0 0 2 1 4 2 6 3 8 4 10 이 data를 통해서 온도에 따른 아이스크림 판매량을 예측하는 기계를 만드는 가장 간단한 방법은 방정식을 만드는 것이다. 예를 들면 x를 온도, y를 판매량으로 하는 1차 방정식을 만드는 것이다. x와 y사이에 어떤 관계가 있다는 확신이 들기 때문이다. 그런데 반드시 1차 방정식이여야 하나? nonlinear한 2차방정식이나, 삼각함수나, 다른 방식을 사용할 수 없는가? 물론 있다. x와 y의 관계가 2차방정식의 모양을 가질 수도 있다.우선은 가장 간단한 1차방정식으로 이러한 기계를 만들 수 있는지 확인해 보자. 1차방정식은 모두 비슷한 모양이다. y = mx +b 라는 방정식의 모양이다. 여기서 우리가 방정식을 만들기 위해서는, m과 b를 구해야 한다. 그래야 y=mx+b라는 기계를 만들고, 임의의 온도를 x에 넣었을 때 판매량을 알 수 있기 때문이다.\nm = \\(\\frac{\\Delta y}{\\Delta x}\\), b =\u0026gt; what goes with x = 0\nm을 생각해보면, x가 1씩 증가할 때 y의 증가량이다. 직관적으로 봤을때 값은 2씩 증가하는 것을 볼 수 있다. 따라서 m은 2로 할 수 있다. y = 2x +b에서 b값을 찾아 보자. b는 x가 0으로 갈때, y값이다. 따라서 방정식은 y = 2x + 2가 된다. 그런데 실제 data를 가지고 1차방정식을 만족하는 m과 b를 구할 수 있을까? 거의 없다고 본다. data의 row가 많아질수록 이렇게 딱 떨어지는 기계는 만들 수 없다.\n이것에 대한 생각은 나중에 하고, 우리는 data를 통해서 방정식에 필요한 x의 계수 m과 y의 절편 b를 찾을 수 있음을 보였다. 물론 이렇게 딱 떨어지게 구하는 경우는 거의없다. 그런데, 다른 경우를 생각해 보자. 만일 판매량에 영향을 미치는 요소가 온도만 있는게 아니라, 습도, 해가 떠있는지 유무,등등\u0026hellip; 데이터의 x에 해당하던 온도뿐 아니라, A,B,C,D,\u0026hellip;X까지 24개의 종류가 있다면, 우리는 데이터로 부터 각각의 계수 24개를 구해야 한다. 어떻게 할 것인가? 또한 첫번째 예는 운이 좋아서 구했지만, row가 엄청많다면 더 힘들 것이다. 어떻게 구해야 할지 머리속에 떠오르지 않는다.\n이 때 필요한게 linear algebra다.\nlinear algebra를 설명하기 전에, 우리가 한것을 다시 overview해보자. 우리는 data로 방정식을 만들고, 만든 방정식에 임의의 온도를 넣었을때, 판매량을 예측할 수 있는 machine을 만드는 것이다. 이것을 비유하면, 마치 음식재료와 요리를 가지고 기계를 만들고, 그 기계에 음식재료를 넣는다면, 요리를 만들수 있다는 것과 비슷하다. 다시한번 말하면, X는 음식재료, Y를 음식이라고 하면, 그 정보를 가지고 음식만드는 기계를 만들고, 다른 재료를 넣더라도 비슷한 음식이 나오게 되는 것이다. 우리가 만드는 방정식은 기계다. linear machine이라고 할 수도 있다.\n결론은 우리가 원하는 기계는 여러가지 feature와 결과의 관계로 만들어진다. data로 부터 각각의 feature의 계수를 구하는데 있어 linear algebra를 사용할 수 있다는것만 알아두자.\n왜 linear Algebra인가? Non-linear algebra는 안되는가? 위의 예에서 보면, 2개의 변수를 갖는 경우나 3개의 변수를 갖는 경우나 모두 값이 실수값 하나다.그런데 값이 실수값이 아닌, 다른형태라면, 그것은 non-linear가 될수 있다고 본다.아래에 그것과 관련한 질문을 한적이 있다.\n왜 기계는 정해져 있는가? data가 주어지면, 우리는 기계를 만들고, 만든 기계로 예측을 한다고 했다. 그런데 주어진 data로 만드는 기계의 형태는 정해져 있다. linear machine이다. Y= AX + BY + CZ의 형태다. 여튼 우리는 지금 linear한 기계만 생각한다.\n[강의 시작-1] Scalar, Vector, and Matrix Scalar: 하나의 수를 나타낸다. s \\(\\in\\mathbb{R}^1\\) : 그 수를 s라 할때, 이와같이 표시할 수 있다. \\(\\mathbb{R}\\) 이 실수를 나타내는 집합이기 때문이다. vector: ordered list of number다. x = \\(\\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ \\vdots \\\\ x_n \\end{bmatrix} \\in \\mathbb{R}^n\\) , 여기서 vector는 n차원이다. \\(\\mathbb{R}^n\\) 은 실수를 나타내는 집합R이 n번 곱해진다는 얘기인가? n은 row의 개수를 말하는 거 같다. matrix: 2차원 array다. \\(A = \\begin{bmatrix} 1 \\ 6 \\\\ 3 \\ 4 \\\\ 5 \\ 2 \\end{bmatrix} \\in \\mathbb{R}^{3x2}\\) 3x2는 row의 개수와 column의 개수를 말하는 거 같다. matrix를 vector로 생각(column vector와 row vector) column: 원기둥 vector를 column vector라고도 부른다. 왜 column이란 이름이 붙였냐 하면, matrix를 볼때, matrix의 column이 vector모양이고, matrix는 column형태의 vector로 구성되었다고 생각했다. 모양을 보면, matrix는 column에 해당하는 vector로 분해될 수 있어 보인다. 그래서, matrix에서 vertical column을 column vector라고 불렀다. row vector란건 원래 없었다. vector는 column형태이기 때문이다. 그런데 column vector를 transpose연산을 하면 row vector matrix의 성분들을 vector로 나눌 수 있기 때문에,row vector란 말이 생겼다. vector를 matrix로 생각. matrix를 vector로 보면, column vector가 합쳐진것, 혹은 row vector가 합쳐진 것으로 볼 수도 있다. vector를 matrix로 볼수도 있다. \\(x = \\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\\\ \\vdots \\\\ x_{n} \\end{bmatrix} \\in \\mathbb{R}^n = \\mathbb{R}^{n x 1}\\) 위에 처럼 vector를 n개의 row와 1개의 column인 matrix로 표시할 수도 있다. 그럼 row vector도 마찬가지로 아래와 같이 표시할 수 있다. \\(x = \\begin{bmatrix} x_{1} \\ x_{2} \\ x_{3} \\end{bmatrix} \\in \\mathbb{R}^n = \\mathbb{R}^{1 x 3}\\) 즉 1개의 row와 3개의 column을 가진 matrix로 표시할 수 있다. Transpose 연산 row vector와 transpose 원래 row vector는 없었다. vector는 column의 모양을 하고 있었기 때문이다. 그런데, column형태의 vector를 row vector형태로 사용할 일은 많았다. 그래서 Transpose라는 연산을 통해서 row vector를 만들어 사용했다. 지금도 마찬가지다. vector는 transpose해서 row vector로 사용한다. 예를 들면 다음과 같다. \\(X = \\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\\\ \\vdots \\\\ x_{n} \\end{bmatrix}^T = \\begin{bmatrix} x_{1} \\ x_{2} \\ x_{3} \\ldots \\x_{n} \\end{bmatrix} \\in \\mathbb{R}^{1 x n}\\) n x 1의 column vector를 transpose해서 1 x n의 row vector를 만든 것이다. transpose와 matrix vector를 row vector로 만들기 위해서 transpose연산을 취했지만, matrix도 transpose연산을 취할 수 있다.\n아래를 보자.\nA = \\(\\begin{bmatrix} 1 \\ 6 \\\\ 3 \\ 4 \\\\ 5 \\ 2 \\\\ \\end{bmatrix} \\in \\mathbb{R}^{3 X 2}\\)\nA = \\(\\begin{bmatrix} 1 \\ 6 \\\\ 3 \\ 4 \\\\ 5 \\ 2 \\\\ \\end{bmatrix}^{T}\\) =\u0026gt; \\(\\begin{bmatrix} 1 \\ 3 \\ 5 \\\\ 6 \\ 4 \\ 2 \\end{bmatrix}\\)\nA matrix는 2개의 column vector로 보면 된다. 첫번 째 column vector가 첫번 째 row vector로 transpose되고, 두번 째 column vector가 두번째 row vector가 된다.\nMatrix notations Square Matrix row와 column이 같은 matrix를 square matrix라고 부른다. 특별한 기호로 나타내진 않는다.\ne.g., B = \\(\\begin{bmatrix} 1 \\ 6 \\\\ 3 \\ 4 \\end{bmatrix}\\)\nRectangular Matrix row와 column이 같지 않은 matrix를 Rectangular Matrix로 부른다. 이것도 특별한 기호를 사용하지 않는다.\ne.g., A = \\(\\begin{bmatrix} 1 \\ 6 \\\\ 3 \\ 4 \\\\ 5 \\ 2 \\end{bmatrix}\\)\nTranspose연산자 기호 Transpose는 matrix 상단에 T를 표시해서 나타낸다.\ne.g., \\(A^{T}\\) = \\(\\begin{bmatrix} 1 \\ 3 \\ 5 \\\\ 6 \\ 4 \\ 2 \\end{bmatrix}\\)\ncomponent의 표시 Matrix의 하나의 원소를 지칭하는 방법, index는 1부터 시작한다. e.g., \\(\\textbf{A}_{ij}\\) , \\(\\textbf{A}_{21}\\) = 3\nmatrix에서 column vector와 row vector표시 row vector\nmatrix에서 row vector는 row를 지정하고 column을 :로 표시한다. 그리고 둘 사이 ,가 삽입된다. e.g.,\\(\\textbf{A}_{i,:}\\) \\(\\textbf{A}_{2,:} = \\begin{bmatrix} 3 \\ 4 \\end{bmatrix}\\)\ncolumn vector\nmatrix에서 column vector는 column을 지정하고 row를 :로 표시한다.그리고 둘 사이 ,가 삽입된다. e.g.,\\(\\textbf{A}_{:,j}\\) \\(\\textbf{A}_{:,2} = \\begin{bmatrix} 6 \\\\ 4 \\\\ 2 \\end{bmatrix}\\)\nsummary scalar가 무엇인지? vector가 무엇인지? matrix가 무엇인지를 배웠다. 어떤 응용에 있어서 그런 용어가 가진 역할이라던가 본질에 대한 의미라기 보다는 생김새, 모양 구조를 배웠다. 예를 들면, 숫자로 된 data가 낱개로 있을때는 scala, 어떤 구조로 organize되어 있으면, vector, matrix 용어로 부른다는 것이다. 아직까진 별다른 얘긴 없다.\n[강의 시작-2] vector/Matrix 덧셈 곱셈 위에서도 말했듯이 우리는 data로 1차원기계를 만들것이다. 수많은 음식재료가 나오기 때문에, 즉, 음식재료가 많기 때문에, matrix나 vector로 만들지 않으면 안된다. 데이터가 vector, matrix형태로 organize되어 있을때, 그것들을 가지고 어떤 처리, 계산을 할수 있어야 한다. 정확하게는 1차원기계의 계수와 절편을 계산해야 하기때문에 Matrix/vector에 대한 계산 방식을 알아야 한다. 그리고 vector는 계산에 있어서 matrix로 취급한다.\n덧셈과 뻴셈 addition 덧셈은 같은모양의 matrix끼리만 할 수 있다.\nscala 곱 그냥 scalar값을 더하거나 뺀다. 더하거나 빼도 같은 모양이 된다.\n내적(inner product, dot product) 내적을 계산하면, 앞 매트릭스의 column과 뒷 매트릭스의 row가 같아서 소멸되고, 앞의 매트릭스의 row와 뒤의 column으로 size가 정해진 매트리스가 새로 만들어진다. 예를 들어서, 100x30과 30x500의 matrix는 100 x 500의 matrix를 만들어 낸다. 내적은 matrix와 matrix를 곱해서 새로운 matrix를 만들어낸다는 것이다. 덧셈이나 scala곱은 기존의 matrix 크기를 변화시키지 않는다. 하지만, 내적은 다르다. 내적은 두개의 matrix를 기반으로 새로운 모양의 matrix로 만든다. 새로운 모양의 matrix가 기존의 matrix보다 클수도 작을수도 있다. 이럴땐 내적을 해야해!라던가 내적이 어떨땐 내적을 사용해! 뭐 이런건 나오지 않았다.\n내적은 not commutative. commutative라는 말은 교환법칙이다. AB \\(\\not=\\) BA. 강사는 3가지의 경우를 모두 예를 들어서 설명한다.\nAB는 계산이 되지만, BA가 계산이 안되는 경우 \\(A \\in \\mathbb{R}^{2X3}\\) 고 \\(B \\in \\mathbb{R}^{3X5}\\) 이면, \\(AB \\in \\mathbb{R}^{2X5}\\) 이지만, $BA$는 만들 수 없다.\nAB와 BA계산이 되지만, size가 안맞는경우 \\(A \\in \\mathbb{R}^{2X3}\\) 고 \\(B \\in \\mathbb{R}^{3X2}\\) 이면, \\(AB \\in \\mathbb{R}^{2X2}\\) 이지만, \\(BA \\in \\mathbb{R}^{3X3}\\) , 따라서, \\(AB \\neq BA\\).\nAB와 BA계산도 되고 size도 맞지만 계산이 다른 경우\neg., \\(\\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 4 \\end{bmatrix}\\) \\(\\begin{bmatrix} 5 \\ 6 \\\\ 7 \\ 8 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 19 \\ 22 \\\\ 43 \\ 50 \\end{bmatrix}\\)\n\\(\\begin{bmatrix} 5 \\ 6 \\\\ 7 \\ 8 \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 4 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 23 \\ 34 \\\\ 31 \\ 46 \\end{bmatrix}\\)\n값이 다른것을 알 수 있다.\nother properties Distributive A(B+C) = AB + AC :commutative같은 경우 성립이 안되는 경우를 모두 보여주었다. 분배 법칙의 경우도 조건이 있는거 아닌가? A의 column과 B row 가 같아야 하고, A의 column과 C의 row가 같아야 만 저 식이 성립되는거 아닌가? 어째든 성립이 된다고 가정하면, 결과는 어떻게 될까? 성립이 되면,AB라는 매트릭스와 AC라는 매트릭스가 만들어지고 두 매트릭스가 size도 같다면, 하나의 매트릭스가 결과값으로 나올 것이다. 그러나 반드시 하나의 매트리스가 된다는 보장은 없다. AB + AC인 상태가 될 수있다.\nAssociative A(BC) = (AB)C Associative도 A의 column과 B의 row가 같으면 위 계산이 가능하다. 결합법칙은 괄호의 연산이 가능하다면 순차적으로 풀면된다. 내적으로 연결된 계산을 할땐 어떤순서로 해도 상관없다는 뜻이다.\nProperty of Transpose \\((AB)^{T} = B^{T}A^{T}\\) 내적의 transpose를 transpose의 내적으로 바꿀수도 있고, transpose로 된 matrix의 내적을 묶은후 transpose할 수 있다. transpose는 size의 경우 뒤바뀜이 일어나고 1st row가 1st column으로 이동한다.\n[강의시작 2-1] Linear System Linear System: 연립방정식과 그에 따른 연산을 포함한다. Linear system에선 여러개의 Linear Equation을 Matrix를 사용해서 풀수 있다.\nLinear Equation 이전에 말했듯이 우리가 Linear Algebra를 사용하는 이유는 요리재료와 음식이 주어질때, 이 정보를 가지고 Linear Equation이란 기계를 만든다고 했다. Linear Equation 기계의 형태는 대략적으로 정해져 있다. 왜냐면 Linear Algebra를 사용하기 때문이다. 우리는 위에서 음식재료가 하나일때는, 하나의 음식재료 가지고 y = ax +b라는 형태의 기계를 만든다고 했다. 그 기계를 만든다는 것은 a와 b를 구하는 것이라고 했다. 아래 표에서 보듯이 음식재료 X가 Y라는 음식이 주어지면 방정식의 계수와 절편을 푸는것이다.\nX -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 그리고 여러종류의 음식재료가 있을때는, 예를 들어 2개의 음식 재료 W,X가 있고, 만들려는 음식이 Y 일 때는,\nW -2 -1 -5 -1 0 5 3 7 1 X -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 Y = aW + k1꼴의 방정식과 Y = bX + k2이란 방정식을 둘다 만족시키는 계수(a,b)와 절편(k1,k2)을 찾아야 한다.\n음식재료가 3개일때도 보자.\nV -2 -1 -5 -1 0 5 3 7 1 W -2 -1 -5 -1 0 5 3 7 1 X -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 Y = aV k1 라는 꼴의 기계, Y= bW +k2라는 기계, Y= cX +k3라는 기계를 모두 만족시키는 하나의 기계를 만들어야 한다. 최종기계는 어쩌면, Y = aV + k1 = b k2, Y = aV +bW + cX + k꼴의 기계의 a,b,c 그리고 k 절편을 구하는것일 지도 모른다.\nlinear algebra의 적용(linear system과 linear equation) linear system: set of linear equations,연립방정식을 뜻한다. 우리는 이 linear system을 풀면된다. 즉 여러개의 linear equation이 모인 linear system을 matrix, vector형태로 표시하고 이를 계산해서 각각의 linear equation의 계수와 절편을 구한다. 그러면 우리가 표를 사용해서 계수와 절편을 구하려고 equation을 만들었는데, 변수와 계수를 변경한다. 왜냐면 우리가 원하는건 계수였기 때문에 계수가 변수가 된다. 그리고 우리는 matrix형태로 data(table)을 표현할 수 있어야 한다. 그리고 절편은 없다고 생각하자. 식을 간단하게 하기 위해서이다. 우리에게 주어지는 것은 음식재료와 음식을 가지고 기계를 linear algebra 기계의 계수를 구해보자. 예를 들어 보자. 이건 강사의 예제다. 강사는 4가지 정보(data)를 바탕으로 얼마나 오래사는지를 예측하고 싶어한다. 우리는 linear machine을 만들어야 한다. 아래는 data다. 이것으로 linear machine을 만들어 보자.\nPerson_ID 1 2 3 Weight 60kg 65kg 55kg Height 5.5ft 5.0ft 6.0ft Is_smoking yes(=1) No(=0) Yes(=1) life-span 66 74 78 위 data를 가지고 linear machine(값을 예측하는 기계)을 만드는데는 process가 필요하다.\n위 data를 linear system으로 구성한다. linear system을 풀면 linear machine의 계수를 알수 있다. 계수만 알면 linear machine이 만들어 지는 것이다. linear system을 만들자. linear system은 linear equation으로 구성된다.linear equation으로 만들기 위해서 표를 transpose하자. transpose하면 matrix로 표현하기 쉽다.\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 3 55kg 6.0ft Yes(=1) 78 \\(60x_{1} + 5.5x_{2} + 1x_{3} = 66\\) \\(65x_{1} + 5.0x_{2} + 0x_{3} = 74\\) \\(55x_{1} + 6.0x_{2} + 1x_{3} = 78\\)\n이렇게 linear combination을 통해 linear system을 만들었다. 이제 matrix/vector형태로 만든다.\n\\(\\begin{bmatrix} 60 \\ 5.5 \\ 1 \\\\ 65 \\ 5.0 \\ 0 \\\\ 55 \\ 6.0 \\ 1\\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\end{bmatrix}\\) = \\(\\begin{bmatrix} 66 \\\\ 74 \\\\ 78 \\end{bmatrix}\\) 이렇게 보면 Ax = b의 형태다.\nmatrix는 대문자, vector는 소문자로 표시한다. 여기서 좀 tweak(조금 고치다;튜닝)을 하면, 아래와 같이 볼 수도 있다.\n\\(a^{T}_{1}x = 66\\) \\(a^{T}_{2}x = 74\\) \\(a^{T}_{3}x = 78\\)\n이제 여기까지하면 data를 가지고 linear system을 만들었다고 볼 수 있다.\nlinear system 풀기 prerequisite for solving linear system\nlinear system을 푼다는 것은 계수인 x vector를 구하는 것이다. 그런데 풀기위해선 행렬 계산법에 대해 몇가지 개념들을 알아야 한다. 그중 Identity matrix를 먼저 살펴보자.\nIdentity Matrix\n항등 행렬로 부른다. 항상 등식이 성립하는 matrix다. diagonal entry들이 모두 1인 square matrix다. I라고 표시하고 다음과 같이 size를 표시한다.\n\\(I_{n} \\in \\mathbb{R}^{n X n}\\)\ne.g., \\(I_{3}\\) = \\(\\begin{bmatrix} 1 \\ 0 \\ 0 \\\\ 0 \\ 1 \\ 0 \\\\ 0 \\ 0 \\ 1 \\end{bmatrix}\\)\n이 matrix의 특징은 이 matrix에 곱해지는 matrix의 결과는 자기자신이라는 것이다. 예를 들어보자.\ne.g., \\(\\begin{bmatrix} 1 \\ 0 \\ 0 \\\\ 0 \\ 1 \\ 0 \\\\ 0 \\ 0 \\ 1 \\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\end{bmatrix}\\) = \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\end{bmatrix}\\)\n3x3과 3x1로 3x1의 vector가 계산되지만, 그 vector가 자기자신임을 알 수 있다. vector도 matrix의 일종이다.\nInverse Matrix\nIdentity matrix를 통해서 Inverse Matrix의 개념이 생겼다고 한다. Inverse Matrix도 Identity matrix처럼 squared matrix다. 어떤 matrix가 있을 때, 그 matrix의 inverse matrix를 내적하면 자기 자신이 된다.\ninverse matrix\nsquare matrix \\(A \\in \\mathbb{R}^{n X n}\\) \\(A^{-1}A\\) = \\(AA^{-1}\\) = \\(I_{n}\\) 특이한 것은 \\(A^{-1}\\) 를 구할때, A와 I를 알고 있기 때문에, A와 I를 적당히 처리해서 구할 수 있을거라고 생각하지만, 구할 수 없다. 예를 들어 \\(AA^{-1}\\) = \\(I_{n}\\) 이니까, 양변에 \\(A^{-1}\\) 을 내적해서 구할수 있지 않을까 하고 생각하는데, 구할 수 없다. inverse matrix는 구하는 공식이 있다.\ne.g., \\(A\\) = \\(\\begin{bmatrix} a \\ b \\\\ c \\ d \\end{bmatrix}\\) 라 하자.\n\\(A^{-1}\\) = \\(\\frac{1}{ad - bc}\\) \\(\\begin{bmatrix} d \\ -b \\\\ -c \\ a \\end{bmatrix}\\)\ne.g., \\(A\\) = \\(\\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 4 \\end{bmatrix}\\) 라 하자. \\(A^{-1}\\) = \\(\\frac{1}{4 - 6}\\) \\(\\begin{bmatrix} 4 \\ -2 \\\\ -3 \\ 1 \\end{bmatrix}\\) = \\(\\begin{bmatrix} -2 \\ 1 \\\\ \\frac{3}{2} \\ - \\frac{1}{2} \\end{bmatrix}\\)\n즉, A에서 ad-bc를 계산한 후, diagonal의 component들을 바꿔주고 나머지는 -값을 해준다.\n여기서 한가지 특이한건, matrix는 transitive하지 않다고 했다. 즉 교환법칙이 성립하지 않는다. AB와 BA는 같지 않았다. 하지만, A와 A의 역행렬은 교환법칙이 성립하는 것을 볼 수 있다.\nSolving linear system\n이제 linear system을 풀기 위한 준비가 되었다. data를 가지고 우리는 linear system을 만들었다. 그 구조는 다음과 같았다.\n\\(Ax = b\\)\n\\(\\begin{bmatrix} 60 \\ 5.5 \\ 1 \\\\ 65 \\ 5.0 \\ 0 \\\\ 55 \\ 6.0 \\ 1\\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ x_{3} \\end{bmatrix}\\) = \\(\\begin{bmatrix} 66 \\\\ 74 \\\\ 78 \\end{bmatrix}\\)\n\\(Ax = b\\) 에서 계산을 위한 matrix인 Identity와 Inverse matrix를 사용해서 푼다. 풀이 과정은 다음과 같다.\n\\(Ax = b\\) \\(A^{-1}Ax = A^{-1}b\\) \\(I_{n}x = A^{-1}b\\) \\(x = A^{-1}b\\)\n이제 적용해 보자. 우리의 linear system에서 \\(A^{-1}\\) 을 구해보자.\n\\(A^{-1}\\) = \\(\\begin{bmatrix} 0.0870 \\ 0.0087 \\ -0.0870 \\\\ -1.1304 \\ 0.0870 \\ 1.1314 \\\\ 2.0000 \\ -1.0000 \\ - 1.0000 \\end{bmatrix}\\)\n이제 \\(x = A^{-1}b\\) 을 계산하면 된다.\n\\(x = A^{-1}b\\) = \\(\\begin{bmatrix} 0.0870 \\ 0.0087 \\ -0.0870 \\\\ -1.1304 \\ 0.0870 \\ 1.1314 \\\\ 2.0000 \\ -1.0000 \\ - 1.0000 \\end{bmatrix}\\) \\(\\begin{bmatrix} 66 \\\\ 74 \\\\ 78 \\end{bmatrix}\\) = \\(\\begin{bmatrix} -0.4 \\\\ 20 \\\\ -20 \\end{bmatrix}\\)\n이렇게 하면 linear system을 풀었다.\nlinear machine\n우리는 linear system을 계산해서 linear machine의 계수를 구했다. 이제 linear machine을 완성시키자.\nlinear machine coefficients = \\(\\begin{bmatrix} -0.4 \\\\ 20 \\\\ -20 \\end{bmatrix}\\)\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 3 55kg 6.0ft Yes(=1) 78 (life-span) = -0.4 x (Weight) + 20 x (Height) -20 x (Is_smoking)\nlinear system의 한계? rectangular matrix의 inverse matrix\nlinear system을 풀기 위해서, 우리는 Identity Matrix와 Inverse matrix를 배웠고 또 활용했다. 그런데 Identity matrix와 Inverse Matrix는 모두 square matrix다. Rectangular matrix는 역행렬이 존재하지 않는다. 그래서 위의 계산방식으로 사용할 수 없다. 그러면 linear system을 풀수 없다는 얘기인가? 그렇지 않다. 그것에 대한 얘기를 할것이다. 물론 programming상에선 알아서 구해주기 때문에 걱정하지 않아도 된다.\nNon-Invertable Matrix A for Ax = b 위에서 data를 가지고 linear machine을 만들었다. linear machine을 만드는 과정에서 역행렬을 사용했다. 그런데 역행렬을 만들 수 없는 경우가 있다. 이전에도 말했듯이 rectangular matrix도 역행렬을 만들 수 없다. 그런데 square matrix도 역행렬을 만들 수 없는 경우가 존재한다. 예를 들어보자.\neg., \\(A = \\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 6 \\end{bmatrix}\\)\n위 matrix는 square matrix이다. 그러나 ad-bc가 0이다. 따라서 역행렬이 존재하지 않는다. ad -bc를 계산하지 않아도, 위 matrix의 column vector는 한개 feature의 data다. 즉 2개 feature data라고 볼 수 있는데, 이 2개의 data가 같은 data로 볼 수 있다. 첫번 째 column에 2를 곱하면, 두번 째 column과 같아진다. 이런경우 역행렬을 구할 수 없다고 볼 수 있다.\n어떤 matrix가 주어졌을때, 역행렬이 존재하는지 안 하는지를 판별하는게 ad -bc가 0인지를 계산했는데, 이것을 A의 determinant라고 한다. 보통은 다음과 같이 표시한다.\n\\(det A\\)\n그러면, 3X3 matrix에서 determinant를 구할 수 있을까? 구할 수 있다. 4X4\u0026hellip;등등.. 강사는 그림으로 알켜줬지만, 난 여기에 적진 않겠다.\n역행렬 존재의 의미. linear system에서 data행렬이 3x3의 square행렬이고, 역행렬이 존재해서 linear machine의 계수를 구할 수 있었다. 그런데, 우리가 받는 data가 3개의 feature를 갖고, 3개의 값만 있지 않다. 정방행렬 형태의 data는 일부러 만든것이고, 실제는 rectangular data일 확률이 더 높다. 또한 정방행렬의 data가 주어진다고 해도 판별식이 0인경우가 많다. 판별식이 0이면 역행렬이 존재하지 않기 때문에 위의 방식으로 해를 구할 수가 없다. inverse matrix로 해를 구할수 없다고 해서, 해가 없다라고 말한다면, 그것은 맞는 것일까? 그렇지 않다. 정방행렬에서 판별식이 0인 경우는 해가 없을수도 있지만,해가 무수히 많을 수도 있기 때문이다. 아래 예를 보자.\neg., \\(\\begin{bmatrix} 1 \\ 2 \\\\ 3 \\ 6 \\end{bmatrix}\\) \\(\\begin{bmatrix} x_{1} \\\\ x_{2} \\end{bmatrix}\\) = \\(\\begin{bmatrix} 4 \\\\ 12 \\end{bmatrix}\\)\n위 matrix는 판별식(determinant)가 존재하지 않는다. ad-bc가 0이다. 따라서 inverse matrix가 존재하지 않는다.그러면 이 linear system의 해는 없는것인가? 아니면 해가 무수히 많은 것인가? 위 matrix 곱을 풀어서 보자.\n\\(x_{1} + 2x_{2} = 4\\) \\(3x_{1} + 6x_{2} = 12\\)\n두 equation들은 동일하다. 왜냐면 3을 윗방정식에 곱했을 때 같은 동일한 직선이기 때문이다. 우리가 해라고 말하는건 위에서 풀어쓴 두 직선의 교점을 얘기한다. 두직선의 교점은 무수히 많다. 따라서 matrix곱의 해는 무수히 많다. 즉 해는 무수히 많다.\n그럼, 해가 없는 경우를 살펴보자. 위 방정식을 그대로 이용하자.\n\\(x_{1} + 2x_{2} = 4\\) \\(3x_{1} + 6x_{2} = 13\\)\n이 경우도 판별식은 0이다. 따라서 역행렬로 해를 구할수는 없다. 따라서 matrix곱을 풀어써보자. 두개를 직선으로 본다면 동일한 직선이 아니다. 따라서 해가 무수히 많지도 않다. 판별식이 0이 아니고 역행렬이 있다면, unique한 해를 가질텐데 그렇지도 못하기 때문에, 따라서 이 경우는 해가 존재하지 않는다.\n강사는 2개의 video를 참조영상으로 제공했다. mit 선형대수 강좌 18,19다. 여기1 여기2 이게 무슨 의미인가? data를 사용해서 기계를 만들려고 할려면 matrix곱을 풀어야 한다. 그런데, matrix곱형태의 계산은 어렵다는 것이다. matrix곱 해결방법으로 흔히 쓰이는 inverse matrix로 양변에 곱해서 해결할려는 시도는 한계가 있다는 것이다. 첫번째 한계는 sqaure matrix만 역행렬이 존재한다는 점이다. 두번째 한계는 sqaure matrix라고 해도, 판별식이 0이 되는 경우, 역행렬을 양변에 곱해서 해를 구하는 계산은 할수 없다는 점이다. 세번째로, matrix의 크기가 커지면, 판별식 자체 계산이 힘들다는 것이다. 설사, 위의 세가지 경우를 벗어나, square matrix이고, 역행렬이 존재하고, 그리고 계산이 가능하다 할지라도, 해가 1개만 unique하는 경우만 답을 구할 뿐이다. 우리는 해가 한개인,unique한 해를가지고, 기계를 만들 수도 있지만, 해가 여러개 되는 경우에도 기계를 만들어야 하고, 혹은 해가 없는 경우에도 기계를 만들어야 한다. 따라서 우리는 square matrix에 구애 받지 않는 rectangular matrix곱의 해를 구하는 방법과, 해가 없는경우, 해가 무수히 많은 경우의 처리를 생각해야 한다.\nRectangular matrix의 계산 data를 제공 받아서,우리는 linear machine을 만든다고 했다. 그러기 위해선 linear machine의 coefficients가 필요했다. 이것이 matrix곱에서의 x벡터(가중치 벡터)를 의미한다. x벡터를 data로 부터 구했을때, 새로운 data의 예측이 가능했다. 그런데 matrix곱형태의 해를 구하는 계산이 역행렬을 곱하는 식으로는 안된다는 점과, 해가 없을때, 해가 무수히많을때를 해결해야 한다.\n우선 해를 따져보자. Rectangular한 data가 주어질때, rectangular matrix가 가진 모양의 특징이 있다. 모양에서 해의 개수를 예측가능하다는 것이다. m: 방정식수(data수) n:feature라고 했을때, 다음과 같이 일반적으로 예측할 수 있다.\nm \u0026lt; n : 보통은 해가 무수히 많다.\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 일반적인 얘기다. 100% 이렇다라고 말할 수는 없다. 여튼 이런 경우를 under-determined system이라고 부른다고 한다.\nm \u0026gt; n : 보통은 해가 없다.\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 3 55kg 6.2ft Yes(=1) 78 4 55kg 6.4ft Yes(=0) 78 5 55kg 6.0ft Yes(=1) 78 6 55kg 5.8ft Yes(=1) 78 이 경우도 일반적인 얘기다. 보통 해가 없는경우가 많고, over-determined system이라고 부른다.\noh my god! 나는 Rectangular matrix도 역행렬을 구하는 다른 방식이 있을 줄 알았다. 그런데 그 설명은 아직 없다. 해를 구하는 계산을 설명하기에 앞서서, 해가 1개인지, 해가 무수히 많은지 아니면 존재하지 않는지에 대해서 먼저 고민해야 한다.\n해가 unique하다는 것은 기계를 1대 만들수 있고, 그 기계로 예측을 할수 있기 때문에, 제일 좋은 케이스다. 그런데 해가 없다는 것은 data를 가지고 machine을 만들지 못한다는 얘기가 된다. 두번째 해가 무수히 많다는 얘기는 우리가 구할려는 x벡터가 어떤값을 가져도 상관없다는 얘기가 된다. x벡터(가중치벡터)가 1000개 2000개 존재할 수 있다는 얘기도 된다. 1000개 2000개 무한하게 많은 기계를 만들수 있다는거다. 그런데, 주어진 data에 대한 각각의 기계의 값은 동일하나, 새로운 data에 대한 각 기계마다 예측값이 다 다를 것이다. 이게 문제다. 그러면, 해가 없는 경우, 해가 많은 경우는 어떻게 해야 하나? 해가 없는경우, 기계를 만들 수 있는가? 어떻게 기계를 만들것인가? 해가 많은 경우, 어떤 기계를 선택할 것인가? 하는 문제가 있다.\nmachine learning과 deep learning은 이런 문제를 해결하기 위한 solution을 준다.\n해가 없는 경우를 보자. 예를들어 1000개의 equation을 모두 만족하는 해가 없다고 할때, 근사화된 해를 선정한다. 근사화된 해라는 것은 예를 들어, 어떤 계수들을 가질때, 결과오차율의 합이 제일 작다면, 그것을 해로 정한다.\n해가 무수히 많은 경우는 regularization이란 기법을 사용한다. regularization은 보통 risk management라고 부른다. 많은 해 중에서, 가장 risk가 적은 해를 선택하겠다는 것이다. 예를 들면, 아래의 표를 통해서 우리는 여러개의 해를 구했다고 치자.\nPerson_ID Weight Height Is_smoking life-span 1 60kg 5.5ft yes(=1) 66 2 65kg 5.0ft No(=0) 74 해는 가중치라고 했다. weight, height, is_smoking에 대한 가중치 벡터가 해가된다. 이 해가 여러개 있다고 치자. 어떤해는 height에 150, 다른 어떤해는 20이라는 값을 갖는다면, 150의 가중치를 갖는다는것은 결과에 지대한 영향을 준다. 혹은 키에 민감한 반응을 보여주는 machine이라고 말할 수 있다. 우리는 해가 여러개 있는 경우, 하나를 선택하는 것이다. 이것에 대한 선택은 어떤 법칙은 없다. 다만 민감도(risk)를 따져서 선택할 뿐이다.\n내가 질문한 내용. 오피스아워에서 질문했던건데요. 해결되었습니다. 제가 말도 잘못하고, 잘 모르다보니 이상한 말을 많이 하게 되네요. 여튼 문제는 해결됐습니다.아래는 제가 생각했던,질문가졌던 내용과 배경을 말해봤습니다.\n[질문배경] 저는 우리가 하는게 수치data로 방정식과 같은 수학적 formula를 만들고, 만든 방정식에 수치data를 입력해서 값을 예측하는 모델을 만든다고 생각했습니다. 마치 음식재료와 요리를 넣어서 음식만드는 기계를 만든다고요. 그래서 간단한 표(data)에서 방정식을 만들어봤습니다. 1차방정식을 아래표에서 계산 하면, 기울기는 x의 증가량과 y의 증가량을 구해서 2를 구했고, y절편은 x가 0일때니까 2를 구했습니다. 그래서 y = 2x +2로 방정식을 만들었는데요.\nX -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 만일 음식재료가 많을 경우(아래와 같은표)는 위의방식대로 만들기 어렵다. 그래서 linear algebra를 사용한다고 생각했습니다.\nW -2 -1 -5 -1 0 5 3 7 1 X -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 그런데 여기서 생각한게 음식재료가 많아봤자(A, B, C \u0026hellip;W,X) 결국에는 Aa+Bb+Cc…와 같은 linear한 방정식만 만드는것 같아요. 여기서 non-linear한 방정식을 만드는 것은 없을까? 하다가 그러면 위에처럼 1차방정식을 data로 유도하듯이 2차방정식을 어떻게 유도하는지를 알고 싶었어요. 그런데 찾아보니 https://sciencing.com/quadratic-equations-table-10001169.html 이 방식이 있더라구요. 여기선 data가 ordered pair형식으로 되어 있더라구요. 그래서 table에 있는 data가 아래와 같은 형태로 되어 있다면 non linear하다고 생각했습니다.\nX (-4,2) ( -3,4) (-2,1) (5,-1) (0,2) (1,2) (2,3) (3,3) (4,4) Y -6 -4 -2 0 2 4 6 8 10 그런데 결론적으로 제가 잘못생각했습니다. 여기서 tuple의 모양은 의미가 없고, tuple을 vector로 생각해서 vector를 넣는 tensor로 non-linear처리가 가능하다는 강사선생님이 말씀하셨는데, 즉 저기의 tuple모양은 vector로 봐도 된다고 하신것과 다름없다고 생각됩니다. 그리고 한동훈님이 말씀하신 것도 일맥상통한거 같습니다. 즉 저기의 tuple모양이던 list모양이던 vector로 치환될 수 있다. 따라서 굳이 tuple같이 따질 필요가 없다. 이말이 맞는거 같습니다.\n여기서 또 질문 어떤 data가 있고, 그 data를 사용해서 방정식을 만들고, 만든 방식으로 예측한다. 그런데 왜 1차방정식만을 생각할까? 음식재료가 있고, 요리가 있을때, 서로간의 관계를 왜 1차 방정식기계만으로 한정하냐는 말이다. 다른 기계는 없을까? 2차방정식도 그중에 하나고, 다른형태의 기계도 만들 수 있는거 아닌가?\nX -4 -3 -2 -1 0 1 2 3 4 Y -6 -4 -2 0 2 4 6 8 10 여기서 또 질문 우리가 해야하는건 data가 주어지면, data로부터 기계를 만드는 것이다. 기계는 1차방정식의 형태다. 1차방정식은 여러 형태가 있지만, 음식재료가 A와 같다면, 우리는 y= Av+Bw+CX+D의 기계를 만들어야 한다. 그러면 어떻게 linear algebra를 사용해서 이런 기계를 만들 수 있을까? 그리고 data가 주어질때, A가 아닌 B의 형태로 주어졌을때, 동일한 data이지만 모양만 transpose한것이라면, 만들어지는 기계는 동일한 것인가? 라는 질문을 던질 수도 있다.\nV(음식재료) -2 -1 -5 -1 0 5 3 7 1 W(음식재료) -2 -1 -5 -1 0 5 3 7 1 X(음식재료) -4 -3 -2 -1 0 1 2 3 4 Y(음식) -6 -4 -2 0 2 4 6 8 10 W(음식재료) X(음식재료) Y(음식) -2 -4 -6 -1 -3 -4 -5 -2 -2 -1 -1 0 0 0 2 5 1 4 3 2 6 7 3 8 1 4 10 ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/linear_algebra1\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/elisp_korean_lorel_ipsum\/": {
        "title": "[elisp] korean lorem ipsum",
        "tags": [],
        "content": "introduction 코딩할 때, dummy 문자열을 사용할 일이 많다. 그런데 보통 lorem ipsum으로 영어 문장을 사용한다. emacs자체가 한국어 사용자가 없다보니 한국어 관련한 작업은 모두 만들어 써야 한다. 아주 간단한 korean lorem ipsum을 만들려고 한다.\nidea 한국어만 나오면 된다. 단어들을 그냥 random하게 섞어서 마지막에만 \u0026ldquo;입니다\u0026quot;로 끝나게 한다. M-x korean-lorem-ipsum-input-sentence로 실행할 수 있게 해야 한다.\nTODO 더 생각해야 하는것 lorem-ipsum처럼 sentence, paragraph, list를 만들어야한다. 그리고 진짜 그럴듯한 한국어문장을 만들려면 형태소 분석과 자연어 처리가 필요하다. 그리고 GAN을 사용해서 만들어내는것까지 할 수 있을 거 같다. 여기까지 갈려면 많은 공부를 해야한다. 중간단계로 고려할 것은 크롤링해서 문장을 가져오는것도 고려할 만 하다.\n구현 난 TDD를 알긴 알지만, 현업에서 써본적은 없다. 그리고 평소에 쓰지도 않는다. 하지만, 가장 간단한 함수부터 구현한다는 생각에는 동의한다. bottom-up 방식이 합리적이다.\nM-x 동작 test nM-x korean-lorem-ipsum-input-sentence을 실행시키면 hello가 나오는 함수를 만들자.\n(defun korean-lorem-ipsum-input-sentence () \u0026#34;print hello in calling this function made by holy\u0026#34; (interactive) (insert \u0026#34;hello\u0026#34;)) (interactive)는 이 함수를 M-x로 실행할 수 있게 한다. 그리고 insert함수는 현재 buffer 현재 위치에 실행할 수 있게 해준다.\n\u0026ldquo;hello\u0026rdquo; 대신에 random한 단어를 출력하자. 변수가 필요하다. word_bank라는 list를 만들자. 그리고 word list에서 random하게 단어뽑는거 까지 해보자.\n(defun korean-lorem-ipsum-input-sentence () \u0026#34;print hello in calling this function made by holy\u0026#34; (interactive) (let* ( (word_bank \u0026#39;(\u0026#34;박호열\u0026#34; \u0026#34;이\u0026#34; \u0026#34;사랑\u0026#34; \u0026#34;아무도\u0026#34; \u0026#34;돈\u0026#34; \u0026#34;명예\u0026#34; \u0026#34;명성\u0026#34; \u0026#34;사회적 지위\u0026#34;)) (my-sentence \u0026#34;\u0026#34;) ) (setq my-sentence (nth (random (length word_bank)) word_bank)) (insert my-sentence))) random함수는 다음과 같다.\nrandom 숫자 그러면 random한 값이 나온다. wordbank에서 그 값에 해당하는 cell을 꺼내기 위해서 nth를 사용했다.\ndotimes와 concat을 사용해서 문장 만들기 설명 단어를 concat해서 문장을 만들려면 dotimes를 써야 한다. dotimes는 for-loop로 생각하면 된다. concat과 dotimes를 사용하는 법은 다음과 같다.\ndotimes\n(dotimes (i 3) (sth)) 두개의 인자가 있는데, 비유에서 설명하겠다. python에서 for i in range(3)의 i와 range(3)과 두번째 인자가 같다고 보면 된다. _ 사용도 가능하다. (dotimes _ 3)을 사용해도 된다. 그러면 index를 사용하지 않겠다는 뜻이다. dotimes할때마다 concat으로 단어를 합쳐서 문장을 만들것이다.\nconcat:\n(concat str1 str2) concat은 이런 식으로 사용한다.\nconcat은 문자열을 합친다. 10번 반복될때마다 my-sentence변수가 계속 새로 선택된 word와 concat하면서 덧붙여지게 하려면 다음과 같이 한다.\n(setq my-sentence (concat my-sentence new-word) 구현 위에서 설명한것을 바탕으로 구현해 보자.\n(defun korean-lorem-ipsum-input-sentence () \u0026#34;print hello in calling this function made by holy\u0026#34; (interactive) (let* ( (word_bank \u0026#39;(\u0026#34;박호열이\u0026#34; \u0026#34;이상한\u0026#34; \u0026#34;사랑이라면\u0026#34; \u0026#34;아무도\u0026#34; \u0026#34;돈\u0026#34; \u0026#34;명예\u0026#34; \u0026#34;중요한\u0026#34; \u0026#34;사회적 지위\u0026#34;)) (sentence-length (+ 1 (random 10))) (my-sentence \u0026#34; \u0026#34;) ) (dotimes (_ sentence-length) (setq my-sentence (concat my-sentence (nth (random (length word_bank)) word_bank) \u0026#34; \u0026#34;))) (setq my-sentence (concat my-sentence \u0026#34;입니다\u0026#34;)) (insert my-sentence))) 위에서 sentence-length를 (+1 (random 10))으로 한건 최소한 1개 단어이상이여야 한다는 것이다. 마음대로 바꿀 수 있다. 최소 3개의 단어로 이루어진 문장이라면 3으로 바꾸면 된다. 그리고 concat에서 \u0026quot; \u0026quot; 를 추가했다. concat은 다음과 같이 쓰일수 있다.\n(concat str1 str2 str3) 마지막엔 \u0026ldquo;입니다\u0026quot;를 추가했다.\nmelpa에 등록하자. melpa는 repo다. python에서 pip나 ruby의 gem, node의 npm들이 repo에서 package를 가져오듯이 자시만의 repo가있다. program을 만들면 그런 저장소에 저장할 수 있다. 등록 이름은 simplis absurdi korean textus: simple meaningless korean text으로 하기로 했다.\n[step1] melpa를 fork하자.\nfork에 대한 참조는 여기 를 참조하자. 오래된 git문서이긴 하지만 git에 대한 내용이 있다.\n[step2] local computer에 clone한다. [step3] recipes폴더로 이동한다. [step4] package에 대한 recipe파일을 만든다. [step5] recipe파일을 commit push [step6] pull request\ngithub의 repo에 있는 pull requests 탭으로 이동한다. new pull request를 선택해서 main브랜치에 pull request한다.\n[step7] melpa관리자 승인 받을때까지 기다려야 함. ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/elisp_korean_lorel_ipsum\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/python_grammar_in_one_shot_standard_library_text\/": {
        "title": "[python] grammar in one shot - standard library (Text)",
        "tags": [],
        "content": "String import sys print(sys.version_info) sys.version_info(major=2, minor=7, micro=16, releaselevel=\u0026#39;final\u0026#39;, serial=0) textwrap regular expression difflib ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/python_grammar_in_one_shot_standard_library_text\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/website_making_portfolio_page\/": {
        "title": "[website] making portfolio page",
        "tags": [],
        "content": "portfolio page만들기 ", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/website_making_portfolio_page\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/example\/": {
        "title": "Example of org to ipynb",
        "tags": [],
        "content": "Introduction I wrote this module to allow me to write lecture notes in org-mode, but export them to ipython notebooks for my students. It also makes it easier to share my work with people who don\u0026rsquo;t use org-mode (although it is a one-way conversion of org to ipynb).\nTo use this, you have to require the ox-ipynb library. Then you can export this file with the key sequence C-c C-e n o to create the ipynb and open it.\nIn the following sections I will demonstrate a few features.\nOrg-mode markup You should get all the regular markup:\nbold text italics underlined strikethrough verbatim code superscripts, e.g. H^+ subscripts, e.g. CH4 hyperlinks: http://github.com/jkitchin/ox-ipynb Embed equations You can use LaTeX equations like: \\(\\int_0^1 \\sin x dx\\).\nEmbed code and results Note that code blocks must be either \u0026ldquo;ipython\u0026rdquo; or \u0026ldquo;R\u0026rdquo;, and the first one determines the language used for all of the code blocks.\nimport numpy as np from scipy.integrate import quad print(quad(lambda x: np.sin(x), 0, 1)) Here we force a new cell to be created with the ipynb-newcell directive. #+ipynb-newcell\nThis text should be in its own cell.\nEmbed tables You can create tables and they render nicely in the notebook. Note that you probably should not use the tables as data sources to code blocks because the ipython notebook does not support that.\nTable 1: A table of numbers. x y 1 1 2 4 3 9 Use ipython magic to get inline figures %matplotlib inline import matplotlib.pyplot as plt z = np.linspace(0, 20 * np.pi, 500) x = np.sin(z) * np.exp(-0.1 * z) y = np.cos(z) * np.exp(-0.1 * z) plt.plot(x, y) Store metadata in the ipynb The directive ox-ipynb-keyword-metadata lists file variables that should be saved as metadata in the ipynb.\nWe can set values as file variables like this:\nOn export, you can see these are stored in the metadata as:\nThese will show as bullets at the top of the ipynb. These are machine readable, so you can access them with any tool that can read json. You can use this to store author names, document id\u0026rsquo;s, etc.\nimport json with open(\u0026#34;example.ipynb\u0026#34;) as f: d = json.loads(f.read()) print(d[\u0026#39;metadata\u0026#39;][\u0026#39;org\u0026#39;]) Use HTML for fancy markup You can use html tags directly in the org file. Here are two examples.\n\u0026lt;div class=\u0026ldquo;alert alert-warning\u0026rdquo;\u0026gt; \u0026lt;font color=\u0026ldquo;blue\u0026rdquo;\u0026gt;This text will show up as blue.\u0026lt;/font\u0026gt; You can use an alert to highlight something you want to stand out. \u0026lt;/div\u0026gt;\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/example\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/python_summary4_data_structures\/": {
        "title": "python_summary4_data structures",
        "tags": [],
        "content": "", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary4_data_structures\/"
    },
       
    "https:\/\/braindump.frege2godel.me\/posts\/python_summary8_string\/": {
        "title": "python_summary8 string",
        "tags": [],
        "content": "String python의 코드를 보면 string이 많이 나온다. python code를 이해하고 짜기 위해선 string이 무엇이고 동작방식을 알아야하는데, 그럴려면 내부구조를 알아야 한다. internals는 깊게 들어가면 한도 끝도 없고, 프로그램을 짜는데 햇갈릴수도 있다. 하지만 코드를 봤을때 머리속에서 그림이 보여야 한다. cpython옛날 버전을 가지고 internals를 설명하는 blog가 있어서 참고를 한다. 참고 string은 기본적으로 container다. string에 들어가는 alphabet은 value이면서 객체다. primitive data type의 value들은 값이면서 객체인것은 oop언어이기 때문이다. 물론 이건 내 생각이다.\ns = \u0026#34;abc\u0026#34; 위 코드를 보면 어떤 그림이 상상되는가? python interpreter는 위코드를 읽고 어떤 일을 할까? 고민해 본적이 있는가? 나는 머리속에서 상상을 해본다. parser는 ascii코드를 읽고 각각의 항목을 list로 만들것이다. 그리고 assignment를 실행할것이다. rvalue는\nstring의 특징 immutable 이다. 표기법: \u0026lsquo;\u0026rsquo;\u0026rsquo;, \u0026ldquo;\u0026rdquo;\u0026quot;, \u0026ldquo;, \u0026lsquo;를 사용해서 string literal을 표시 가능 여러줄의 string literal은 \u0026ldquo;\u0026rdquo;\u0026rdquo;,\u0026lsquo;\u0026lsquo;\u0026lsquo;을 사용하자. tuple과 string은 둘다 배열이다. 그래서 둘다 immutable하고, indexing이 가능하며, slicing이 가능하다. 이것들이 배열의 특징이기 때문이다. in과 not in이 가능하다. 예를 들어보자. print(\u0026#39;a\u0026#39; in \u0026#39;abc\u0026#39;) print(\u0026#39;asdf\u0026#39; in \u0026#39;asdf_asdf\u0026#39;) python에선 character set으로 unicode로 처리한다. 즉 모든 글자는 4byte를 사용한다. escape문자 escape문자란? escape문자란 벗어난 문자다. 벗어난다는게 무슨 말인가? 원래 용도에서 벗어나 다른용도로 사용된다는 뜻이다. 문자라는것은 문자열에 포함된다. 문자열에 포함되면, 화면에 보여질 수도 있고, file에 text로 저장이 될 수도 있다. 그런데 escape문자는 문자열에 포함되지 않는다. escape문자중에 os나 언어차원에서 공식적으로 정의된 형태의 문자가 있다. \\를 사용하지 않는 문자인데, meta문자라고 부르기도 한다. 따옴표도 meta문자다. 예를 들어보자. python이란 언어에선 문자열을 나타내기 위해서 따옴표같은 문자를 사용한다. 따옴표도 문자이기때문에 문자열에 포함되어야 하지만, 따옴표는 문자열에 포합되지 않는다. 문자열의 시작과 끝을 나타낸다. 문자이지만, 문자열에 포함되지않는 escape문자라서 그렇다. 다시 말해서,문자라는게 문자라는 용도에 벗어나 다른 용도로 정의되어 있다면, escape문자라고 한다. meta문자 이외의 escape문자들은 보통 \\를 붙인다.\nescape문자를 만드는 \\문자가 일반문자에 적용되면 escape문자가 되지만, escape문자에 적용되면 escape문자를 일반 문자로 만들어준다.\nprint(\u0026#34;this is \\\u0026#34; .\u0026#34;) \\ escape 문자도 자기 자신을 escape시켜서 문자열에 포함시킬 수 있다.\nprint(\u0026#34;this escape escape character \\\\\u0026#34;) python 환경에만 이런 문자가 있는건 아니다. os도에도 있고, system에도 있다. 파일을 editor에서 편집한다고 생각하자. 키보드의 문자키를 입력하면, 키보드에선 문자키에 해당하는 code값을 cpu에 보낸다. 문자키에 해당하는 code값이란 unicode와 같은 character set 테이블에 있는 숫자값을 뜻한다. 각각의 character set은 symbol과 숫자값을 가지고 있기 때문이다. cpu에선 입력된 문자 code를 display로 보낸다. 그리고,display에선 code에 일치하는 symbol그림을 화면에 보여준다. font가 있다면 font에 해당하는 symbol그림을 display에서 보여준다. 키보드 문자키로 작성되는 모든 문자들은 기본적으로 화면에 출력이 된다. 파일을 열었을때, 파일에 담긴 문자코드들은 화면에 글자로 보여져야하는 용도인데, escape문자들은 문자열에 포함되지 않은 문자라서 화면에 보여지지 않고 다른 용도로 사용될 수있다. 예를 들어, \\a라는 문자는 bell소리를 낸다. a라고 화면에 보이지 않는다. escape문자이기 때문이다. display device로 가지않고 sound device로 가기 때문이다.\nescape 문자의 예 python에서 사용되는 escape문자는 아래와 같은 예가 있다.\nprint(\u0026#39;\\\\ \u0026#39;) print(\u0026#39;\\\u0026#39; \u0026#39;) print(\u0026#39;\\\u0026#34; \u0026#39;) print(\u0026#39;\\b \u0026#39;) print(\u0026#39;\\n \u0026#39;) print(\u0026#39;\\t \u0026#39;) print(\u0026#39;\\e \u0026#39;) \\\\: back slash\n\\ enter: back slash : 화면에서 다음줄로 넘어가지만, newline이 생기지 않는다. 실제 저장될 때, newline이 없게된다.\n\u0026gt;\u0026gt;\u0026gt; 이렇게 적으면 \\enter \u0026gt;\u0026gt;\u0026gt; 엔터없이 \\enter \u0026gt;\u0026gt;\u0026gt; 여러줄을 적어요. \\enter \u0026gt;\u0026gt;\u0026gt; \u0026#39;이렇게 적으면 엔터없이 여러줄을 적어요\u0026#39; \\b: backspace\n\\n: newline: 문자열에 newline이 있으면, 무조건 newline이 해석되는 게 아니다.\nFigure 1: text eval\nrepl에선 text에 escape문자가 있다고 해서 evaluate되지 않는다. 하지만, 변수에 있는 문자열은 evaluate되기 때문에 newline이 해석된다. 이것은 repr()함수가 동작하기 때문이다. repr()는 built-in function이다. repr()는 escape문자를 그대로 출력한다. 따라서, repr()로 return된 값은 escape문자를 포함한 문자열을 return하기 때문에 print해도 escape문자가 출력된다. repr() 표현된 문자열은 string이 아닌 representation이라고 부른다고 한다. string은 formatting을 할수 있지만, representation은 formatting을 할 수 없다고 한다.\ntext =\u0026#34;This is \\nNewline\u0026#34; print(repr(text)) repr()는 class객체를 출력할 때도 볼 수 있다.\nclass A: pass a = A() print(a) 객체를 출력할때, str()를 overriding해서 string을 출력하게 할수도 있지만, repr()을 overriding해서 위와 같은 문자열을 출력하게 할 수도 있다.\n\\t: tab\n\\e: esc\nraw string repr()가 escape문자를 해석하지 않고 original 그대로 가지고 있다면, raw string도 escape문자를 string literal로 취급하는데, 약간 trick을 사용한다. 즉 escape문자에 \\를 덧붙이면 escape 문자가 출력이 된다. 그래서 마치 escape문자를 문자 그대로 출력하는것 처럼 보이게 만든다. 아래의 예를 보면, repr()에서 escape문자가 포함된 문자를 출력하는것과 raw string으로 표현된 문자열의 출력을 repr()로 보면 original string모습을 확인 할 수 있다.\n참고로 raw string은 r이라는 symbol을 string앞에 붙인다.\nstring = \u0026#34;여기서 \\n은 escape문자다.\u0026#34; print(repr(string)) print(string) raw_string = r\u0026#34;여기서 \\n은 string literal이다.\u0026#34; print(repr(raw_string)) print(raw_string) raw string이 사용되는 경우는 escape문자가 그대로 출력되야 하는 경우에 raw string을 사용하면 편하다. 예를 들어보자.\nlocate = \u0026#34;c:\\\\users\\\\test\u0026#34; print(locate) locate = r\u0026#34;c:\\users\\test\u0026#34; print(locate) 첫번째는 경로 문자열을 그대로 표현해야 한다. string을 사용할 경우, \\을 하나씩 더 붙여야 문자경로명이 표시된다. raw string을 사용할 경우 경로와 같은 escape문자를 그대로 출력해야 할때, 그대로 사용하면 된다. 굳이 원본 text에 \\을 붙일 필요가 없다. 예를 들어, ebook에 \\를 사용한 단어들이 많이 나왔을때, string으로 취급해서 처리할려면, ebook의 모든 \\ 글자를 찾아서 \\를 추가해야만 \\가 출력이 가능하다. 하지만, raw string은 그런 pre-processing을 할 필요가 없다.\nString의 기본 methods 기본 methods len(string) 문자의 길이를 반환한다.\ntext =\u0026#39;this is sentence\u0026#39; print(len(text)) string.upper() 대문자로 변환한다.\ntext = \u0026#34;this is string\u0026#34; print(text.upper()) string.lower() 소문자로 변환한다.\ntext = \u0026#34;this is string\u0026#34; print(text.lower()) string.capitalize() 시작 문자를 대문자로 변환\ntext = \u0026#34;this is string\u0026#34; print(text.capitalize()) string.title() 단어의 시작을 대문자로 변환한다.\ntext = \u0026#34;this is string\u0026#34; print(text.title()) string 공백 제거 methods 크롤링할때 공백을 제거할 일이 많다.\ntext = \u0026#39; 공백이 \\t 있어요. \\t\\n \u0026#39; print(text) print(text.strip()) print(text.rstrip()) print(text.lstrip()) string.strip() 좌우의 공백을 제거한다.\nstring.lstrip() 왼쪽 공백을 제거한다.\nstring.rstrip() 오른쪽 공백 제거한다.\n문자열 check predicate print(\u0026#39;12345\u0026#39;.isdigit()) print(\u0026#39;1.23e-5\u0026#39;.isdigit()) print(\u0026#39;Capitalize\u0026#39;.isupper()) print(\u0026#39;lower_case\u0026#39;.islower()) string.isdigit() string이 0-9사이의 숫자형태인지 확인한다. 위의 예를 보면, e를 사용한 지수형태가 있는데 이것은 digit이 아니다.\nstring.isupper() 모든 문자가 대문자로 이루어져 있는지 확인한다.\nstring.islower() 모든 문자가 소문자로 이루어져 있는지 확인한다.\nString Pattern matching pattern이 문자열에 있는지 궁금할 수도 있고, 있다면 어디에 있는지 알고 싶을 때 pattern matching함수를 사용한다. pattern이 있는지 없는지 여부는 in을 사용해도 된다.\ntext = \u0026#39;abc_text_abc_ee\u0026#39; pattern = \u0026#39;abc\u0026#39; print(text.count(pattern)) print(text.find(pattern)) print(text.rfind(pattern)) print(text.startswith(pattern)) print(text.endswith(pattern)) string.count(pattern) string 문자열내에 pattern의 occurs 반환\nstring.find(pattern) string 문자열 내에서 pattern을 find해서 첫 occur의 index반환\nstring.rfind(pattern) string 문자열 내에서 pattern을 reversed(뒤에서부터) find한 첫 occur의 index반환\nstring.startswith(pattern) string이 pattern으로 시작하는지 확인\nstring.endswith(pattern) string이 pattern으로 끝나는지 확인\nsplit \u0026amp; join 프로그램을 짤 때, 프로그램의 기본 구조가 있다. 파일이나 외부 입력으로 sequence data(유한개)를 입력 받고 for-loop으로 하나하나 꺼내서 if로 처리한다. 이게 기본 구조다. 여기서, 입력으로 받은 sequence가 문자열이고, 우리는 for-loop으로 하나 하나 꺼내서 list에 넣는 처리를 하고 싶다. 어떻게 해야 할까? 이때, split()를 사용하면 for-loop과 if를 사용하지 않아도 된다. python에선 어떻게 하면 이 정형화된 for-loop과 if대신 함수로 간단화 할것인가?에 관심이 많다.\ntext = \u0026#39;한국어 abc 테스트 \\n abc 중 \\t 입니다\u0026#39; print(text.split()) print(text.split(\u0026#39;abc\u0026#39;)) print(\u0026#39; \u0026#39;.join(text.split())) print(\u0026#39;, \u0026#39;.join(str(i) for i in range(10))) string.split() string이 입력으로 들어왔을 때, 단어를 list로 넣는다. white space(space,newline,tab)을 제거후 split한다. for-loop으로 문자 하나하나 꺼내고 if로 white space 확인후 제거후 list에 넣는다. for-loop과 if를 사용하지 않게 해준다.\nstring.split(pattern) split에 인자가 없다면, white space(space,newline,tab)을 기준으로 제거하고 list에 넣는다면, 이것은 인자가 주어진다. 주어진 인자를 제거하고 list에 넣는다.\nstring.join(iterable) for loop와 if로 입력 data를 처리하는게 programming에서 입력데이터를 처리하는 기본 구조라고 했다. if로 조건에 맞는 data를 처리도 해야 한다. join은 split()로 if까지 해서 조건에 맞는 data를 list로 넣었다면, list에 대한 처리까지 한다. list의 item을 꺼내서 string을 덧붙여 최종적으로 string을 만들어 낸다.\nprint(\u0026#39; \u0026#39;.join(text.split())) print(\u0026#39;, \u0026#39;.join(str(i) for i in range(10))) 위의 예에서 보듯이 join은 iterable의 item을 꺼낸 후 뒤에 string에 해당하는 문자열을 붙여서 최종적으로 string을 return한다. 첫번째는 split()에 의해서 white space가 제거된 list에서 space를 item마다 추가한 문자열을 return한다. 여기서 추가된 건 space다. white space가 아니다.\nstring formatting program에서 string을 사용하는것은 string에서 어떤 값을 도출하기 위해서,즉 계산을 위해서 사용될 수도 있으나, 출력을 위해서 사용할 때도 있다. 화면에 출력한다거나, file에 로그기록을 남긴다던가, 이럴때 formatting이 필요하다. 알아보기 쉽게 string을 재작성하는 것이다. string literal을 사용하면 되지, 왜 재 작성이냐? 출력할 string은 string literal이 아닌, 변수,객체값을 표현해야 하기 때문이다. 객체의 값이나 변수의 값을 string에 포함시키기 위해선 재작성및 재처리가 필요하다. 예를 들어, 어떤 변수가 3.141592\u0026hellip; 엄청 긴값을 가지고 있을때, 이것을 그대로 파일에 저장한다거나 화면에 출력한다면 가독성이 떨어지게 된다. 그래서 formatting이 필요하다.\na,b,c = 10,1.725, \u0026#39;sample\u0026#39; print(str(a) + \u0026#34;: \u0026#34; + str(b) + \u0026#34; - \u0026#34; + c) print(\u0026#34;%d: %f - %s\u0026#34; % (a,b,c)) print(\u0026#34;{}: {} - {}\u0026#34;.format(a,b,c)) print(f\u0026#34;{a}: {b} -{c}\u0026#34;) % formatting 문자열에 변수나 객체값을 넣어서 string을 만들려고 하기때문에 변수나 객체를 제공하는 부분과, 변수값이나 객체가 위치할 placeholder를 포함한 string template이 있다. 변수나 객체는 뒤에 % tuple형태로 제공한다. placeholder는 %형태로 되어 있다. 미리 만들어준 string template에 %로 시작하는 placeholder를 넣어둔 꼴이다. placeholder안에서 값들을 formatting한다. formatting은 3-4가지 정도가 있다. 대표적인 padding,precision,datatype을 기술하는 ppd format은 가장 많이 쓰이는 formatting방식이다.\nplaceholder =\u0026gt; %[padding+datatype] placeholder =\u0026gt; %[align + padding + datatype] etc) -,+: align placeholder =\u0026gt; %[align + precision + padding + datatype] etc) -,+: align padding 설정 %-4d: 4칸의 padding을 만들고 값을 앞에서부터 넣는다. %4d: 4칸의 padding을 만들고 값을 뒤에서부터 넣는다. %04d: 4칸의 padding을 만들고 값을 뒤에넣고 빈공간은 0으로 채운다. print(\u0026#34;%d+%d+%d\u0026#34; % (1,10,100)) print(\u0026#34;%4d+%4d+%4d\u0026#34; % (1,10,100)) print(\u0026#39; 1+ 10+ 100\u0026#39;) print(\u0026#34;%-4d+%-4d+%-4d\u0026#34; % (1,10,100)) print(\u0026#34;%04d+%04d+%04d\u0026#34; % (1,10,100)) float를 위한 precision 설정 precision은 .을 붙여준다.\nprint(\u0026#34;%f+%f+%f\u0026#34; %(123.4,12.34,1.234)) print(\u0026#34;%.3f+%.3f+%.3f\u0026#34; %(123.4,12.34,1.234)) print(\u0026#34;%8.3f+%8.3f+%8.3f\u0026#34; %(123.4,12.34,1.234)) print(\u0026#34;%08.3f+%08.3f+%08.3f\u0026#34; %(123.4,12.34,1.234)) [datatype] %datatype a %s string %d int %f float %o octet %x hexa naming placeholder를 나타내는 %와 변수는 1:1 mapping한다고 했다. 이를 명확하게 해줄 수도 있다.\nprint(\u0026#34;%(first)5.2f - %(second)5.2f\u0026#34; % {\u0026#34;first\u0026#34;: 10.2, \u0026#34;second\u0026#34;: 5.62}) format() 함수 객체나 변수의 값을 string으로 만들어 출력한다고 했다. 이때 formatting을 해서 string을 만든다고 했다. format()함수도 formatting하는 함수다. % formatting은 %로 변수값을 제공했다면, format()는 인자에 변수값을 제공한다. 그리고 만들고 싶은 형태의 string format은 미리 만들고, placeholder를 만드는 방식은 % formatting과 다를 바 없다. 다만 placeholder를 포함한 string template이 좀 다르다. %formatting은 placeholder가 %로 시작했다면, format()는 string template안에 들어가는 placeholder가 {}같은 형태다. {}는 변수와 1:1 mapping된다. mapping된 변수에 대한 formatting작업이 일어난다.\npositioning (순서 설정) {}와 변수는 1:1 mapping된다. mapping 순서를 바꿀 수 있다.\na,b,c = 10,1.725,\u0026#39;sample\u0026#39; print(\u0026#34;{}: {} - {}\u0026#34;.format(a,b,c)) print(\u0026#34;{0}: {1} - {2}\u0026#34;.format(a,b,c)) print(\u0026#34;{0}: {2} - {1}\u0026#34;.format(a,b,c)) 순서 설정은 변수와 placeholder가 mapping되는 순서를 바꿔줄 수 있다는 것이다. 마치 index같다. % formatting에는 없는 방법이다.\npadding \u0026amp; precision \u0026amp; datatype 설정 format()함수도 placeholder에서 padding과 float를 위한 precision, datatype을 넣어 줄 수 있다.\nprint(\u0026#34;{0}+{1}+{2}\u0026#34;.format(123.4, 12.34, 1.234)) print(\u0026#34;{0:.3f} + {1:.3f} +{2:.3f}\u0026#34;.format(123.4, 12.34, 1.234)) print(\u0026#34;{:8.3f}+{:8.3f}+{:8.3f}\u0026#34;.format(123.4, 12.34, 1.234)) naming 각각의 placeholder와 각각의 변수들이 1:1 mapping된다고 했다. format()에서는 index를 사용해서 placeholder에서 구분이 가능했다. 그런데 mapping이 많아지면, naming을 쓰는 것이 더 효율적이다. 아래 예를 보면, kwargs형태가 나왔다. format()를 호출할때, parameter가 stack에 쌓아지는데, keyword:value의 형태를 한꺼번에 가져갈때, dictionary를 사용하고, **kwargs로 받는다고 했다. 비슷하게 dictionary를 string template이 받는다고 생각하면 될듯하다. 강사는 unpacking이라고 얘기한다.\nprint(\u0026#34;{first:5.2f} - {second:5.2f}\u0026#34;.format(first=10.2, second=5.62)) print(\u0026#34;{first:5.2f} - {second:5.2f}\u0026#34;.format(**{\u0026#34;first\u0026#34;: 10.2, \u0026#34;second\u0026#34;: 5.62})) f string 가장 많이 사용되는 방식이라고 한다. fstring은 % formatting이나 format()와 가장 큰 차이점은 string template만 존재한다는 것이다. 이전의 2가지 방식은 모두 placeholder가 포함된 string template과, 변수와 객체값을 나타내는 formatting provider가 존재했다. f string에선 string template만 존재한다.\npositioning a,b,c = 10,1.725,\u0026#39;sample\u0026#39; print(f\u0026#34;{a}: {b} - {c}\u0026#34;) print(f\u0026#34;{a}: {c} - {b}\u0026#34;) padding \u0026amp; precision \u0026amp; datatype value = 12.34 print(f\u0026#34;{value*10} +{value} + {value/10}\u0026#34;) print(f\u0026#34;{value*10:.3f} +{value:.3f} + {value/10:.3f}\u0026#34;) print(f\u0026#34;{value*10:8.3f} +{value:8.3f} + {value/10:8.3f}\u0026#34;) Regular Expression pattern을 찾는다는것. pattern이란 무엇인가? 규칙(regular)적인 형태, 반복적인 형태를 pattern이라고 말한다. 문자열뿐만 아니라 우리는 보는 모든것에서 본능적으로 pattern을 인식할 수 있다. 우리가 pattern이라고 생각하는것을 표현할 수 있을까? 표현할 수 있다면 어디에 쓸것인가?\npattern을 표현하는 방법, programming language에서 문자열에 나타내는 pattern을 표현하는 언어가 따로 있다. regular expression이라고 한다. 규칙적인 표현? pattern의 다른말에 불과하다. 즉 pattern을 나타내고자 한다면, regular expression을 사용하면 된다.\npattern을 regular expression으로 나타낸다면, 어디에 사용되는가 사용가치가 있는가?라는 질문이 있을 수 있다. 패턴을 나타내면 검색하는데 사용할 수 있다. 즉 어떤 문자열이 주어졌을때, 어떤 pattern이 있냐 없냐를 검색할 수도 있고, 검색된 내용을 바꿀수도 있다. regular expression이란 tool이 이것을 가능하게 해준다. for-loop과 if를 사용해서 이런 기능을 구현할 수도 있겠지만, regular expression이란 tool을 사용하면, 좀 더 쉽고, 막강하게 처리할 수 있다. 참고로 pattern은 일종의 set으로 봐도 된다. 강사는 실제적인 예로 다음 예를 설명한다.\n야 이거 #%이름#꺼 아니야? #%이름#에게 물어봐 #%이모티콘# 정보보호를 위해서 이름이나, 전화번호,주소, 특정내용은 blind되서 제공된다고 한다. 이런 경우 pattern을 찾고 replace하는 일이 빈번하게 일어난다. 이 경우 find(pattern)로 찾을 수 없다고 한다. find는 명시적인 문자열이여야 하는데,#%\u0026lt;임의의 문자열\u0026gt;#으로 명확하지 않은 pattern은 regular expression을 사용해야 한다고 한다.\nRegular expression 패턴 예시 \\d{3}\\-\\d{4}\\-\\d{4} 010-1234-5678 {1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3} 192.168.0.20 #%[^#]+# #%이모티콘# 정규식을 다룬다는건 양이 많다. 참조 사이트에서 연습을 하길 추천한다. Regular Expression 문법 meta character escape문자의 일종, escape문자는 원래 용도에서 벗어난 문자. 문자의 원래용도는 화면에 출력되거나 문자열에 포함되거나, data로서의 역할이다. meta문자는 \\를 사용하지 않는 escape문자로 보면된다. 다른곳에선, 문법적인 역할이 정해진 문자. pattern을 표현할 때, 사용하는 문자다.라고 정의하기도 한다.\n. ^ $ * + ? { } [ ] \\ | ( ) regular expression에서 위 문자들은 화면에 보이는 문자가 아니다. 특수한 의미를 가진 문자로 용도가 정해져 있다. literal character로 사용하려면 \\를 앞에 붙여 줘야 한다.\n^ meta 문자\n문자를 나타내지 않는다. line의 처음을 나타낸다.\n^a a aa aaa aaaa 1aaa 위에서 보면, 1aaa빼고 다 match된다.\n$ meta 문자\n문자를 나타내지 않는다. line의 끝을 나타낸다.\na$ a aa baa aabb a$는 line의 마지막글자가 a라는 것을 나타낸다. 따라서 aabb는 매치되지 않는다.\n/d meta 문자\n하나의 숫자를 나타내는 pattern이다.\n/w meta 문자\n한 문자를 나타내는 meta문자다. 한문자는 a-z,A-Z,0-9가 될 수 있다.\n/s meta 문자\nspace를 나타내는 meta문자다.\nmeta 문자.\nregular expression에서 []라는 문자를 보면, 다음과 같은 형태로 되어 있다.\n[a-z], [A-Z0-9] [\\d\\s] [ ]는 한 문자를 나타내는 pattern이다. 어떤 문자인지는 [ ] 내부에서 -로 표현한다. [A-Z0-9]는 A~Z이거나 0~9의 범위에 있는 문자를 의미한다. [\\d\\s]는 digit이거나 space이거나라는 범위를 나타낸다.\n[^ ] meta 문자\n^란 문자는 not을 의미한다. 즉 포함되지 않는 문자를 말한다. [^ ] 도 한 문자를 의미한다.\ndot(.) meta 문자\ndot 문자도 하나의 문자를 나타내는 pattern이다. [ ]는 range가 있다. 하지만 dot은 \\n을 제외한 모든 문자를 dot으로 나타낼 수 있다. white space도 포함한다.\n\\s...\\s pattern은 \u0026#34;abcd efg hij klmnop\u0026#34; =\u0026gt; efg, hij ? meta 문자\n[]이나 dot처럼 ?문자도 한문자를 대신하는 pattern이다. 한 문자를 대신하는 pattern이 3개 이지만, 한문자를 cover하는 범위가 각기 다르다. 예를 들어 []의 경우는 안에 range가 있다. 특정 range의 문자만 대신한다. 반면에 dot은 모든 문자1개를 대신할 수 있다. 그런데 ?는 범위가 더 넓다. 1개의 모든문자와 문자가 없는 경우도 대신한다.\n반복횟수 지정({}) meta문자\n이전에는 한개의 문자에 대한 pattern이였다. 한 문자에 대한 pattern은 강력하지 않을 수 있다. 아래에 나오는 반복을 나타내는 pattern과 같이 쓰인다면 강력한 pattern을 만들 수 있다.\n{3} -\u0026gt; 3번 반복 {3,} -\u0026gt; 3번이상 반복하는, 무한 반복을 나타낼수 있다. {2,5} -\u0026gt; 2번이상 반복 5번 이하 반복 되지 않는것. star(*) meta 문자\n문자를 나타내는 meta문자가 아니다. 앞의 문자의 횟수를 나타내는 meta문자다. 0번 이상 무한 반복을 나타내는 pattern이다. 예를 들어서,\nab* pattern은 a,ab, abb, abbb, abbb... 앞의 문자인 b의 0번부터 무한까지의 반복된 문자 pattern을 나타낼 수 있다.\nmeta 문자 +도 문자를 나타내는 meta문자가 아니다. 앞문자의 횟수를 나타내는 meta문자다. 단 1회 이상의 반복을 해야하기 때문에 *와는 다르다.\nab+ pattern은 ab, abb, abbb, abbb... start와 + meta 문자의 문제점\n+와 *를 사용해서 pattern을 만들고, 만든 pattern으로 특정 text를 검색할 때 문제가 생길 수 있다. 우리가 원하는 문자열 검색이 안될 수 있다.\n예를 들어서 #%을 prefix로 갖고, #을 postfix로 갖는 pattern을 만들었다고 하자.\n#%.*# .*는 prefix와 postfix의 문자열이다. 무한개의 가능한 문자열이 들어갈수 있다. prefix와 postfix만 맞으면 된다. 이 pattern으로 아래 text를 검색해 보자.\n#% 테스트입니다.# 정말로 #% test일까요?# 결과는\n#% 테스트입니다.# 정말로 # 우리가 원한 결과는 아래였다.\n#% 테스트입니다.# 많이 다르다. 왜냐하면 *나 +의 앞문자 무한반복 가능한 pattern의 경우, greedy하다. 즉 prefix와 postfix가 일치해도, 남은 text중에 postfix가 일치하면, 더 긴 검색결과를 return하기 때문이다. 이것을 막기위해서 다음과 같은 방식을 사용할 수도 있다.\n#%[^#]+# 즉 prefix와 postfix안에 #이라는 문자가 있는 경우 제외시킨다. 이러면 우리가 원한 결과를 얻을 수 있다. 이 방식 말고도 lazy matching pattern을 사용할 수도 있다. 선호하는 방식은 위의 방법이 더 선호된다고 한다.\nlazy matching pattern\n위에서 +나 *를 사용한 pattern들은 우리가 원했던 의도로 검색이 안됐다. 안된 이유는, 가장 긴 pattern을 찾기 때문이라고 했다. greedy하다. 그래서 검색을 할때 만족하는 가장 긴 pattern이 아닌 가장 짧은 pattern을 검색하게 하려면, lazy하게 만들어야 한다. 게을러지면, 짧아도 만족만 되면 멈추기 때문이다. 그것을 lazy matching pattern이라고 부른다고 한다. 아래와 같은 pattern을 만들었다.\n\u0026lt;.+\u0026gt; prefix인 \u0026lt;과 postfix인 \u0026gt; 사이에, 무한한 문자(.+)가 올수 있는 경우다. 이것은 *와 +를 사용할 때의 문제점을 보여주고자 함이다. 아래의 문자열을 검색해 보자.\nThis is a \u0026lt;div\u0026gt; simple div\u0026lt;/div\u0026gt; test 검색 결과는 다음과 같다.\n\u0026lt;div\u0026gt; simple div\u0026lt;/div\u0026gt; 우리가 원하는 결과는 앞의 \u0026lt;div\u0026gt; 와 뒤의 \u0026lt;div\u0026gt;를 찾고 싶었던 건데, 원하는 결과가 안나왔다. 즉 pattern을 만족하는 가장 긴 문자열을 찾았기 때문이다. 이것을 lazy pattern으로 만든다면, 다음과 같다.\n\u0026lt;.+?\u0026gt; +나 *뒤에 ?를 하면 lazy pattern이 되는 것이다. lazy pattern을 사용하면 원하는 검색결과를 얻을 수 있다고 한다. 하지만, 선호되지 않는다고 한다. 그래서 보통은 다음과 같이 사용한다고 한다.\n\u0026lt;[^\u0026gt;]+\u0026gt; \u0026lt; \u0026gt; 사이에 문자들이 오는데, \u0026gt;을 포함하면 안된다는 뜻이다.\n선택(|) meta 문자\n\u0026lsquo;|\u0026rsquo; meta 문자는 두개의 pattern을 사용할 수 있게 해준다. 예를 들어 보자.\n010-1234-5678 +82-010-1234-1234 +81-42-1234-5678 024-23-4321 위 전화번호중에 010으로 시작하고, +82로 시작하는 전화번호만 검색하려고 한다. 이때 2개의 pattern을 만들고 |을 사용하면 된다.\n(0 | \\+82)\\d{1,2}-\\d{3,4}-\\d{4} Boundary meta 문자들\n\\b : 단어를 찾을 때 사용한다. 단어의 시작점을 의미\n\\babc this is not mabc but abc abc가 검색된다.\n^: 줄이나 문자열의 시작점\n^\\w+ This is sample. I like this. Life is short. 참고로 \\w 는 문자 하나를 나타내는 pattern이다. 각라인의 첫 단어를 검색하게 된다. 아래와 같은 것이 검색된다.\nThis, I, Life $: 줄의 끝에서 찾는다.\n$\\. 이것은 newline 바로 앞 단어에서 찾는다. 예제는 마침표를 찾는 것이다.\ncapturing group\ncapturing group: tomato같은 단어를 찾고 싶다면, one-to-one이란 단어를 찾고 싶다면, abdeab라는 단어를 찾고 싶다면 어떻게 해야할까?\ntomato, one-to-one, abcdebch 위 단어의 공통점은 prefix에 해당하는 문자들과 postfix에 해당하는 문자들이 동일하다는 것이다. 이것을 pattern으로 나타낼 수 있다면, 비슷한 단어들을 검색할 수 있을 것이다. 어떻게 pattern을 만들어야 할까? prefix는 capture하고, postfix는 numeric reference로 참조한다. capturing을 group화 한다고도 많이 말한다.\n우선 capture, numeric reference란 용어와 사용법을 알아야 한다. capture는 group으로 만들어 저장한다. 저장하는 방법과 capture된것을 사용하는 방법은 아래에 있다.\n(\\w)a\\1 hah bong dad bad dab gag gab 우선 pattern분석부터 해보자.\n\\w w는 한 문자다. [a-zA-Z0-9]와 같은 뜻이다. 즉 소문자이거나, 대문자이거나 digit인 한 문자다. 따라서 아래의 text에서 space를 제외한 모든 문자들이 하나 하나 다 선택된다.\nhah bong dad bad dab gag gab (\\w) 이것은 한문자가 선택되는 건 맞는데 capture된다. capture된다는건 기억된다는 것이고 기억하는 이유는 다시 사용하기 위함이다. number reference로 기억했던걸 다시 사용할 수 있다. 우선 한문자를 선택하는 건 변함이 없기 때문에 아래의 text 각각의 문자가 선택된다.\nhah bong dad bad dab gag gab 이제 한문자를 추가한 pattern을 만들자.\n(\\w)a 임의의 문자와 그 뒤에 a가 나오는 pattern을 만들었다. 이 pattern으로 아래의 text를 검색해보자.\nhah bong dad bad dab gag gab ha da ba da ga ga 위의것이 선택된다. 이제 numeral reference를 사용하자. 지금 capturing group은 1개밖에 없다. 따라서 \\1밖에 사용하지 못한다. 여튼 이 패턴을 text에 적용해보자. 즉 검색해보자.\n(\\w)a\\1 hah bong dad bad dab gag gab 결과는 어떻게 될까?\nhah dad gag 위와같이 된다. 작동 원리는 다음과 같다. 임의의 한문자뒤의 a로 된 2개의 문자, 그리고 capturing된 문자가 있는 3개의 문자를 text에서 찾아야한다. text를 보자. 첫 문자 \u0026lsquo;h\u0026rsquo;는 일치한다. 따라서 capturing한다. 이제 뒤의 문자를 보자. \u0026lsquo;a\u0026rsquo;가 있다. ok. 그 다음 문자는 h다. 우리의 pattern을 보면, \u0026lsquo;a\u0026rsquo;다음엔 capturing문자가 와야 한다. 즉,\\1에 의해 \u0026lsquo;h\u0026rsquo;문자가 와야 pass가 된다. \u0026lsquo;h\u0026rsquo;가 있다. 일치한다. 따라서 검색 완료. 그다음 space는 \\w에 해당하지 않기 때문에 pass한다. \u0026lsquo;b\u0026rsquo;는 \\w와 일치한다. 그런데 그 다음 \u0026lsquo;o\u0026rsquo;는 일치하지 않는다. \u0026rsquo;n\u0026rsquo;은 \\w와 일치한다. \u0026lsquo;g\u0026rsquo;가 일치하지 않는다. 그 다음은 space라서 \\w와 일치하지 않는다. d를 본다. \\w와 일치한다. d가 capturing된다. \u0026lsquo;a\u0026rsquo;문자를 본다. 일치한다. \u0026rsquo;d\u0026rsquo;문자가 나왔다. 이것은 capturing된 \u0026rsquo;d\u0026rsquo;와 일치한다. 따라서 검색이 완료된다. 이런식으로 계속 검색을 하는 것이다.\n위에서도 말했지만, prefix와 postfix가 같은 경우, capturing group을 사용하는게 굉장히 유용하다.\ncapturing group이 한개만 사용되는건 아니다. 2개도 사용될 수 있다. 2개가 사용되면, 2개를 기억하게 되고, 기억된 문자를 다시 numeric reference로 참조해서 사용하면 된다.\ncapturing(group) 간단 예제\nimport re m = re.match(\u0026#39;([0-9]+) ([0-9]+)\u0026#39;, \u0026#39;10 295 32 54\u0026#39;) print(m.group(1)) print(m.group(2)) print(m.group()) print(m.group(0)) print(m.groups()) 위의 pattern을 보면 2개의 group이 있다. 첫번째 group에 매치되는 문자열은 group(1)로 출력할 수 있고, 두번째 group에 매치되는 문자열은 group(2)에 출력할 수 있다. group()는 group이 몇개던 matching된 문자열을 return한다. group(0)도 group()과 같은 뜻이다. groups()는 tuple로 return한다.\nnon-capturing group\nnon-capturing group은 group이긴 한데, captuing을 하지 않는다. group()을 사용하는 이유는 우선순위를 갖기 때문이라고 한다. 사용법은 (?:)형태로 사용해야 한다. 자주 사용될지 모르겠다. 여튼 captuing은 하지 않는다. 다음과 같은 text가 있다고 하자. 여기서 010-1234-1234, +82-10-5678-5678과 같은 형태의 전화번호를 검색하고 싶다고 하자. pattern을 만들어야 한다.\n010-1234-1234 010-1234-5678 +82-10-5678-5678 +82-4123-1234 pattern을 어떻게 만들까? 5678로 나온게 뒤에 다시 5678로 나오고 1234로 나온게 뒤에 또 1234가 나온다. 이것은 capturing의 예이다. 우선 capturing만 적용시키면 다음과 같이 쓸수 있다.\n(\\d\\d\\d\\d)-\\1 그런데 반복된다. 반복은 {} meta문자로 나타낼수 있기 때문에,\n(\\d{4})-\\1 로 표현하면 된다. 그다음 해야할 것은 010-1234-1234, +82-10-5678-5678 에서 보면 010이거나 10이다. 즉 3자리의 숫자이거나 2자리의 숫자이다.\n\\d{2,3} 표시하면 된다. 이제 마지막으로 +82이거나 없거나인데, 이때, non-capturing group을 사용할 수 있다.\n(?: ?|\\+82-) 최종 결과 pattern은 다음과 같다.\n(?: ?|\\+82-)\\d{2,3}(\\d{4})-\\1 condition\npostfix 포함 여부\npostfix로 끝나는 단어를 찾는데 편한 방법이 있다고 한다. 예를 들어, 다음과 같은 text가 있다고 하자.\nTourism I don\u0026#39;t like idealism He is socialism 여기서 ism으로 끝나는 단어의 앞부분만 가져오고 싶다면, pattern을 만들어야 한다.\n[^\\s]* 이렇게 하면 ism을 postfix로 갖는 문자열을 검색하는 pattern이 된다. [^\\s]* 는 space가 포함되지 않은 문자열을 의미한다. 즉 단어를 뜻한다. 그런데 강사는 단어를 가져올때, 쉬운 방법이 있다고 한다.\n\\w+ 이게 단어를 가져오는 pattern이라고 한다. w라는게 word를 뜻한다고 한다. \\w는 단하나의 문자이기 때문에 \\w+를 해줘야 단어가 된다.\n여기서, postfix를 추가하기 위해서 ism을 추가한다.\n\\w+ism 이런 pattern을 다음의 text에서 검색한다.\nTourism I don\u0026#39;t like idealism He is socialism 결과는 아래와 같다.\nTourism idealism socialism 여기서, ism이 다 포함된다. 만일 ism을 포함시키지 않을려면 어떻게 해야 하나? 이때 ism 대신 (?=ism)을 사용하면 된다. 즉 ism은 결과에 포함시키지 않겠다는 뜻이다.\n[^\\s]*(?=ism) 이렇게 하면 결과는 다음과 같다.\nTour ideal social prefix 포함 여부\n위에서 했던것과 비슷하다. 예를 들어보자. 다음과 같은 text가 있다고 하자.\nThis is preprocessing function. The word is precompiled function. 여기서 preprocessing, precompiled라는 단어를 검색하고 싶다. 그리고 결과로 pre를 제거한 processing과 compiled를 얻고 싶다고 하자.\npattern을 만들어야 한다. pre로 시작하는 단어이기 때문에 다음과 같이 쓴다.\npre\\w+ 그런데 이 방식은 pre라는 prefix를 포함한다. 따라서 (?\u0026lt;=pre)로 바꿔줘야 한다.\n(?\u0026lt;=pre)\\w+ 이렇게 하면 다음과 같은 결과를 얻게 된다.\nprocessing compiled 주의해야 할것은 prefix경우 (?\u0026lt;=)를 사용하고 postfix의 경우 (?=)를 사용한다는 것이다.\npython에서 regular expression 간단한 사용법 import re text = \u0026#34;\u0026#34;\u0026#34; 010-1234-1234 010-1234-5678 +82-10-5678-5678 +82-4123-1234 \u0026#34;\u0026#34;\u0026#34; pattern = r\u0026#39;(?:0|\\+82-)\\d{1,2}-(\\d{4})-\\1$\u0026#39; for match in re.finditer(pattern,text,re.MULTILINE): print(\u0026#34;전체문자열\u0026#34;,match.group()) print(r\u0026#34;\\1 문자열\u0026#34;, match.group(1)) python에서 정규식은 re package를 사용한다. pattern은 r로 시작하는 문자열로 정의된다. pattern을 통해 text검색하는 함수는 여러개를 제공한다. 위의 예에도 있지만, re패키지에 보면, finditer라는 함수가 있다. 이 함수는 text에 pattern을 적용시켜서 검색을 하는데, iterator형태라서 한번 검색하는게 아니라, text끝까지 반복해서 검색한다. 이 함수의 1번째는 pattern, 두번째는 text, 3번째 인자는 multiline flag이다. text에서 multiline은 flag가 없다면 line으로 인식하지 않기 때문이다. 이 함수에서 match라는 객체를 return한다. 이 객체는 일치하는 문자열을 가지고 있다. 또한 여기선 capturing group을 사용하기 때문에, capturing된 문자열도 가지고 있다. group(0)은 일치하는 문자열이 나오고, group(1)은 capturing group의 값이 나오게 된다.\nMULTILINE option python의 re package를 사용해서 pattern을 text에 적용할 때, option들을 사용할 수 있다. 여러 option들이 있지만, MULTILINE에 대해서만 살펴보자.\nimport re pattern = r\u0026#34;^python\\s\\w+\u0026#34; text = \u0026#34;\u0026#34;\u0026#34;python one life is too short python two you need python python three\u0026#34;\u0026#34;\u0026#34; # match = re.findall(pattern,text,re.MULTILINE) match = re.findall(pattern,text) print (match) MULTILINE이란 option을 추가하지 않으면, python one만 결과로 나온다. pattern을 보면, ^는 문자열의 처음을 나타낸다. 주어진 text는 여러 line으로 이루어져 있음에도, 따옴표때문에 하나의 문자열로 인식되기 때문이다. 여기서 MULTILINE option을 넣어주면, python one, python two, python three의 결과가 나온다. 이것은 하나의 따옴표로 이루어진 문자열이라고 해도 각각의 line의 처음을 문자열의 처음으로 보겠다는 뜻이다.\n사용되는 함수들 re.search() import re text = \u0026#34;\u0026#34;\u0026#34; 010-1234-1234 010-1234-5678 +82-10-5678-5678 +82-4123-1234 \u0026#34;\u0026#34;\u0026#34; pattern = r\u0026#39;(?:0|\\+82-)\\d{1,2}-(\\d{4})-\\1\u0026#39; # pattern = r\u0026#39;(?:\\d{3})-\\d{4}\u0026#39; temp = re.search(pattern,text,re.MULTILINE) print(temp.group()) print(temp.groups()) # print(match.group(0)) search는 처음 매칭되는 문자열을 match객체로 return한다. match객체에서 group()를 사용하면 검색된 문자열을 return한다. groups()는 tuple형태로 검색된 문자열을 반환하는 match의 method다. 만일 capturing을 사용한다면, group(0)을 사용해서 capturing을 출력할 수 있다.\nre.finditer() 이것은 위에서 예제를 봤는데, iterator를 사용해서 matching될때마다 return하게 된다.\nre.sub() import re text = \u0026#39;\u0026#39;\u0026#39; 010-1234-1234 010-1234-5678 +82-10-5678-5678 +82-4123-1234\u0026#39;\u0026#39;\u0026#39; repl = r\u0026#39;치환됨\\1\u0026#39; pattern = r\u0026#39;(?:0|\\+82-)\\d{1,2}-(\\d{4})-\\1$\u0026#39; temp = re.sub(pattern,repl,text,re.MULTILINE) print(temp) # 다른예 # text = \u0026#39;\u0026#39;\u0026#39;010-1234-5678 Kim # 011-1234-5678 Lee # 016-1234-5678 Han\u0026#39;\u0026#39;\u0026#39; # text_mod = re.sub(\u0026#39;^[0-9]{3}-[0-9]{4}-[0-9]{4}\u0026#39;,\u0026#34;***-****-****\u0026#34;,text, flags=re.MULTILINE) # print(text_mod) re.sub는 substitute로, pattern을 검색해서 찾은 것을 replace하는 건데, 강사의 예제는 실행되지 않는다. 강사의 예제는 capture한것을 재가공해서 replace한건데, 제대로 안된다. replace할 문자열은 capture한 것을 사용하기 위해서 \\1 이라는 numeric reference를 사용했기 때문에, r이라는 prefix를 붙였다.\nre.split() import re print(re.split(\u0026#39;-\u0026#39;,\u0026#39;aaa-bbb\u0026#39;)) print(re.split(\u0026#39;(-)\u0026#39;,\u0026#39;aaa-bbb\u0026#39;)) import re text = \u0026#34;\u0026#34;\u0026#34; 010-1234-1234 010-1234-5678 +82-10-5678-5678 +82-4123-1234 \u0026#34;\u0026#34;\u0026#34; pattern = r\u0026#39;(?:0|\\+82-)\\d{1,2}-(\\d{4})-\\1\u0026#39; # result = re.search(pattern,text, re.MULTILINE) splited = re.split(pattern,text,re.MULTILINE) print(splited) # print(result) split는 검색결과를 list로 나타낸다. group이 있는경우는 좀 다르게 return한다. group에 match된 문자열과 전체문자열을 모두 표시한다. 따라서, 첫번째 group에 매치된 문자열과, group을 포함한 regular expression에 일치된 문자열을 return하는 것이다. group이란 독립적인 regular expression으로 볼 수 있기 때문이다.\nregular expression compile pattern을 compile해서 사용할 수 있다고 한다. compile을 한다는 의미가 와 닿지는 않는다. 강사는 pattern을 인식하는것이 시간이 많이 걸린다고 하는데, 그냥 meta와 escape문자로 이루어진 문자열에 불과한데, 시간이 더 많이 걸릴 이유는 없어보인다. 내가 봤을때, compile은 단지 pattern이란 문자열을 객체화한다고 본다. 그렇게 되면 재사용에 유리하다는 장점을 갖기 때문이다. 또한 코드의 가독성이 높아진다.\nfor string in dataset: match = re.search(pattern, string, re.MULTILINE) print (match.group(0)) 위에는 compile을 사용하지 않고, dataset으로 부터 string을 가져와서 검색하는 code다. 매번 string을 가져올때마다 pattern이 string에 적용되게 된다. 이것을 compile하면 다음과 같은 모양이 된다.\ncompiled = re.compile(pattern, flags= re.MULTILINE) for string in dataset: match = compiled.search(string) print(match.group(0)) re.search가 compiled.search(string)문장으로 대체된다. 가독성도 좋아지는 것을 볼 수 있다.\n", 
        "url": "https:\/\/braindump.frege2godel.me\/posts\/python_summary8_string\/"
    },
    
 }
</script>


<script src="/js/lunr.min.js" type="text/javascript" charset="utf-8"></script>


<script src="/js/lunr.stemmer.support.js" type="text/javascript" charset="utf-8"></script>


<script src="/js/lunr.ko.js" type="text/javascript" charset="utf-8"></script>


<script src="/js/search.js" type="text/javascript" charset="utf-8"></script>
</body>
</html>
