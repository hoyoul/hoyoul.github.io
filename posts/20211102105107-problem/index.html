<!DOCTYPE html>
<html>
  <head><title>Problem</title>


<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes" />

<link rel="shortcut icon" href="./img/favicon.ico" type="image/x-icon">
<link rel="icon" href="./img/favicon.ico" type="image/x-icon">    

<link rel="stylesheet" href="/css/main.css">

</head>
  <body><header>
  <a href="/" id="logo">
    <img src="http://braindump.frege2godel.me/img/mylogo.png" alt="holy frege">
    <h3><span>H</span>oly <span>F</span>rege's <span id="note">notes</span></h3>
  </a>
    <small>G.frege를 너무 사랑하는 holy가...</small>  
</header>

<div class="container">
  <div class="page">
    <h1 class="collapsed-title">Problem</h1>    
      <div class="content">
	<a href="http://braindump.frege2godel.me/posts/20211102105107-problem/" alt="Problem" class="permalink"><h1>Problem</h1></a>      
	<p><a href="/posts/20211026143558-algorithms/">Algorithms</a>란건, problem을 푼다는 것이다. problem이 뭔지를 알아야 하고,
푼다는게 어떤 의미인지를 알아야 한다.</p>
<h2 id="problem"><span class="section-num">1</span> Problem</h2>
<h3 id="문제"><span class="section-num">1.1</span> 문제</h3>
<p>문제를 구성하는것은 unknown, data, condition이다. unknown을
찾는것이 문제를 해결하는것이다. unknown은 무한개의 known들 중에서
찾는것이다. 찾는다는 말이 핵심이다. 이미 주어지는 것들중에서 조건에
맞는것을 찾는것이 문제 해결이다. 전제조건으로 우리가 선택할 답들이
이미 있고, 선택할 답들을 condition을 통해 줄여나가서 답이라고
하는것을 찾는것이다. 없는것을 만들어내는게 아니라 이미 있는것에서
선택하는 것이 문제 해결이다.</p>
<h3 id="problem에-대해-떠오르는-생각-and-하나의-값을-갖는-답-여러개의-값을-갖는-답-dot"><span class="section-num">1.2</span> problem에 대해 떠오르는 생각&amp; 하나의 값을 갖는 답, 여러개의 값을 갖는 답.</h3>
<p>problem이라는 단어를 들었을때, 머리속에 언뜻 떠오르는 것은, &ldquo;모르는
것이 있는(미지수가 있는) 문장&quot;이다. 수학에서 미지수로 표현되는 문장이
떠오른다. 예를 들면, x+3 =5나 3x^2=27과 같은 수식이다. 그리고 이런
수식은 법칙을 통해서 다른 모양으로 변경해서 미지수가 특정 값을
지칭하는 문장의 형식으로 바꿔서 답을 구한다. 이게 문제의 본질이고
풀이의 본질 아닐까?  만일 법칙을 모르는 경우, 여러가지값을 넣어서 답을
찾을수도 있다.  수학식같은 경우, 특정 값(scala)이 정답이 된다. 그런데
만일 값이 하나가 아닌 여러개인경우도 있다. 길찾기라던가? 조합문제,
순열문제의 답은 scala값이 아닌 list형태이기도 하다. 문제의 형태에 따라
달라진다. A지점에서 B지점으로 가는 방법은 여러개가 있을 수 있다.
여러개의 경로중 최적의 경로와 같은것은 답이 scala가 아니다. 경로를
나타내는 list가 답인것이다. 정렬도 여러개의 값이 답이라고 볼 수 있다.
이렇게 여러개의 값으로 된게 정답이라면, 각각의 값들을 찾거나 결정하는
과정이 하나의 step(process)으로 볼 수 있고, 이런 순차적인 답을 갖는
여러개의 step이 하나의 정답을 만든다고 볼 수 있다.  ps: problem에
대해서 진지하게 고찰한 책은 <a href="/posts/20211103035920-book_howtosolveit/">[book] HowToSolveIt</a>이란 책이다.  여기서는
problem을 모르는 것을 기술한 문장, 혹은 이뤄야하는 것이 문제라고
기술한다. 그리고 문제에는 data가 주어지며, data와 미지수간의 관계가
주어진다고 한다. 그리고 기술된 문제를 쉬운 다른 문제로 변환하는 과정을
거쳐 답을 구한다고 한다. 즉 문제를 이루는 3가지 구성요소로 다음과 같은
것을 들었다.</p>
<div class="note">
<ul>
<li><strong>unknown</strong></li>
<li><strong>data</strong></li>
<li><strong>condition</strong></li>
</ul>
</div>
<h3 id="모든-문제는-yes-or-no문제로-바꿀수-있다-deterministic-sat문제"><span class="section-num">1.3</span> 모든 문제는 yes or no문제로 바꿀수 있다? deterministic? SAT문제?</h3>
<div class="note">
<p>computer에서 풀수있는 모든 문제는 yes or no문제로 바꿀수 있다고
한다. computer가 nand나 nor로 구성된 system이기 때문에 yes or no문제는
풀수 있다. 그런데 yes or no 문제는 SAT문제로 볼 수 있고, 이 문제들은
CNF나 DNF로 만든다. 왜냐면 훨씬 빠르게 문제를 해결할 수 있기
때문이다. CNF나 DNF로 변환하면, CNF나 DNF를 구성하는 항이 no일 경우
false가 되기 때문이다.</p>
</div>
<h3 id="계산과-함수"><span class="section-num">1.4</span> 계산과 함수</h3>
<p>computer program에서 하는 순수한 계산은 2가지다. 수학적 calculuse인
4칙연산, 논리적 연산 and or not if 연산이다. 그리고 수학에서의
function과 graph는 계산된 값을 mapping하는 연산이다. 이 수학적인
연산도 computer에서는 function으로 처리한다. 우리가 문제를 풀때,
문제의 종류는 3가지 같다. computer로 해결하기위해 만드는 프로그램은
function 하나지만, 순수한 계산문제, function문제, graph문제를 풀 수
있다.</p>
<p>how to solve it이란 책에 보면, data, condition, unknown이란 용어를
설명한다. computer의 계산은 program function에서 한다고 했는데,
입력되는 argument는 how to solve it에서 말한 data에 해당하는 경우가
많다. 물론 받은 data를 가공해서 function을 만든다거나 graph를
만들수도 있는 가능성은 있다. 하지만 보통 function을 design할 때,
입력 arguemnt를 domain으로 처리할 수 있다.</p>
<p>입력 argument는 위에서 말한
data,unknown,condition중에 data가 argument이다. 또한 function을
보면 domain과 codomain을 mapping한다. 보통 domain의 원소들을
codomain에 mapping하기 위해선, for-loop에서 원소의 index를 사용해서
원소를 가리킬 수 있다. 가리키고 있는 원소가 어떤 codomain에
mapping할지는 위에서 말한 계산들을 사용한다. 4칙연산이나, 논리적
연산을 통해서 domain의 원소값을 변경하거나 index를 조작하거나,
codomain의 index를 설정하거나, codomain의 값을 변경하는
것이다. 수학적 function에서 domain이나 codomain은 집합이다. 하지만,
programming에선 function의 argument인 data, 그 data를 domain이라고
한다면, domain의 원소를 가리키기 위해서 index를 사용하기 때문에
집합이 아니라 배열이나 list를 사용해야 만 한다. 우리가 노트에
domain을 나타내기 위해서 diagram을 그려서 하나의 원소를 codomain의
원소로 mapping할 때는 눈에 보이는 원소를 가리킬수 있었지만,
컴퓨터입장에서는 어떤 원소인지를 가리키기 위해선 index를 사용해야
하기때문에 domain의 원소들은 모두 index가 있고, 집합도 아니라는것을
알아야 한다. 문제를 풀때는 함수인지 아니면 graph와 같은
비선형인지를 확인해야 한다. 즉 domain의 원소가 2개이상의 codmain과
mapping되면 graph인데, 이 경우, data structure를 tree나
dictionary를 통해서 domain을 나타낼 수 있다. linear한 경우, 즉
domain의 한 원소가 하나의 codomain의 원소를 mapping 하는 경우엔
domain을 list나 array로 나타낼 수 있다. 따라서 argument에 따라서
구분이 가능한데, 만일 argument가 list나 array일 경우 함수관점에서
처리한다고 보면 되고, dictionary나 tree일 경우 graph관점에서
처리한다고 보면 된다.</p>
<h3 id="재귀함수의-첫번째-예제"><span class="section-num">1.5</span> 재귀함수의 첫번째 예제</h3>
<p>가우스의 덧셈 1에서 10을 더한다고 할때, 1+2&hellip;10까지 순차적으로
더하는 방식이 있을 수 있다. ((1+2)+3).. 2개의 인자를 받는
덧셈함수를 계산하고, 함수값에 다시 인자를 더하고&hellip;for-loop의
방식이다. 가우스는 1과 10을 더하고 2와 9를 더하는 방식이다. 2개의
방식은 다르다. 함수의 설계도 달라진다. add라는 함수를 만든다고
할때, 첫번째 덧셈함수의 인자는 무엇일까? n이라는 하나의 인자?
그리고 내부에서 for-loop를 사용한다면, add라는 함수는 재사용되지
않는다. 반면에 2번째 방식은 인자가 2개다. 시작과 끝값을 주면 두값을
더하고 나머지는 다시 자기자신을 호출하는 방식으로 바꿀 수 있다.</p>
<h3 id="function과-graph"><span class="section-num">1.6</span> function과 graph</h3>
<p>function은 입력이 list나 array로 주어질때 각각의 원소를 4칙연산을
통해서 다른원소를 만들어내거나, and or not으로 다른원소를
만들어낸다. 다른원소를 만든다는것은 codomain의 원소와 mapping한다고
생각해도 된다. 중요한것은 function처럼 domain의 data가 codomain으로
mapping된다는것이다. for-loop이라는게 원소 하나하나를 선택해서
그값을 계산하는것이기 때문에 function처럼 동작한다. 그런데 double
for-loop나 loop가 3개 4개 있는경우를 보자. 이 경우는 조합문제
같은경우에서 나오는데, 이것은 대부분 graph문제다. 하나의
domain원소가 여러개의 codomain원소와 mapping되는 것이다. 예를들어서
어떤순서쌍을 만든다고 하자.(1,1),(1,2),(1,3),(1,4) 1을 선택했을때,
다음에 선택할수 있는 여러 경우의 수가 있다던지 하는경우&hellip; 이경우는
graph문제다. tree구조를 보면 알수 있는게,어떤 부모노드를 선택했을때
자식노드가 3개라는건, domain 원소 1개에 3개의 codomain 원소가
mapping되는 그림이다. tree는 모두 graph구조다. 이런 graph구조는
시간이 많이 걸린다. 모든것을 다해볼려면, 그래서 대부분의 algorithm
문제는 이런 graph문제를 다룬다. brute force, 완전 탐색을 통해서
모든 가능성을 다 해보고, 최적화방식으로 줄이고 dynamic programming,
분할 정복, greedy문제는 모두 graph문제의 처리
방식이다. non-linear한경우를 graph문제라고도 한다. graph문제는
문제를 보면 알수 있다. 하나를 선택했을때 그 선택이 다음 3개중 1개를
선택한다거나 3개를 선택하는 방식이다.  domain의 한 원소를
여러원소에 mapping하는, 하나에 여러 가능성을 mapping하는 모든
문제는 graph다.</p>
<h3 id="계산문제"><span class="section-num">1.7</span> 계산문제</h3>
<p>3+4는 무엇인가? 같은 문제는 함수를 만들고 함수의 인자로 3,4를
입력하면 그 계산값을 return하기 때문에 함수형문제의 일종이다. 즉
domain의 원소 3과 4를 7과 mapping하기 때문이다. 하지만, 함수 문제는
data를 입력받는다. list나 array같이 많은 양의 data를 입력으로 받고,
이를 계산하여 값을 return한다. 물론 이런 계산문제는 함수 내부에서
domain을 만들어서 처리할 수도 있다. 5의 약수는 무엇인가? 라는
질문을 할때, 함수의 입력으로 5를 입력받지만, 내부적으로는
for-loop으로 domain집합을 만들고, 각 원소에 대한 처리를 하기때문에
function으로 볼 수 있다. 이런 경우는 function문제로 취급한다.</p>
<h3 id="function문제"><span class="section-num">1.8</span> function문제</h3>
<p>function문제는 입력데이터로 list나 array같은 domain집합을
입력받을수도 있고, 하나의 data를 받아서 for-loop을 사용해서
domain집합을 for-loop으로 만들수 있다. 중요한것은 for-loop을 하나만
사용한다는 것이다. 그리고 domain 원소 각각에 대한 계산결과가
codomain의 원소가 된다.</p>
<h3 id="graph문제"><span class="section-num">1.9</span> graph문제</h3>
<p>graph문제는 기본적으로 조합문제를 생각하면 된다. 어떤 한 원소를
선택했을때, 그 원소에 따른 선택지가 여러개 있는경우, 혹은 가능성이
여러개 있는 경우는 graph문제다. 보통 2개이상의 for-loop을
사용한다. 예를들어서 1을 선택했을때, 그 다음원소로 2,3,4를 모두
선택하는경우, 1을 선택했을때 그 다음 원소로 2,3,4가 가능한 경우에도
2개의 for-loop을 사용한다. 가능한경우에는 2개의 for-loop다음에 if를
사용한다. 가능여부를 판단해야 하기 때문이다.</p>
<p>그래프 문제는 기본적으로 계산량이 많다. 모든것을 계산하기가
힘들다. 모든것을 계산하는것을 brute force라고 하는데, brute force를
사용하기 어렵다. 따라서 최적화가 필요하다.</p>
<h3 id="function과-함성함수"><span class="section-num">1.10</span> function과 함성함수</h3>
<p>문제의 종류를 보면, function이 가진 domain원소를 처리하는 문제가
있고 sequence같은 문제가 있다. function문제는 관계가 하나이고 모든
원소에 적용되는 문제다. 혹은 관계가 2개일수도 있다. 이런경우 for
loop를 1개 혹은 2개로 표현할 수 있다. 그런데 관계가 많은 경우가
있다. 재귀함수는 함수가 여러개다. 즉 관계가 여러개이다. 이 관계가
1개의 관계가 여러번 적용되는 것일 수도 있고, 여러개의 관계가 섞여서
여러번 진행될수도 있다. 합을 구하는 문제나 피보나치 수열 같은것은
function(관계)가 여러번 있는 것이다. 합성함수나 재귀함수 형태를
말한다. counting문제들이나 sequence문제들에 해당한다. 지수문제도
그렇다. 2의 n승에서 5번째는 5번 함수를 적용한것으로 해석할 수 있다.</p>
<p><a id="figure--function-1"></a></p>
<figure><img src="./img/function_1.png"
         alt="Figure 1: function_1" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 1: </span>function_1</p>
        </figcaption>
</figure>

<p><a id="figure--function-2"></a></p>
<figure><img src="./img/function_2.png"
         alt="Figure 2: function_2" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 2: </span>function_2</p>
        </figcaption>
</figure>

<p><a id="figure--function-3"></a></p>
<figure><img src="./img/function_3.png"
         alt="Figure 3: function_3" width="400px"/><figcaption>
            <p><span class="figure-number">Figure 3: </span>function_3</p>
        </figcaption>
</figure>

      
      </div>
        
  
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
  

  

  </div>
</div>  

<script src="/js/URI.js" type="text/javascript"></script>
<script src="/js/page.js" type="text/javascript"></script>
</body>
</html>
