<!DOCTYPE html>
<html>
  <head><title>web programming</title>


<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes" />

<link rel="shortcut icon" href="./img/favicon.ico" type="image/x-icon">
<link rel="icon" href="./img/favicon.ico" type="image/x-icon">    

<link rel="stylesheet" href="/css/main.css">

</head>
  <body><header>
  <a href="/" id="logo">
    <img src="http://braindump.frege2godel.me/img/mylogo.png" alt="holy frege">
    <h3><span>H</span>oly <span>F</span>rege's <span id="note">notes</span></h3>
  </a>
    <small>G.frege를 너무 사랑하는 holy가...</small>  
</header>

<div class="container">
  <div class="page">
    <h1 class="collapsed-title">web programming</h1>    
      <div class="content">
	<a href="http://braindump.frege2godel.me/posts/web_programming/" alt="web programming" class="permalink"><h1>web programming</h1></a>      
	<h2 id="web-programming이란-dot">web programming이란.</h2>
<p>web programming을 공부하면서 왜 이런 개념이 만들어졌지, 왜 이렇게
사용하는지?라는 질문에 대한 해답은 역사를 통해서 쉽게 이해할 수
있다. 그래서 우리는 역사를 배우는 것이다.</p>
<h2 id="abstract-design">Abstract design</h2>
<h2 id="web-programming-history">web programming history</h2>
<h3 id="최초-1989-90-timothy-berners-lee">최초 [1989-90, Timothy Berners-Lee]</h3>
<p>팀 버너스리가 생각한것은 scientific document의 공유였다.</p>
<p>http통신은 문서를 주고 받는 protocol이다. server가 있고, server의
문서를 client가 요청해서 받는 구조다. 초창기에는 server가 가진
data를 어떻게 하면 대다수 client에게 전달할 것인가를 생각했기
때문에, 통신 protocol은 간단했다. server에 연결한다. server는
client가 요청한 문서의 위치(get url)을 해석하고 해당 html문서(data)를
client에게 보낸다. 그리고 연결을 끊는다.</p>
<p>이때 당시는 client가 문서를 요청하면, server가 보내는 문서는
fax처럼 문서가 출력되는 생각을 했다. 실제로도 server는 문서를
text형태로 그대로 보냈다. 그리고 원래 목적인 불특정 다수가 server에
접속하고 문서를 다운 받게 하는 것이였기 때문에 protocol을 매우
간단하게 했다.</p>
<p>기존의 ftp와 같은 다른 통신방법도 존재했지만, 팀 버나스리의
핵심적인 사상(idea)는 hyperlink라는 개념이다. 일반 문서와 달리
hyper link가 있는 문서를 server가 보내준다는 것이다. 이것은 논문을
흉내 낸것이다. 여러 출처를 명시한 논문처럼 문서에 출처를 hyper
link라는 기술로 대체한 것이다. 이것을 위해서 http protocol,
html이란 기술과 방법이 등장했는데, 이것들은 모두 hyperlink라는
idea를 구체화 시키는 수단이였다.</p>
<h3 id="breakthrough-idea--cgi-css--1993">breakthrough idea(cgi, css) [1993]</h3>
<p>1993년도에 web에 있어서 breakthrough한 idea가 2개 나온다. cgi와
css다.</p>
<h4 id="cgi--common-gateway-interface">cgi(common gateway interface)</h4>
<p>server는 사용자가 요청한 문서를 그대로 보내주기만 했었다.  get
URL이란 명령어를 보내면, server는 URL에 적힌 문서의 위치를 찾아서
문서를 보내주기만 했다. 미리 문서는 server의 해당위치에 만들어져
있었다. 여기서 문제가 생긴다. 미리 만들어놓은 문서는 최신 문서가
아니다. up to date한 문서는 사람이 미리 만들어서 올려야 하는데
이건 여간 성가신 일이 아니였다. 그래서 program을 이용해서 요청이
들어오면 문서를 바로 만들어내는 cgi라는 기술이 사용되게
된다. 동적인 문서를 만들게 되었다라고 흔히 말하지만, 어떻게 보면
최신의 문서를 만들어서 제공하는 break-through한 아이디어다. 또한
client는 원하는 정보를 server에게 parameter형식으로 전달해서
cusom된 문서를 제공받을수도 있게 되었다.</p>
<h4 id="css">css</h4>
<p>server단에서의 이런변화와 더불어, client단에서도 변화가
생긴다. lynx같은 text browser는 server가 보내주는 문서를 보여주긴
하나, 문서라기 보단 프로그램이나 암호문처럼 보였다. 그리고
client의 컴퓨터들이 gui운영체제를 사용하게 되면서, mosaic,
netscape같은 gui browser가 나오면서 문서를 꾸밀수 있게 되었다. 즉
server측에서 html문서만 주는게 아닌, 문서의 모양을 규정한
css파일까지 전달하게 되었다.</p>
<h3 id="breakthrough-idea--javascript--1996">breakthrough idea(javascript) [1996]</h3>
<p>cgi가 server에서 breakthrough한 idea였다면, client side에서
break-through한 idea는 js engine을 browser에 탑재했다는
것이다. 이것은 server에서 문서를 만들고, 만든 문서의
appearance까지 만들어서 client에게 보낸다. 서버에서 모든것을
다하고, client는 단지 전달받은 문서를 보여주는 역할이였다면, js의
탑재는 server가 하던 html문서의 작성, css의 작성까지 모든것을 js로
할수 있다. js는 programming이 가능하기 때문에 data의 생성과 수정이
가능하기 때문이다. html과 css는 단지 data이기 때문이다. 이렇게
js가 css와 html을 만들수 있다는것은 server에선 단지 json파일과
같은 정보만제공하는 방식으로 paradigm이 client로 넘어왔다는 것을
뜻한다. 물론 초창기 js는, 서버가 보내는 html문서와 cs에 대한 작은
수정과 animation, event처리를 했었다. 지금은 rest방식처럼 서버에
대한 역할을 data provider로 한정지어 버렸다.</p>
<h3 id="breakthrough-idea--ajax-xmlhttprequest--2000">breakthrough idea(ajax, xmlhttprequest) [2000~]</h3>
<p>javascript가 browser에 도입되면서 web의 paradigm이 server에서
client로 바뀌었다고 했다. ajax도 client centered한 paradigm에
일조를 한다. 2000년경에 xmlhttprequest라는 기술이 만들어지면서 web
2.0이라고 부를 정도로 breakthrough한 아이디어였다. 이것이 왜
break-through한 아이디어인지 알아보자.</p>
<p>browser에서 server에 URL을 요청하면 server는 해당 문서를 찾아서
전달해준다고 했다. 처음, browser가 url로 html문서에 대한 요청을
하면, server는 그 html문서를 client에게 보내준다. 그런데
html문서를 보면, 모든 resource들을 url을 hyperlink로 표현하고
있다. 그래서, css,js,image,audio,movie 이런 resource들은 모두
URL이 있다. 예를들어, css,js는 html문서에서 header에 있고, logo나
기타 여러 이미지들은 img tag의 src라는 property에서 url이 명기되어
있다. 이말은, html문서를 파싱하면서 URL을 통해 server와 통신을
해서 resource들을 다운받아야 한다는 것이다. 한개의 page를
browser에서 보여주기 위해서, page의 url에 적힌 server와 통신을
해서 다운을 받는다는것은 긴시간이 걸릴 수 있다. browser화면이
먹통되는 것이다. 네트웍속도가 느렸던 2000년대만 하더라도, 이미지가
많은 한개의 page를 보여주는것도 하세월이였다. 이 문제를 해결한
것이 바로 ajax다. 비동기적 통신 방법이다.  예를
들어보자. webpage가 다음과 같다고 하자.</p>
<div class="important">
<p>&lt;head&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h3&gt; this is a image
&lt;img src= &ldquo;<img src="http://a/a.png" alt="">&quot;&gt; ;;30초
&lt;h3&gt; this is b image
&lt;img src= &ldquo;<img src="http://a/b.png" alt="">&quot;&gt; ;; 30초
&lt;h3&gt; this is c audio
&lt;audio src= &ldquo;<a href="http://a/c.mp3">http://a/c.mp3</a>&gt; ;; 3분
&lt;/body&gt;</p>
</div>
<p>이 webpage를 보여주기 위해서는 a image를 다운하고, b를 다운하고,
c를 다운받아야 한다. 그러면 도합 4분이 걸린다. 이것을 해결한
기술이 ajax인것이다. ajax는 동기적이 아니다. 즉 a,b,c가
다운받을때까지 기다리지 않는다. 단지 placeholder만 남겨놓고 바로
화면에 보여준다. 완료가 되면 보여준다. 즉 ajax를 사용하면 page를
보여줄때 먹통되는것을 막아줄 수 있다.</p>
<h3 id="javascript와-ajax의-혁명적-변화">javascript와 ajax의 혁명적 변화</h3>
<p>website를 만들때, client에서 resource의 url이 아닌 page URL을
요청하면 server의 backend에서 java,ruby,python같은 언어로 만들어진
pre-built된 page가 있었다. jsp,php같은 prebuilt된 file들은 요청이
들어오면 placeholder혹은 blank로 되어 있는 부분을 db에서 가져와서
page를 완성해서 client에 보냈다. 그리고 client는 그 page를
browser의 window에 보여줬다. 하나의 page는 browser의 화면인
window와 대응되었다. 한개의 page가 하나의 화면에 대응되는건
확장하면 하나의 page url이 browser의 하나의 화면을 나타낸다고 볼
수 있다. 여태껏 모든 website는 그랬다. 하나의 page url이 하나의
화면을 나타낸것이다. 따라서 다음 화면은 또다른 page url의 요청으로
page를 다운받아서 보여주는 식이였다. 그런데, ajax는 미리 page를
가져올수 있다. 그리고 javascript는 실제 browser의 window에
보여주는 화면을 재구성할 수 있다. 이 말은 예전에는 browser의 화면
하나하나가 하나의 page와 대응된거라면, 지금은 여러개의 page를
가져와서 하나의 화면에 나타낼 수도 있는것이다. javascript와 ajax를
사용하면 가능하다.</p>
<h3 id="my-website">my website</h3>
<p>나는 javascript와 ajax를 사용해서 여러 page들을 하나의 화면에
graph형태로 그리고 여러개의 page를 하나의 browser window에
나타낼려고 한다.</p>
      
      </div>
        
  
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
    
     
  

  

  </div>
</div>  

<script src="/js/URI.js" type="text/javascript"></script>
<script src="/js/page.js" type="text/javascript"></script>
</body>
</html>
